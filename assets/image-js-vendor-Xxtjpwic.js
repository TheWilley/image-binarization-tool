import{M as S,x as gt,T as St,r as Xt,D as mt,B as Vt,i as xe,a as be,b as kt,q as Rt,k as pe,l as Me,c as ft}from"./vendor-5d10CC1f.js";function ge(t,e){return{column:t.column-e.column,row:t.row-e.row}}function me(t){const e=Math.hypot(t.column,t.row);return{column:t.column/e,row:t.row/e}}function G(t,e){const n=[],r=Math.cos(t),o=Math.sin(t);for(const l of e)n.push({column:r*l.column-o*l.row,row:o*l.column+r*l.row});return n}function H(t,e){const n=ge(e,t),r=me(n),o=Math.acos(r.column);return r.row<0?-o:o}function bt(t){return t*180/Math.PI}function dt(t){if(t%2!==1||t<0)throw new RangeError("size must be positive and odd");return(t-1)/2}function jt(t){const e=[];for(let n=0;n<t.length;n++)t[n].column===t[(n+1)%t.length].column&&t[n].row===t[(n+1)%t.length].row||e.push(t[n]);return e}function C(t,e,n,r=0){return(e*n.width+t)*n.channels+r}const Ve=new Intl.ListFormat("en",{type:"disjunction"});function B(t,e={}){let{bitDepth:n,alpha:r,colorModel:o,components:l,channels:i}=e;if(n&&(Array.isArray(n)||(n=[n]),!n.includes(t.bitDepth)))throw new RangeError(`image bitDepth must be ${W(n)} to apply this algorithm`);if(r&&(Array.isArray(r)||(r=[r]),!r.includes(t.alpha)))throw new RangeError(`image alpha must be ${W(r)} to apply this algorithm`);if(o&&(Array.isArray(o)||(o=[o]),!o.includes(t.colorModel)))throw new RangeError(`image colorModel must be ${W(o)} to apply this algorithm`);if(l&&(Array.isArray(l)||(l=[l]),!l.includes(t.components))){const c=`image components must be ${W(l)} to apply this algorithm`;throw l.length===1&&l[0]===1?new RangeError(`${c}. The image can be converted using "image.grey()"`):new RangeError(c)}if(i&&(Array.isArray(i)||(i=[i]),!i.includes(t.channels)))throw new RangeError(`image channels must be ${W(i)} to apply this algorithm`)}function W(t){return Ve.format(t.map(String))}const Re=[[-1,0,1],[-2,0,2],[-1,0,1]],Be=[[-1,-2,-1],[0,0,0],[1,2,1]],Ie=[[3,0,-3],[10,0,-10],[3,0,-3]],ve=[[3,10,3],[0,0,0],[-3,-10,-3]],Ee=[[1,0,-1],[1,0,-1],[1,0,-1]],Ae=[[1,1,1],[0,0,0],[-1,-1,-1]];function T(t,e){if(!t)throw new Error(e||"unreachable")}function Ce(t){throw new Error(`unreachable: ${String(t)}`)}function X(t){return t.maxValue===255?Pe:(T(t.maxValue===65535),De)}function Pe(t){return Math.min(Math.max(t,0),255)}function De(t){return Math.min(Math.max(t,0),65535)}function ot(t,e){for(const n of t)J(n,e)}function J(t,e){if(!Number.isInteger(t)||t>=e.channels||t<0)throw new RangeError(`invalid channel: ${t}. It must be a positive integer smaller than ${e.channels}`)}function ze(t,e){for(const n of t)_(n,e)}function _(t,e){if(t>e.maxValue||t<0)throw new RangeError(`invalid value: ${t}. It must be a positive value smaller than ${e.maxValue+1}`)}function Ht(t,e){if(t.width!==e.width||t.height!==e.height)throw new RangeError("both images must have the same size");if(t.alpha!==e.alpha||t.bitDepth!==e.bitDepth)throw new RangeError("both images must have the same alpha and bitDepth");if(t.channels!==e.channels)throw new RangeError("both images must have the same number of channels")}function O(t,e){J(t.length-1,e),ze(t,e)}function Te(t,e,n={}){const{channels:r=new Array(t.channels).fill(0).map((l,i)=>i)}=n;if(ot(r,t),e===0)throw new TypeError("Cannot divide by 0");const o=I(t,n,{clone:!0});if(r.length===0)return o;for(const l of r)for(let i=0;i<o.height;i++)for(let c=0;c<o.width;c++){const s=o.getValue(c,i,l)/e;o.setClampedValue(c,i,l,s)}return o}function L(t){return S(t.colorModel).with("GREY",()=>[0]).with("GREYA",()=>[0,t.maxValue]).with("RGB",()=>[0,0,0]).with("RGBA",()=>[0,0,0,t.maxValue]).with("BINARY",()=>[1]).exhaustive()}function pt(t,e,n,r){if(r=r??L(t),!t.alpha)t.setPixel(e,n,r);else{T(t instanceof V);const o=r.at(-1);if(o===t.maxValue){t.setPixel(e,n,r);return}const l=t.getValue(e,n,t.channels-1),i=o+l*(1-o/t.maxValue);t.setValue(e,n,t.channels-1,i);for(let c=0;c<t.components;c++){const s=r[c],h=t.getValue(e,n,c),u=(s*o+h*l*(1-o/t.maxValue))/i;t.setValue(e,n,c,u)}}}function z(t,e,n,r){e>=0&&e<t.width&&n>=0&&n<t.height&&pt(t,e,n,r)}function Ye(t){return{row:Math.round(t.row),column:Math.round(t.column)}}function $e(t,e,n,r={}){const o=I(t,r,{clone:!0}),{strokeColor:l=L(o),fillColor:i}=r;if(O(l,o),B(o,{bitDepth:[8,16]}),n<0)throw new RangeError("circle radius must be positive");if(e=Ye(e),n=Math.round(n),n===0)return z(o,e.column,e.row,l),o;if(!i)gt(e.column,e.row,n,(c,s)=>{z(o,c,s,l)});else{n===1&&z(o,e.column,e.row,i);let c=e.row+n,s=0;gt(e.column,e.row,n,(h,u)=>{z(o,h,u,l),s===0&&o.drawLine({row:u,column:h-1},{row:u,column:e.column-(h-e.column-1)},{strokeColor:i,out:o}),s%4===1&&c!==u&&(o.drawLine({row:u,column:h+1},{row:u,column:e.column-(h-e.column+1)},{strokeColor:i,out:o}),c=u,o.drawLine({row:e.row-(u-e.row),column:h+1},{row:e.row-(u-e.row),column:e.column-(h-e.column+1)},{strokeColor:i,out:o})),s++})}return o}function Ge(t,e,n,r={}){const o=I(t,r,{clone:!0}),{strokeColor:l=L(o),origin:i={column:0,row:0}}=r;return O(l,o),B(o,{bitDepth:[8,16]}),St(Math.round(i.column+e.column),Math.round(i.row+e.row),Math.round(i.column+n.column),Math.round(i.row+n.row),(c,s)=>{z(o,c,s,l)}),o}function Oe(t,e,n,r={}){const{origin:o={column:0,row:0}}=r,l=Y(t,r,{clone:!0});return St(Math.round(o.column+e.column),Math.round(o.row+e.row),Math.round(o.column+n.column),Math.round(o.row+n.row),(i,c)=>{l.setVisiblePixel(i,c,[1])}),l}function Fe(t,e,n={}){const{strokeColor:r=L(t),origin:o={column:0,row:0}}=n;B(t,{bitDepth:[8,16]});const l=I(t,n,{clone:!0});O(r,l);for(let i=0;i<e.length-1;i++){const c=e[i],s=e[i+1];l.drawLine(c,s,{out:l,strokeColor:r,origin:o})}return l}function Le(t,e,n={}){const r=Y(t,n,{clone:!0});for(let o=0;o<e.length-1;o++){const l=e[o],i=e[o+1];r.drawLine(l,i,{out:r,origin:n.origin})}return r}function Ut(t){const e=[];for(const n of t)e.push([n.column,n.row]);return e}function Ne(t,e,n={}){const{fillColor:r,origin:o={column:0,row:0},...l}=n;B(t,{bitDepth:[8,16]});const i=I(t,n,{clone:!0});if(r===void 0)return i.drawPolyline([...e,e[0]],{origin:o,...l});{O(r,i);const c=jt(e),s=Ut(c);for(let h=0;h<i.height;h++)for(let u=0;u<i.width;u++)Xt(s,[u,h])===-1&&z(i,Math.round(o.column)+u,Math.round(o.row)+h,r)}return i.drawPolyline([...e,e[0]],{origin:o,...l})}function Se(t,e,n={}){const{filled:r=!1,origin:o={column:0,row:0},...l}=n,i=Y(t,n,{clone:!0});if(!r)return i.drawPolyline([...e,e[0]],{origin:o,...l});const c=jt(e),s=Ut(c);for(let h=0;h<i.height;h++)for(let u=0;u<i.width;u++)Xt(s,[u,h])===-1&&i.setBit(Math.round(o.column)+u,Math.round(o.row)+h,1);return i.drawPolyline([...e,e[0]],{origin:o,...l})}function Wt(t,e={}){const{width:n=t.width,height:r=t.height,origin:o={column:0,row:0},strokeColor:l=L(t),fillColor:i}=e,c=Math.round(n),s=Math.round(r),h=Math.round(o.column),u=Math.round(o.row);let a;t instanceof V?(B(t,{bitDepth:[8,16]}),O(l,t),i&&O(i,t),a=I(t,e,{clone:!0})):a=Y(t,e,{clone:!0});for(let d=h;d<h+c;d++)z(a,d,u,l),z(a,d,u+s-1,l);for(let d=u+1;d<u+s-1;d++)z(a,h,d,l),z(a,h+c-1,d,l);if(i)for(let d=u+1;d<u+s-1;d++)for(let f=h+1;f<h+c-1;f++)z(a,f,d,i);return a}function qt(t,e,n={}){const{color:r=L(t),origin:o={row:0,column:0}}=n;let l;t instanceof V?(l=I(t,n,{clone:!0}),O(r,l)):l=Y(t,n,{clone:!0}),B(l,{bitDepth:[1,8,16]});for(const i of e)z(l,Math.round(o.column+i.column),Math.round(o.row+i.row),r);return l}function Kt(t,e,n){const r=I(t,n,{clone:!0}),{strokeColor:o=L(r),fillColor:l,shape:i="cross",size:c=1}=n,s=Math.round(c);if(O(o,r),l&&O(l,r),B(r,{bitDepth:[8,16]}),i==="circle"&&r.drawCircle(e,s,{strokeColor:o,fillColor:l,out:r}),i==="triangle"){const h=[{row:e.row-s,column:e.column},{row:e.row,column:e.column+s},{row:e.row,column:e.column-s}];r.drawPolygon(h,{strokeColor:o,fillColor:l,out:r})}if(i==="cross"&&(r.drawLine({row:e.row-s,column:e.column},{row:e.row+s,column:e.column},{strokeColor:o,out:r}),r.drawLine({row:e.row,column:e.column-s},{row:e.row,column:e.column+s},{strokeColor:o,out:r})),i==="square"){const h={row:e.row-(s-1)/2,column:e.column-(s-1)/2};r.drawRectangle({origin:h,width:s,height:s,strokeColor:o,fillColor:l,out:r})}return r}function Xe(t,e,n={}){const r=I(t,n,{clone:!0});for(const o of e)Kt(r,o,{...n,out:r});return r}function ke(t,e,n){const r=Y(t,n);if(t.width!==e.width||t.height!==e.height)throw new RangeError("both masks must have the same size");for(let o=0;o<r.size;o++)t.getBitByIndex(o)&&e.getBitByIndex(o)?r.setBitByIndex(o,1):r.setBitByIndex(o,0);return r}function lt(t,e){return S(t).with("constant",()=>je(e)).with("replicate",()=>He).with("reflect",()=>Ue).with("reflect101",()=>qe).with("wrap",()=>We).exhaustive()}function it(t,e){if(t<=0-e||t>=e+e-1)throw new RangeError("border must be smaller than the original image")}function je(t){return function(n,r,o,l){const i=Bt(n,l.width),c=Bt(r,l.height);return i===-1||c===-1?t:l.getValue(i,c,o)}}function Bt(t,e){return t>=0&&t<e?t:-1}function He(t,e,n,r){return r.getValue(It(t,r.width),It(e,r.height),n)}function It(t,e){return t>=0&&t<e?t:(it(t,e),t<0?0:e-1)}function Ue(t,e,n,r){return r.getValue(vt(t,r.width),vt(e,r.height),n)}function vt(t,e){return t>=0&&t<e?t:(it(t,e),t<0?-1-t:e+e-1-t)}function We(t,e,n,r){return r.getValue(Et(t,r.width),Et(e,r.height),n)}function Et(t,e){return t>=0&&t<e?t:(it(t,e),t<0?e+t:t-e)}function qe(t,e,n,r){return r.getValue(At(t,r.width),At(e,r.height),n)}function At(t,e){return t>=0&&t<e?t:(it(t,e),t<0?0-t:e+e-2-t)}function Ke(t,e){const{horizontal:n,vertical:r,borderType:o="reflect101",borderValue:l=0}=e,i=lt(o,l),c=V.createFrom(t,{width:t.width+2*n,height:t.height+2*r});t.copyTo(c,{origin:{column:n,row:r},out:c});for(let s=0;s<r;s++)for(let h=0;h<c.width;h++)for(let u=0;u<t.channels;u++){const a=i(h-n,s-r,u,t);c.setValue(h,s,u,a)}for(let s=c.height-r;s<c.height;s++)for(let h=0;h<c.width;h++)for(let u=0;u<t.channels;u++){const a=i(h-n,s-r,u,t);c.setValue(h,s,u,a)}for(let s=r;s<c.height-r;s++)for(let h=0;h<n;h++)for(let u=0;u<t.channels;u++){const a=i(h-n,s-r,u,t);c.setValue(h,s,u,a)}for(let s=r;s<c.height-r;s++)for(let h=c.width-n;h<c.width;h++)for(let u=0;u<t.channels;u++){const a=i(h-n,s-r,u,t);c.setValue(h,s,u,a)}return c}function U(t){const e=Math.trunc(t),n=t-e;return n<.5?e:n>.5?e+1:e%2===0?e:e+1}function _e(t,e,n={}){const{borderType:r="reflect101",borderValue:o=0}=n,l=_t(t,e,{borderType:r,borderValue:o}),i=I(t,n),c=X(i);for(let s=0;s<t.size;s++)for(let h=0;h<t.channels;h++){const u=s*t.channels+h,a=U(c(l[u]));i.setValueByIndex(s,h,a)}return i}function _t(t,e,n={}){const{borderType:r="reflect101",borderValue:o=0}=n,l=lt(r,o),i=new Float64Array(t.size*t.channels);for(let c=0;c<t.channels;c++)for(let s=0;s<t.height;s++)for(let h=0;h<t.width;h++){const u=C(h,s,t,c);i[u]=Ze(h,s,c,t,e,l,{returnRawValue:!0})}return i}function rt(t,e,n,r={}){const{normalize:o,borderType:l="reflect101",borderValue:i=0}=r;o&&([e,n]=Je(e,n));const s=(e.length-1)/2,u=(n.length-1)/2,a=Ke(t,{horizontal:s,vertical:u,borderType:l,borderValue:i}),d=V.createFrom(t),f=X(d),w=new mt(a.width,e,Vt.CUT),g=new mt(a.height,n,Vt.CUT),x=new Float64Array(a.width),y=new Float64Array(a.height),p=new Float64Array(t.width*a.height);for(let m=0;m<a.channels;m++){for(let R=0;R<a.height;R++){for(let M=0;M<a.width;M++)x[M]=a.getValue(M,R,m);const b=w.convolve(x);for(let M=0;M<t.width;M++)p[R*t.width+M]=b[M]}for(let R=0;R<t.width;R++){for(let M=0;M<a.height;M++)y[M]=p[M*t.width+R];const b=g.convolve(y);for(let M=0;M<t.height;M++)d.setValue(R,M,m,U(f(b[M])))}}return d}function Ze(t,e,n,r,o,l,i={}){let{clamp:c}=i;const{returnRawValue:s=!1}=i;s&&(c=void 0);let h=0;const u=o[0].length,a=o.length,d=(u-1)/2,f=(a-1)/2;for(let w=0;w<a;w++)for(let g=0;g<u;g++){const x=o[w][g];h+=x*l(t+g-d,e+w-f,n,r)}return c?U(c(h)):h}function Je(t,e){const n=t.reduce((i,c)=>i+c,0),r=e.reduce((i,c)=>i+c,0),o=n*r;if(o<0)throw new RangeError("this separated kernel cannot be normalized");const l=1/Math.sqrt(Math.abs(o));return[t.map(i=>i*l),e.map(i=>i*l)]}function Qe(t,e){const{width:n,height:r}=e;if(n<1||n%2===0)throw new RangeError(`Invalid property "width". Must be an odd number greater than 0. Received ${n}.`);if(r<1||r%2===0)throw new RangeError(`Invalid property "height". Must be an odd number greater than 0. Received ${r}.`);const o=new Array(n).fill(1),l=new Array(r).fill(1);return rt(t,o,l,{normalize:!0,...e})}function tn(t,e={}){const{filter:n="sobel"}=e,r=S(n).with("sobel",()=>({kernelX:Re,kernelY:Be})).with("scharr",()=>({kernelX:Ie,kernelY:ve})).with("prewitt",()=>({kernelX:Ee,kernelY:Ae})).exhaustive();return t.gradientFilter({...r,...e})}const Ct={GREYA:"GREYA",RGBA:"RGBA"},Zt={GREY:{components:1,alpha:!1,channels:1},GREYA:{components:1,alpha:!0,channels:2},RGB:{components:3,alpha:!1,channels:3},RGBA:{components:3,alpha:!0,channels:4},BINARY:{components:1,alpha:!1,channels:1}};function en(t,e={}){const{uniform:n=!1}=e;B(t,{bitDepth:[8,16]});const r=t.minMax();let o=r.min,l=r.max;if(n){let c=-1,s=-1;for(let h=0;h<r.max.length;h++){const u=r.max[h]-r.min[h];u>s&&(c=h,s=u)}o=r.min[c],l=r.max[c]}let i=new Array(t.components).fill(0).map((c,s)=>s);return t.colorModel===Ct.GREYA?i=[0]:t.colorModel===Ct.RGBA&&(i=[0,1,2]),t.level({inputMin:o,inputMax:l,outputMin:0,outputMax:t.maxValue,channels:i,...e})}function nn(t,e){if("sigma"in e){const{sigma:n,size:r=yt(n),borderType:o}=e,l=dt(r),i=wt(l,n);return rt(t,i,i,{borderType:o})}else if("sigmaX"in e&&"sigmaY"in e){const{sigmaX:n,sigmaY:r,sizeX:o=yt(n),sizeY:l=yt(r),borderType:i}=e,c=dt(o),s=dt(l),h=wt(c,n),u=wt(s,r);return rt(t,h,u,{borderType:i})}else throw new TypeError("you must either define sigma or sigmaX and sigmaY in the options argument")}function wt(t,e){const n=t*2+1,r=new Array(n),o=e||((n-1)*.5-1)*.3+.8,l=-.5/(o*o);let i=0;for(let c=0;c<n;c++){const s=c-t,h=Math.exp(l*s*s);r[c]=h,i+=h}for(let c=0;c<n;c++)r[c]/=i;return r}function yt(t){return 2*Math.ceil(2*t)+1}function rn(t,e){const{borderType:n="replicate",borderValue:r=0}=e;if(B(t,{bitDepth:[8,16],colorModel:"GREY"}),"kernelX"in e&&"kernelY"in e){const{kernelX:o,kernelY:l}=e,i=t.rawDirectConvolution(o,{borderType:n,borderValue:r}),c=t.rawDirectConvolution(l,{borderType:n,borderValue:r}),s=new V(t.width,t.height,{colorModel:"GREY"});for(let h=0;h<t.size;h++)s.setValueByIndex(h,0,Math.hypot(i[h],c[h]));return s}else{if("kernelX"in e)return t.directConvolution(e.kernelX,{borderType:n,borderValue:r});if("kernelY"in e)return t.directConvolution(e.kernelY,{borderType:n,borderValue:r});throw new TypeError("kernelX and KernelY are not defined")}}function on(t,e,n={}){const{channels:r=new Array(t.components).fill(0).map((l,i)=>i)}=n;if(B(t,{bitDepth:[8,16]}),t.width!==e.width||t.height!==e.height)throw new RangeError("both images must have the same size");if(t.alpha!==e.alpha||t.bitDepth!==e.bitDepth)throw new RangeError("both images must have the same alpha and bitDepth");if(t.channels!==e.channels)throw new RangeError("both images must have the same number of channels");ot(r,t);const o=I(t,{},{clone:!0});for(const l of r)for(let i=0;i<t.size;i++){const c=Math.hypot(t.getValueByIndex(i,l),e.getValueByIndex(i,l));o.setValueByIndex(i,l,Math.min(c,o.maxValue))}return o}function Jt(t,e,n={}){const r=new Map([["GREY",["GREYA","RGB","RGBA"]],["GREYA",["GREY","RGB","RGBA"]],["RGB",["GREY","GREYA","RGBA"]],["RGBA",["GREY","GREYA","RGB"]],["BINARY",["GREY","RGB","RGBA"]]]);if(t.colorModel===e&&e!=="BINARY")return I(t,{out:n.out},{clone:!0});if(!r.get(t.colorModel)?.includes(e))throw new RangeError(`conversion from ${t.colorModel} to ${e} not implemented`);if(t instanceof V){const l=I(t,n,{newParameters:{colorModel:e}});return(t.colorModel==="GREY"||t.colorModel==="GREYA")&&ln(t,l),(t.colorModel==="RGB"||t.colorModel==="RGBA")&&(e==="RGB"||e==="RGBA"?cn(t,l):sn(t,l)),!t.alpha&&l.alpha&&l.fillAlpha(l.maxValue),t.alpha&&l.alpha&&Qt(t,l),l}else if(e==="GREY"){const l=po(t,n);return hn(t,l),l}else{const l=new V(t.width,t.height,{colorModel:e});return un(t,l),l}}function Qt(t,e){if(t.size!==e.size)throw new RangeError("source and destination have different sizes");if(!t.alpha)throw new RangeError("source image does not have alpha");if(!e.alpha)throw new RangeError("destination does not have alpha");for(let n=0;n<e.size;n++)e.setValueByIndex(n,e.channels-1,t.getValueByIndex(n,t.channels-1))}function ln(t,e){for(let n=0;n<t.size;n++)for(let r=0;r<e.components;r++)e.setValueByIndex(n,r,t.getValueByIndex(n,0))}function cn(t,e){for(let n=0;n<t.size;n++)for(let r=0;r<3;r++)e.setValueByIndex(n,r,t.getValueByIndex(n,r))}function sn(t,e){for(let n=0;n<t.size;n++){const r=t.getValueByIndex(n,0),o=t.getValueByIndex(n,1),l=t.getValueByIndex(n,2);e.setValueByIndex(n,0,Math.round(.299*r+.587*o+.114*l))}}function hn(t,e){for(let n=0;n<t.size;n++)e.setValueByIndex(n,0,t.getBitByIndex(n)?e.maxValue:0)}function un(t,e){const n=new Array(e.components).fill(0),r=new Array(e.components).fill(e.maxValue);e.alpha&&(n.push(e.maxValue),r.push(e.maxValue));for(let o=0;o<t.size;o++)e.setPixelByIndex(o,t.getBitByIndex(o)?r:n)}function an(t,e,n={}){if(t.bitDepth===e)return I(t,n,{clone:!0});if(e!==8&&e!==16)throw new RangeError(`This image bit depth is not supported: ${e}`);const r=I(t,n,{clone:!1,newParameters:{bitDepth:e,colorModel:t.colorModel}});return e===8?dn(t,r):fn(t,r)}function fn(t,e){for(let n=0;n<t.size;n++)for(let r=0;r<e.channels;r++)e.setValueByIndex(n,r,t.getValueByIndex(n,r)<<8);return e}function dn(t,e){for(let n=0;n<t.size;n++)for(let r=0;r<e.channels;r++)e.setValueByIndex(n,r,t.getValueByIndex(n,r)>>8);return e}function Q(t,e="Point"){if(!Number.isInteger(t.row)||!Number.isInteger(t.column))throw new TypeError(`${e} row and column must be integers`)}function wn(t,e,n={}){const{origin:r={row:0,column:0}}=n,{row:o,column:l}=r;T(o<t.height&&l<t.width&&o+e.width>0&&l+e.height>0,"extract: image and mask have no overlap"),Q(r,"Origin");const i=Math.min(t.width,e.width+l)-Math.max(0,l),c=Math.min(t.height,e.height+o)-Math.max(0,o);let s=new V(i,c,{colorModel:t.colorModel,origin:r});s.alpha&&(s=s.fillAlpha(0));const h=Math.max(0,o),u=Math.max(0,l),a=o<0?-o:0,d=l<0?-l:0;for(let f=0;f<c;f++)for(let w=0;w<i;w++)e.getBit(d+w,a+f)&&s.setPixel(w,f,t.getPixel(u+w,h+f));return s}function yn(t){const e=[];for(let n=0;n<t.channels;n++){const r=V.createFrom(t,{colorModel:"GREY"});for(let o=0;o<r.size;o++)r.setValueByIndex(o,0,t.getValueByIndex(o,n));e.push(r)}return e}function xn(t){let e=0;for(let u=0;u<t.length;u++)if(t[u]!==0){e=u;break}let n=t.length-1;for(let u=t.length-1;u>=e;u--)if(t[u]!==0){n=u;break}const r=1/(n-e),o=new Array(t.length);let l=0,i=0;for(let u=e;u<t.length;u++)l+=u*t[u],i+=t[u],o[u]=l/i;const c=new Array(t.length);l=0,i=0;for(let u=n;u>0;u--)l+=u*t[u],i+=t[u],c[u-1]=l/i;let s=-1,h=Number.MAX_VALUE;for(let u=0;u<t.length;u++){let a=0,d;for(let f=0;f<=u;f++)d=1/(1+r*Math.abs(f-o[u])),d<1e-6||d>.999999||(a+=t[f]*(-d*Math.log(d)-(1-d)*Math.log(1-d)));for(let f=u+1;f<t.length;f++)d=1/(1+r*Math.abs(f-c[u])),d<1e-6||d>.999999||(a+=t[f]*(-d*Math.log(d)-(1-d)*Math.log(1-d)));a<h&&(h=a,s=u)}return s}function bn(t){const e=t.slice();let n=0;for(;!pn(e);){let o=0,l=0,i=e[0];for(let c=0;c<t.length-1;c++)o=l,l=i,i=e[c+1],e[c]=(o+l+i)/3;e[t.length-1]=(l+i)/3,n++,T(n<1e3,"Intermodes threshold not found after 1000 iterations")}let r=0;for(let o=1;o<t.length-1;o++)e[o-1]<e[o]&&e[o+1]<e[o]&&(r+=o);return Math.floor(r/2)}function pn(t){let e=!1,n=0;for(let r=1;r<t.length-1;r++)if(t[r-1]<t[r]&&t[r+1]<t[r]&&(n++,n>2))return!1;return n===2&&(e=!0),e}function Mn(t){let e,n,r,o,l=0;for(let i=1;i<t.length;i++)if(t[i]>0){l=i+1;break}for(;;){e=0,r=0;for(let i=0;i<l;i++)r=r+t[i],e=e+t[i]*i;o=0,n=0;for(let i=l+1;i<t.length;i++)n+=t[i],o+=t[i]*i;if(r>0&&n>0&&(e/=r,o/=n,l===Math.round((e+o)/2)))break;l++,T(l<=t.length-2,"Threshold not found")}return l}function gn(t,e){let n,r,o,l,i,c,s,h,u,a,f;a=0;for(let w=0;w<t.length;w++)a+=w*t[w];a/=e,s=a;do{c=s,n=c+.5|0,r=0,l=0;for(let w=0;w<=n;w++)r+=w*t[w],l+=t[w];h=l===0?0:r/l,o=0,i=0;for(let w=n+1;w<t.length;w++)o+=w*t[w],i+=t[w];u=i===0?0:o/i,f=(h-u)/(Math.log(h)-Math.log(u)),f<-Number.EPSILON?s=f-.5|0:s=f+.5|0}while(Math.abs(s-c)>.5);return n}function mn(t,e){const n=new Array(t.length);for(let d=0;d<t.length;d++)n[d]=t[d]/e;const r=new Array(t.length),o=new Array(t.length);r[0]=n[0],o[0]=1-r[0];for(let d=1;d<t.length;d++)r[d]=r[d-1]+n[d],o[d]=1-r[d];let l=0;for(let d=0;d<t.length;d++)if(Math.abs(r[d])>=Number.EPSILON){l=d;break}let i=t.length-1;for(let d=t.length-1;d>=l;d--)if(Math.abs(o[d])>=Number.EPSILON){i=d;break}let c=-1,s,h=Number.MIN_VALUE,u,a;for(let d=l;d<=i;d++){u=0;for(let f=0;f<=d;f++)t[f]!==0&&(u-=n[f]/r[d]*Math.log(n[f]/r[d]));a=0;for(let f=d+1;f<t.length;f++)t[f]!==0&&(a-=n[f]/o[d]*Math.log(n[f]/o[d]));s=u+a,h<s&&(h=s,c=d)}return c}function Vn(t,e){let n=0;for(let r=0;r<t.length;r++)n+=r*t[r];return Math.floor(n/e)}function Rn(t,e){let n,r=-2,o,l,i,c,s,h,u,a,d,f,w,g=0;for(let x=0;x<t.length;x++)g+=x*t[x];for(g/=e,n=g;n!==r;){const x=Pt(t,n),y=Pt(t,t.length-1),p=Dt(t,n),m=Dt(t,t.length-1),R=zt(t,n),b=zt(t,t.length-1);if(o=p/x,l=(m-p)/(y-x),i=x/y,c=(y-x)/y,s=R/x-o*o,h=(b-R)/(y-x)-l*l,u=1/s-1/h,a=o/s-l/h,d=o*o/s-l*l/h+Math.log10(s*(c*c)/(h*(i*i))),f=a*a-u*d,f<0)return n;r=n,w=(a+Math.sqrt(f))/u,Number.isNaN(w)?n=r:n=Math.floor(w)}return n}function Pt(t,e){let n=0;for(let r=0;r<=e;r++)n+=t[r];return n}function Dt(t,e){let n=0;for(let r=0;r<=e;r++)n+=r*t[r];return n}function zt(t,e){let n=0;for(let r=0;r<=e;r++)n+=r*r*t[r];return n}function Bn(t){if(t.length<2)return 0;let e=0,n=-1,r=-1,o=new Array(t.length);for(let l=0;l<t.length;l++)o[l]=t[l],t[l]>0&&(r=l);for(;!vn(o);)if(o=In(o),e++,e>1e4)return n;for(let l=1;l<r;l++)if(o[l-1]>o[l]&&o[l+1]>=o[l]){n=l;break}return n}function In(t){const e=new Array(t.length);for(let n=1;n<t.length-1;n++)e[n]=(t[n-1]+t[n]+t[n+1])/3;return e[0]=(t[0]+t[1])/3,e[t.length-1]=(t.at(-2)+t.at(-1))/3,e}function vn(t){const e=t.length;let n=!1,r=0;for(let o=1;o<e-1;o++)if(t[o-1]<t[o]&&t[o+1]<t[o]&&(r++,r>2))return!1;return r===2&&(n=!0),n}function En(t,e){let r=0,o=0,l=0,i=0,c=-1;const s=t.length,h=[];for(let x=0;x<s;x++)h.push(t[x]/e);for(let x=0;x<s;x++)r+=x*h[x],o+=x*x*h[x],l+=x*x*x*h[x];const u=1*o-r*r,a=(-o*o+r*l)/u,d=(1*-l+o*r)/u,f=.5*(-d-Math.sqrt(d*d-4*a)),w=.5*(-d+Math.sqrt(d*d-4*a)),g=(w-r)/(w-f);for(let x=0;x<s;x++)if(i+=h[x],i>g){c=x;break}return c}function An(t,e){let n=0,r=0,o=0,l=0,i=0;for(let c=0;c<t.length;c++)i+=c*t[c];for(let c=0;c<t.length;c++){r=r+t[c];const s=e-r;if(r===0||s===0)continue;n=n+c*t[c];const h=(i-n)/s,u=r*s*(n/r-h)*(n/r-h);u>=o&&(l=c,o=u)}return l}function Cn(t){let e=-1;const n=.5,r=new Array(t.length),o=Tt(t,t.length-1);let l=1;for(let i=0;i<t.length;i++)r[i]=Math.abs(Tt(t,i)/o-n),r[i]<l&&(l=r[i],e=i);return e}function Tt(t,e){let n=0;for(let r=0;r<=e;r++)n+=t[r];return n}function Pn(t,e){let n,r;const o=new Array(t.length),l=new Array(t.length),i=new Array(t.length);let c=0,s=0,h=0,u=0,a=0,d=0;const w=1/(1-.5),x=1/(1-2);for(let b=0;b<t.length;b++)o[b]=t[b]/e;l[0]=o[0],i[0]=1-l[0];for(let b=1;b<t.length;b++)l[b]=l[b-1]+o[b],i[b]=1-l[b];n=0;for(let b=0;b<t.length;b++)if(Math.abs(l[b])>=Number.EPSILON){n=b;break}r=t.length-1;for(let b=t.length-1;b>=n;b--)if(Math.abs(i[b])>=Number.EPSILON){r=b;break}for(let b=n;b<=r;b++){let M=0,v=0,$=0;for(let A=0;A<=b;A++)t[A]!==0&&(M-=o[A]/l[b]*Math.log(o[A]/l[b])),v+=Math.sqrt(o[A]/l[b]),$+=o[A]*o[A]/(l[b]*l[b]);let F=0,E=0,D=0;for(let A=b+1;A<t.length;A++)t[A]!==0&&(F-=o[A]/i[b]*Math.log(o[A]/i[b])),E+=Math.sqrt(o[A]/i[b]),D+=o[A]*o[A]/(i[b]*i[b]);const N=M+F,et=w*(v*E>0?Math.log(v*E):0),Mt=x*($*D>0?Math.log($*D):0);N>u&&(u=N,c=b),et>a&&(a=et,s=b),Mt>d&&(d=Mt,h=b)}const y=new Uint32Array([c,s,h]);y.sort();let p;Math.abs(y[0]-y[1])<=5?Math.abs(y[1]-y[2])<=5?p=[1,2,1]:p=[0,1,3]:Math.abs(y[1]-y[2])<=5?p=[3,1,0]:p=[1,2,1];const m=l[y[2]]-l[y[0]];return Math.round(y[0]*(l[y[0]]+.25*m*p[0])+.25*y[1]*m*p[1]+y[2]*(i[y[2]]+.25*m*p[2]))}function Dn(t,e){const n=new Array(t.length);for(let f=0;f<t.length;f++)n[f]=t[f]/e;const r=new Array(t.length),o=new Array(t.length);r[0]=n[0],o[0]=1-r[0];for(let f=1;f<t.length;f++)r[f]=r[f-1]+n[f],o[f]=1-r[f];let l=0;for(let f=0;f<t.length;f++)if(Math.abs(r[f])>=Number.EPSILON){l=f;break}let i=t.length-1;for(let f=t.length-1;f>=l;f--)if(Math.abs(o[f])>=Number.EPSILON){i=f;break}let c=-1,s=Number.MAX_VALUE,h,u,a,d;for(let f=l;f<=i;f++){a=0,h=.5/r[f];for(let w=1;w<=f;w++)a-=n[w]*Math.log(1-h*r[w-1]);a*=h,d=0,h=.5/o[f];for(let w=f+1;w<t.length;w++)d-=n[w]*Math.log(1-h*o[w]);d*=h,u=Math.abs(a-d),u<s&&(s=u,c=f)}return c}function zn(t){let e=0,n=0,r=0,o=0;for(let a=0;a<t.length;a++)if(t[a]>0){e=a;break}e>0&&e--;for(let a=t.length-1;a>0;a--)if(t[a]>0){o=a;break}o<t.length-1&&o++;for(let a=0;a<t.length;a++)t[a]>n&&(r=a,n=t[a]);let l=!1;if(r-e<o-r){l=!0;let a=0,d=t.length-1;for(;a<d;){const f=t[a];t[a]=t[d],t[d]=f,a++,d--}e=t.length-1-o,r=t.length-1-r}if(e===r)return e;let i,c,s;i=t[r],c=e-r,s=Math.hypot(i,c),i/=s,c/=s,s=i*e+c*t[e];let h=e,u=0;for(let a=e+1;a<=r;a++){const d=i*a+c*t[a]-s;d>u&&(h=a,u=d)}if(h--,l){let a=0,d=t.length-1;for(;a<d;){const f=t[a];t[a]=t[d],t[d]=f,a++,d--}return t.length-1-h}else return h}function Tn(t,e){const n=new Array(t.length);for(let h=0;h<t.length;h++)n[h]=t[h]/e;const r=new Array(t.length);r[0]=n[0];for(let h=1;h<t.length;h++)r[h]=r[h-1]+n[h];const o=new Array(t.length);o[0]=n[0]*n[0];for(let h=1;h<t.length;h++)o[h]=o[h-1]+n[h]*n[h];const l=new Array(t.length);l[t.length-1]=0;for(let h=t.length-2;h>=0;h--)l[h]=l[h+1]+n[h+1]*n[h+1];let i=-1,c=Number.MIN_VALUE,s;for(let h=0;h<t.length;h++)s=-1*(o[h]*l[h]>0?Math.log(o[h]*l[h]):0)+2*(r[h]*(1-r[h])>0?Math.log(r[h]*(1-r[h])):0),s>c&&(c=s,i=h);return i}function Yn(t,e={}){const{algorithm:n="otsu",slots:r}=e;if(t.channels!==1)throw new TypeError("threshold can only be computed on images with one channel");const o=t.histogram({slots:r}),l=r?2**t.bitDepth/r:1;return S(n).with("huang",()=>xn(o)*l).with("intermodes",()=>bn(o)*l).with("isodata",()=>Mn(o)*l).with("li",()=>gn(o,t.size)*l).with("maxEntropy",()=>mn(o,t.size)*l).with("mean",()=>Vn(o,t.size)*l).with("minimum",()=>Bn(o)*l).with("minError",()=>Rn(o,t.size)*l).with("moments",()=>En(o,t.size)*l).with("otsu",()=>An(o,t.size)*l).with("percentile",()=>Cn(o)*l).with("renyiEntropy",()=>Pn(o,t.size)*l).with("shanbhag",()=>Dn(o,t.size)*l).with("triangle",()=>zn(o)*l).with("yen",()=>Tn(o,t.size)*l).exhaustive()}function $n(t,e={}){let n;if("threshold"in e){const o=e.threshold;if(o<0||o>1)throw new RangeError("threshold must be a value between 0 and 1");n=o*t.maxValue}else n=Yn(t,e);const r=ye(t,e);for(let o=0;o<t.size;o++)r.setBitByIndex(o,t.getValueByIndex(o,0)>n?1:0);return r}function Gn(t,e,n){return t*6966+e*23436+n*2366>>15}function On(t,e,n){return t*9798+e*19235+n*3735>>15}function ct(t,e,n){return Math.max(t,e,n)}function st(t,e,n){return Math.min(t,e,n)}function Fn(t,e,n){return(t+e+n)/3>>0}function Ln(t,e,n){return(Math.max(t,e,n)+Math.min(t,e,n))/2}function Nn(t){return t}function Sn(t,e){return e}function Xn(t,e,n){return n}function ht(t,e,n,r){return Math.min(r.maxValue-t,r.maxValue-e,r.maxValue-n)}function kn(t,e,n,r){const o=ht(t,e,n,r);return(r.maxValue-t-o)/(1-o/r.maxValue)>>0}function jn(t,e,n,r){const o=ht(t,e,n,r);return(r.maxValue-e-o)/(1-o/r.maxValue)>>0}function Hn(t,e,n,r){const o=ht(t,e,n,r);return(r.maxValue-n-o)/(1-o/r.maxValue)>>0}function Un(t,e,n,r){const o=st(t,e,n),l=ct(t,e,n);if(l===o)return 0;let i=0;const c=l-o;return l===t?i=(e-n)/c+(e<n?6:0):l===e?i=(n-t)/c+2:(T(l===n),i=(t-e)/c+4),i/6*r.maxValue>>0}function Wn(t,e,n,r){const o=st(t,e,n),l=ct(t,e,n),i=l-o;return l===0?0:i/l*r.maxValue}function qn(t,e,n){const r=st(t,e,n);return(ct(t,e,n)+r)/2}const te=Object.freeze(Object.defineProperty({__proto__:null,average:Fn,black:ht,blue:Xn,cyan:kn,green:Sn,hue:Un,lightness:qn,luma601:On,luma709:Gn,magenta:jn,max:ct,min:st,minmax:Ln,red:Nn,saturation:Wn,yellow:Hn},Symbol.toStringTag,{value:"Module"})),Kn={LUMA_709:"luma709",LUMA_601:"luma601",MAX:"max",MIN:"min",AVERAGE:"average",MINMAX:"minmax",RED:"red",GREEN:"green",BLUE:"blue",BLACK:"black",CYAN:"cyan",MAGENTA:"magenta",YELLOW:"yellow",HUE:"hue",SATURATION:"saturation",LIGHTNESS:"lightness"};{const t=new Set(Object.values(Kn));for(const e of Object.keys(te))T(t.has(e),`Grey algorithm ${e} is missing in the GreyAlgorithm enum`)}function _n(t,e={}){let{keepAlpha:n=!1,mergeAlpha:r=!0}=e;const{algorithm:o="luma709"}=e;B(t,{colorModel:["RGB","RGBA"]}),n=n&&t.alpha,r=r&&t.alpha,n&&(r=!1);const i=I(t,e,{newParameters:{colorModel:n?"GREYA":"GREY"}});let c;typeof o=="function"?c=o:c=te[o];const s=X(i);for(let h=0;h<t.size;h++){const u=t.getValueByIndex(h,0),a=t.getValueByIndex(h,1),d=t.getValueByIndex(h,2);let f;if(r){const w=t.getValueByIndex(h,3);f=s(c(u,a,d,t)*w/t.maxValue)}else if(f=s(c(u,a,d,t)),n){const w=t.getValueByIndex(h,3);i.setValueByIndex(h,1,w)}i.setValueByIndex(h,0,f)}return i}function ee(t,e,n={}){const{origin:r={column:0,row:0}}=n,{column:o,row:l}=r;if(t.colorModel!==e.colorModel)throw new RangeError("source and target must have the same color model");Q(r,"Origin");let i;e instanceof V?i=I(e,n,{clone:!0}):i=Y(e,n,{clone:!0});for(let c=Math.max(l,0);c<Math.min(t.height+l,e.height);c++)for(let s=Math.max(o,0);s<Math.min(t.width+o,e.width);s++){const h=t.getPixel(s-o,c-l);pt(i,s,c,h)}return i}function Zn(t,e={}){const{origin:n={row:0,column:0},width:r=t.width-n.column,height:o=t.height-n.row}=e,{column:l,row:i}=n;if(B(t,{bitDepth:[8,16]}),Q(n,"Origin"),!Number.isInteger(r)||!Number.isInteger(o))throw new RangeError(`Width and height (width:${r}; height:${o}) must be integers`);if(i>t.height-1||l>t.width-1)throw new RangeError(`Origin (row:${i}, column:${l}) out of range (${t.width-1}; ${t.height-1})`);if(r<=0||o<=0)throw new RangeError(`Width and height (width:${r}; height:${o}) must be positive numbers`);if(i<0||l<0)throw new RangeError(`Row and column (row:${i}, column:${l}) must be positive numbers`);if(r>t.width-l||o>t.height-i)throw new RangeError(`Size is out of range (row:${i}, column:${l}, width:${r}, height:${o})`);const c=V.createFrom(t,{width:r,height:o});for(let s=0;s<o;s++)for(let h=0;h<r;h++)c.setPixel(h,s,t.getPixel(l+h,i+s));return c}function Jn(t,e={}){B(t,{alpha:!0});const{threshold:n=t.maxValue}=e,r=Qn(t,n,t.components);if(r===-1)throw new RangeError(`could not find new dimensions. Threshold may be too high: ${n}`);const o=tr(t,n,t.components,r),l=er(t,n,t.components,r),i=nr(t,n,t.components,r,o,l);return t.crop({origin:{column:r,row:o},width:i-r+1,height:l-o+1})}function Qn(t,e,n){for(let r=0;r<t.width;r++)for(let o=0;o<t.height;o++)if(t.getValue(r,o,n)>=e)return r;return-1}function tr(t,e,n,r){for(let o=0;o<t.height;o++)for(let l=r;l<t.width;l++)if(t.getValue(l,o,n)>=e)return o;return-1}function er(t,e,n,r){for(let o=t.height-1;o>=0;o--)for(let l=r;l<t.width;l++)if(t.getValue(l,o,n)>=e)return o;return-1}function nr(t,e,n,r,o,l){for(let i=t.width-1;i>=r;i--)for(let c=o;c<=l;c++)if(t.getValue(i,c,n)>=e)return i;return-1}function rr(t){return S(t).with("nearest",()=>or).with("bilinear",()=>lr).with("bicubic",()=>ir).exhaustive()}function or(t,e,n,r,o){return e=Math.round(e),n=Math.round(n),o(e,n,r,t)}function lr(t,e,n,r,o){const l=Math.floor(e),i=Math.floor(n),c=l+1,s=i+1;if(c<t.width&&s<t.height&&l>=0&&i>=0){const h=t.getValue(l,i,r),u=t.getValue(c,i,r),a=t.getValue(l,s,r),d=t.getValue(c,s,r),f=(c-e)*h+(e-l)*u,w=(c-e)*a+(e-l)*d;return U((s-n)*f+(n-i)*w)}else{const h=o(l,i,r,t),u=o(c,i,r,t),a=o(l,s,r,t),d=o(c,s,r,t),f=(c-e)*h+(e-l)*u,w=(c-e)*a+(e-l)*d;return U((s-n)*f+(n-i)*w)}}function ir(t,e,n,r,o,l){const i=Math.floor(e),c=Math.floor(n);if(i===e&&c===n)return o(i,c,r,t);const s=e-i,h=n-c,u=o(i-1,c-1,r,t),a=o(i,c-1,r,t),d=o(i+1,c-1,r,t),f=o(i+2,c-1,r,t),w=q(u,a,d,f,s),g=o(i-1,c,r,t),x=o(i,c,r,t),y=o(i+1,c,r,t),p=o(i+2,c,r,t),m=q(g,x,y,p,s),R=o(i-1,c+1,r,t),b=o(i,c+1,r,t),M=o(i+1,c+1,r,t),v=o(i+2,c+1,r,t),$=q(R,b,M,v,s),F=o(i-1,c+2,r,t),E=o(i,c+2,r,t),D=o(i+1,c+2,r,t),N=o(i+2,c+2,r,t),et=q(F,E,D,N,s);return U(l(q(w,m,$,et,h)))}function q(t,e,n,r,o){return e+.5*o*(n-t+o*(2*t-5*e+4*n-r+o*(3*(e-n)+r-t)))}function ut(t,e,n={}){const{borderType:r="constant",borderValue:o=0,interpolationType:l="bilinear",fullImage:i}=n;let{width:c=t.width,height:s=t.height}=n;if(!cr(e))throw new TypeError(`transformation matrix must be 2x3 or 3x3. Received ${e.length}x${e[1].length}`);if(e.length===2&&e.push([0,0,1]),i){e=e.map(E=>E.slice()),e[0][2]=0,e[1][2]=0;const f=[t.getCoordinates("top-left"),t.getCoordinates("top-right"),t.getCoordinates("bottom-right"),t.getCoordinates("bottom-left")];f[1].column+=1,f[2].column+=1,f[2].row+=1,f[3].row+=1;const w=f.map(E=>[j(e[0],e[2],E.column,E.row),j(e[1],e[2],E.column,E.row)]),g=w.map(E=>E[0]),x=w.map(E=>E[1]),y=Math.max(...g),p=Math.max(...x),m=Math.min(...g),R=Math.min(...x),b=[(t.width-1)/2,(t.height-1)/2];c=y-m,s=p-R;const M=j(e[0],e[2],b[0],b[1]),v=j(e[1],e[2],b[0],b[1]),$=(c-1)/2-M,F=(s-1)/2-v;e[0][2]=$,e[1][2]=F,c=Math.round(c),s=Math.round(s)}n.inverse||(e=xe(new be(e)).to2DArray());const h=V.createFrom(t,{width:c,height:s}),u=lt(r,o),a=X(h),d=rr(l);for(let f=0;f<h.height;f++)for(let w=0;w<h.width;w++){const g=j(e[0],e[2],w,f),x=j(e[1],e[2],w,f);for(let y=0;y<h.channels;y++){const p=d(t,g,x,y,u,a);h.setValue(w,f,y,p)}}return h}function j(t,e,n,r){return(t[0]*n+t[1]*r+t[2])/(e[0]*n+e[1]*r+e[2])}function cr(t){return t.length===3&&t[0].length===3&&t[1].length===3&&t[2].length===3||t.length===2&&t[0].length===3&&t[1].length===3}function sr(t,e){const{interpolationType:n="bilinear",borderType:r="replicate",borderValue:o=0}=e,{width:l,height:i,xFactor:c,yFactor:s}=hr(t,e);return ut(t,[[c,0,c/2],[0,s,s/2]],{interpolationType:n,borderType:r,borderValue:o,height:i,width:l})}function hr(t,e){const{width:n,height:r,xFactor:o,yFactor:l,preserveAspectRatio:i=!0}=e;if(n===void 0&&r===void 0&&o===void 0&&l===void 0)throw new TypeError("at least one of the width, height, xFactor or yFactor options must be passed");let c,s;const h=Yt(n,o,t.width,i),u=Yt(r,l,t.height,i);return h===void 0?(T(u!==void 0),c=Math.round(u*(t.width/t.height))):c=h,u===void 0?(T(h!==void 0),s=Math.round(h*(t.height/t.width))):s=u,{width:c,height:s,xFactor:o??c/t.width,yFactor:l??s/t.height}}function Yt(t,e,n,r){if(t===void 0){if(e!==void 0)return Math.round(n*e);if(!r)return n}else{if(e!==void 0)throw new TypeError("factor and size cannot be passed together");return t}}function ur(t,e){const n=e%180===0?t.width:t.height,r=e%180===0?t.height:t.width,o=V.createFrom(t,{width:n,height:r});if(e===90||e===-270)for(let l=0;l<t.width;l++)for(let i=0;i<t.height;i++)for(let c=0;c<t.channels;c++)o.setValue(o.width-i-1,l,c,t.getValue(l,i,c));else if(e===180||e===-180)for(let l=0;l<t.width;l++)for(let i=0;i<t.height;i++)for(let c=0;c<t.channels;c++)o.setValue(o.width-l-1,o.height-i-1,c,t.getValue(l,i,c));else if(e===270||e===-90)for(let l=0;l<t.width;l++)for(let i=0;i<t.height;i++)for(let c=0;c<t.channels;c++)o.setValue(i,o.height-l-1,c,t.getValue(l,i,c));else throw new RangeError(`invalid angle: ${e}`);return o}function ar(t,e,n={}){const{center:r="center",scale:o=1,...l}=n;let i;typeof r=="string"?i=t.getCoordinates(r):i=r;const c=fr(e,i,o);return ut(t,c,l)}function fr(t,e,n){const r=t*Math.PI/180,o=n*Math.cos(r),l=n*Math.sin(r);return[[o,l,(1-o)*e.column-l*e.row],[-l,o,l*e.column+(1-o)*e.row],[0,0,1]]}function $t(t,e,n){const r=Math.cos(n),o=Math.sin(n),l=t.column*r-t.row*o+(1-r)*e.column+e.row*o,i=t.column*o+t.row*r+(1-r)*e.row-e.column*o;return{column:l,row:i}}function dr(t,e,n){if(e.length!==4)throw new Error("The points array must contain 4 points");const r=wr(e),o={row:(e[0].row+e[2].row)/2,column:(e[0].column+e[2].column)/2},l=e.map(p=>$t(p,o,r)),[i,c,s]=l,h=Math.max(Math.abs(i.column-c.column),Math.abs(c.column-s.column)),u=Math.max(Math.abs(i.row-c.row),Math.abs(c.row-s.row)),a=Math.min(Math.ceil(h),Math.ceil(h-1e-10)),d=Math.min(Math.ceil(u),Math.ceil(u-1e-10)),f={row:Math.min(...l.map(p=>p.row))-(d-u)/2,column:Math.min(...l.map(p=>p.column))-(a-h)/2},w=$t(f,o,-r),g=Math.cos(-r),x=Math.sin(-r),y=[[g,-x,w.column],[x,g,w.row]];return ut(t,y,{inverse:!0,width:a,height:d,...n})}function wr(t){let e=-H(t[1],t[0]);e>Math.PI/2?e-=Math.PI:e<-Math.PI/2&&(e+=Math.PI);let n=e;return Math.abs(e)>Math.PI/4&&(n=e>0?-Math.PI/2+e:Math.PI/2+e),n}function yr(t,e,n={}){const{origin:r={row:0,column:0},color:o=L(t),blend:l=!0}=n,{column:i,row:c}=r;if(o.length!==t.channels)throw new RangeError("the given color is not compatible with the image");Q(r,"Origin");const s=I(t,n,{clone:!0});if(l){xr(o);for(let h=Math.max(c,0);h<Math.min(e.height+c,t.height);h++)for(let u=Math.max(i,0);u<Math.min(e.width+i,t.width);u++)e.getBit(u-i,h-c)&&pt(s,u,h,o)}else for(let h=Math.max(c,0);h<Math.min(e.height+c,t.height);h++)for(let u=Math.max(i,0);u<Math.min(e.width+i,t.width);u++)if(e.getBit(u-i,h-c))for(let a=0;a<t.channels;a++){const d=o[a];typeof d=="number"&&s.setValue(u,h,a,d)}return s}function xr(t){for(const e of t)if(typeof e!="number")throw new TypeError("cannot have null channels in color if blend is true")}function br(t,e,n={}){const{origin:r={row:0,column:0},value:o=1}=n,{column:l,row:i}=r;Q(r,"Origin");const c=Y(t,n,{clone:!0});for(let s=Math.max(i,0);s<Math.min(e.height+i,t.height);s++)for(let h=Math.max(l,0);h<Math.min(e.width+l,t.width);h++)e.getBit(h-l,s-i)&&c.setBit(h,s,o);return c}function ne(t,e){if(t instanceof V){const n=I(t,e);t.alpha&&Qt(t,n);const{maxValue:r,size:o}=n;for(let l=0;l<o;l++)for(let i=0;i<t.components;i++)n.setValueByIndex(l,i,r-t.getValueByIndex(l,i));return n}else{const n=Y(t,e);for(let r=0;r<n.size;r++)n.setBitByIndex(r,!t.getBitByIndex(r));return n}}function pr(t,e={}){const n=t.minMax();let{inputMin:r=n.min,inputMax:o=n.max,outputMin:l=0,outputMax:i=t.maxValue,gamma:c=1}=e;const{channels:s=new Array(t.components).fill(0).map((a,d)=>d)}=e;ot(s,t),B(t,{bitDepth:[8,16]});const h=I(t,e,{clone:!0}),u=X(t);r=K(r,t.channels),o=K(o,t.channels),l=K(l,t.channels),i=K(i,t.channels),c=K(c,t.channels);for(let a=0;a<t.height;a++)for(let d=0;d<t.width;d++)for(const f of s){const w=t.getValue(d,a,f),g=Math.max(Math.min(w,o[f]),r[f]);let x=u((g-r[f])/(o[f]-r[f]));Number.isNaN(x)&&(x=0);const y=u(x**(1/c[f])*(i[f]-l[f])+l[f]);h.setValue(d,a,f,y)}return h}function K(t,e){if(Array.isArray(t)){if(t.length===e)return t;throw new RangeError("array length is not compatible with channel option")}else return new Array(e).fill(t)}function Mr(t,e,n){const r=Y(t,n);if(t.width!==e.width||t.height!==e.height)throw new RangeError("both masks must have the same size");for(let o=0;o<r.size;o++)t.getBitByIndex(o)||e.getBitByIndex(o)?r.setBitByIndex(o,1):r.setBitByIndex(o,0);return r}function Gt(t){B(t,{bitDepth:[8,16]});for(let e=0;e<t.height;e++)for(let n=0;n<Math.floor(t.width/2);n++){const r=n,o=t.width-n-1;for(let l=0;l<t.channels;l++){const i=t.getValue(r,e,l);t.setValue(r,e,l,t.getValue(o,e,l)),t.setValue(o,e,l,i)}}return t}function Ot(t){B(t,{bitDepth:[8,16]});for(let e=0;e<Math.floor(t.height/2);e++)for(let n=0;n<t.width;n++){const r=e,o=t.height-e-1;for(let l=0;l<t.channels;l++){const i=t.getValue(n,r,l);t.setValue(n,r,l,t.getValue(n,o,l)),t.setValue(n,o,l,i)}}return t}function gr(t,e={}){const{axis:n="horizontal"}=e,r=I(t,e,{clone:!0});return n==="horizontal"?Gt(r):Ot(n==="vertical"?r:Gt(r))}function mr(t,e){const{cellSize:n=3,borderType:r="reflect101",borderValue:o}=e;if(B(t,{bitDepth:[8,16]}),n<1)throw new RangeError(`Invalid property "cellSize". Must be greater than 0. Received ${n}.`);if(n%2===0)throw new RangeError(`Invalid property "cellSize". Must be an odd number. Received ${n}.`);const l=lt(r,o),i=V.createFrom(t),c=n**2,s=new Uint16Array(c),h=(n-1)/2;for(let u=0;u<t.channels;u++)for(let a=0;a<t.height;a++)for(let d=0;d<t.width;d++){let f=0;for(let w=-h;w<=h;w++)for(let g=-h;g<=h;g++)s[f++]=l(d+g,a+w,u,t);i.setValue(d,a,u,kt(s))}return i}function Vr(t,e){const{cellSize:n,algorithm:r="center"}=e;if(!Number.isInteger(n))throw new TypeError("cellSize must be an integer");if(n<2)throw new RangeError("cellSize must be greater than 1");const o=I(t,e),l=vr(r);for(let i=0;i<t.channels;i++)for(let c=0;c<t.width;c+=n)for(let s=0;s<t.height;s+=n){const h=Math.min(n,t.width-c),u=Math.min(n,t.height-s),a=l(t,i,{width:h,height:u,origin:{column:c,row:s}});for(let d=c;d<c+h;d++)for(let f=s;f<s+u;f++)o.setValue(d,f,i,a)}return o}function Rr(t,e,n){const r={column:Math.floor((n.origin.column+n.origin.column+n.width-1)/2),row:Math.floor((n.origin.row+n.origin.row+n.height-1)/2)};return t.getValue(r.column,r.row,e)}function Br(t,e,n){let r=0;for(let o=n.origin.column;o<n.origin.column+n.width;o++)for(let l=n.origin.row;l<n.origin.row+n.height;l++)r+=t.getValue(o,l,e);return Math.round(r/(n.width*n.height))}function Ir(t,e,n){const r=[];for(let o=n.origin.column;o<n.origin.column+n.width;o++)for(let l=n.origin.row;l<n.origin.row+n.height;l++)r.push(t.getValue(o,l,e));return kt(r)}function vr(t){switch(t){case"mean":return Br;case"median":return Ir;case"center":return Rr;default:Ce(t);break}}function Er(t,e={}){const{innerBorders:n=!1,allowCorners:r=!1}=e;n||(t=t.solidFill());const o=[];for(let l=0;l<t.width;l++)t.getBit(l,0)&&o.push({column:l,row:0}),t.getBit(l,t.height-1)&&o.push({column:l,row:t.height-1});for(let l=0;l<t.height;l++)t.getBit(0,l)&&o.push({column:0,row:l}),t.getBit(t.width-1,l)&&o.push({column:t.width-1,row:l});for(let l=1;l<t.height-1;l++)for(let i=1;i<t.width-1;i++)t.getBit(i,l)&&((t.getBit(i-1,l)===0||t.getBit(i,l-1)===0||t.getBit(i+1,l)===0||t.getBit(i,l+1)===0)&&o.push({column:i,row:l}),r&&(t.getBit(i-1,l-1)===0||t.getBit(i-1,l+1)===0||t.getBit(i+1,l-1)===0||t.getBit(i+1,l+1)===0)&&o.push({column:i,row:l}));return o}function Ar(t,e){return Math.hypot(t.column-e.column,t.row-e.row)}function Cr(t){let e=0;for(let n=0;n<t.length;n++)e+=Ar(t[(n+1)%t.length],t[n]);return e}function Pr(t){let e=0;for(let n=0;n<t.length;n++){const r=(n+1)%t.length;e+=t[n].column*t[r].row,e-=t[n].row*t[r].column}return Math.abs(e/2)}function re(t){const e=t.getBorderPoints({allowCorners:!0,innerBorders:!1}),n=[];for(const r of e)n.push(r,{column:r.column+1,row:r.row},{column:r.column+1,row:r.row+1},{column:r.column,row:r.row+1});return n}function oe(t,e={}){const{sorted:n=!1}=e;n||(t=t.slice(),t.sort(Dr));const r=t.length,o=new Array(r*2);let l=0;for(let c=0;c<r;c++){const s=t[c];for(;l>=2&&Ft(o[l-2],o[l-1],s)<=0;)l--;o[l++]=s}const i=l+1;for(let c=r-2;c>=0;c--){const s=t[c];for(;l>=i&&Ft(o[l-2],o[l-1],s)<=0;)l--;o[l++]=s}return o.slice(0,l-1)}function Ft(t,e,n){return(e.row-t.row)*(n.column-t.column)-(e.column-t.column)*(n.row-t.row)}function Dr(t,e){return t.column===e.column?t.row-e.row:t.column-e.column}function zr(t){const e=re(t);if(e.length===0)return{points:[],surface:0,perimeter:0};const n=oe(e),r=Cr(n),o=Pr(n);return{points:n,perimeter:r,surface:o}}function Tr(t){const e=t.getConvexHull(),n=e.points;if(e.surface===0)return{minDiameter:{length:0,points:[{column:0,row:0},{column:0,row:0}],angle:0,calliperLines:[[{column:0,row:0},{column:0,row:0}],[{column:0,row:0},{column:0,row:0}]]},maxDiameter:{length:0,points:[{column:0,row:0},{column:0,row:0}],angle:0,calliperLines:[[{column:0,row:0},{column:0,row:0}],[{column:0,row:0},{column:0,row:0}]]},aspectRatio:1};let r=Number.POSITIVE_INFINITY,o=0,l=[],i;for(let y=0;y<n.length;y++){const p=H(n[y],n[(y+1)%n.length]),m=G(-p,n);let R=0,b=[];for(let M=0;M<n.length;M++){const v=Math.abs(m[y].row-m[M].row);v>R&&(R=v,b=[m[y],m[M]])}if(R<r){r=R,o=p,l=b;const{minIndex:M,maxIndex:v}=Yr(m);i=Gr(o,M,v,m,l)}}const c={points:G(o,l),length:r,angle:bt(o),calliperLines:i};let s=[],h=0,u=[];for(let y=0;y<n.length-1;y++)for(let p=y+1;p<n.length;p++){const m=(n[y].column-n[p].column)**2+(n[y].row-n[p].row)**2;m>h&&(h=m,s=[n[y],n[p]],u=[y,p])}const a=H(s[0],s[1]),d=G(-a,n),{minIndex:f,maxIndex:w}=$r(d),g=Or(a,f,w,d,u),x={length:Math.sqrt(h),angle:bt(H(s[0],s[1])),points:s,calliperLines:g};return{minDiameter:c,maxDiameter:x,aspectRatio:c.length/x.length}}function Yr(t){let e=0,n=0;for(let r=0;r<t.length;r++)t[r].column>t[e].column&&(e=r),t[r].column<t[n].column&&(n=r);return{minIndex:n,maxIndex:e}}function $r(t){let e=0,n=0;for(let r=0;r<t.length;r++)t[r].row>t[e].row&&(e=r),t[r].row<t[n].row&&(n=r);return{minIndex:n,maxIndex:e}}function Gr(t,e,n,r,o){const l=[{column:r[e].column,row:o[0].row},{column:r[n].column,row:o[0].row}],i=[{column:r[e].column,row:o[1].row},{column:r[n].column,row:o[1].row}];return[G(t,l),G(t,i)]}function Or(t,e,n,r,o){const l=[{column:r[o[0]].column,row:r[e].row},{column:r[o[0]].column,row:r[n].row}],i=[{column:r[o[1]].column,row:r[e].row},{column:r[o[1]].column,row:r[n].row}];return[G(t,l),G(t,i)]}const Fr=(t,e)=>t.column<=e.column?-1:1,Lt=(t,e)=>t.row>=e.row?-1:1;function Lr(t){const e=t.slice();e.sort(Fr);const n=e.slice(0,2),r=e.slice(2,4);n.sort(Lt),r.sort(Lt);const o=n[0],l=r[0];return-bt(H(o,l))}function Nr(t){if(t.length===0)return{points:[],angle:0,width:0,height:0,surface:0,perimeter:0,aspectRatio:0};if(t.length===1)return{points:[t[0],t[0],t[0],t[0]],perimeter:0,surface:0,angle:0,width:0,height:0,aspectRatio:1};let e=[],n=Number.POSITIVE_INFINITY,r=0,o=[];for(let a=0;a<t.length;a++){const d=H(t[a],t[(a+1)%t.length]);e=G(-d,t);const f=e[a].column,w=e[a].row,g=e[(a+1)%e.length].column,x=e[(a+1)%e.length].row;let y=!0,p=0,m=0,R=0;for(const $ of e){const F=$.column,E=$.row,D=(F-f)/(g-f);y?(y=!1,p=D,m=D):(D<p&&(p=D),D>m&&(m=D));const N=(-(g-f)*E+g*w-x*f)/(g-f);Math.abs(N)>Math.abs(R)&&(R=N)}const b={column:f+p*(g-f),row:w},M={column:f+m*(g-f),row:w},v=Math.abs(R*(p-m)*(g-f));v<n&&(r=d,n=v,o=[M,b,{column:b.column,row:b.row-R},{column:M.column,row:M.row-R}])}const l=G(r,o),i=[Math.hypot(o[0].column-o[1].column,o[0].row-o[1].row),Math.hypot(o[0].column-o[3].column,o[0].row-o[3].row)],c=Math.max(...i),s=Math.min(...i),h=Lr(l),u=s/c;return{points:l,surface:n,angle:h,width:c,height:s,perimeter:2*c+2*s,aspectRatio:u}}function Sr(t){const e=oe(re(t));return Nr(e)}function k(t){if(t.length%2===0||t[0].length%2===0)throw new TypeError("the number of rows and columns of the kernel must be odd")}function le(t,e={}){let n=!1;e.kernel===void 0&&(n=!0);const{kernel:r=[[1,1,1],[1,1,1],[1,1,1]],iterations:o=1}=e;t instanceof V&&B(t,{bitDepth:[1,8,16],components:1,alpha:!1}),k(r);let l=!0;if(!n){t:for(const c of r)for(const s of c)if(s!==1){l=!1;break t}}let i=t;for(let c=0;c<o;c++)if(i instanceof P)if(l){const s=i.clone();i=Hr(i,s,r[0].length,r.length)}else{const s=P.createFrom(t);i=jr(i,s,r)}else if(l){const s=V.createFrom(t);i=kr(i,s,r[0].length,r.length)}else{const s=V.createFrom(t);i=Xr(i,s,r)}return i}function Xr(t,e,n){const r=n[0].length,o=n.length,l=(r-1)/2,i=(o-1)/2;for(let c=0;c<t.height;c++)for(let s=0;s<t.width;s++){let h=t.maxValue;for(let u=0;u<o;u++)for(let a=0;a<r;a++){if(n[u][a]!==1)continue;const d=a-l+s,f=u-i+c;if(d<0||f<0||d>=t.width||f>=t.height)continue;const w=t.getValue(d,f,0);w<h&&(h=w)}e.setValue(s,c,0,h)}return e}function kr(t,e,n,r){const o=(n-1)/2,l=(r-1)/2,i=[];for(let c=0;c<t.width;c++)i.push(0);for(let c=0;c<t.height;c++){for(let s=0;s<t.width;s++){let h=t.maxValue;for(let u=Math.max(0,c-l);u<Math.min(t.height,c+l+1);u++){const a=t.getValue(s,u,0);a<h&&(h=a)}i[s]=h}for(let s=0;s<t.width;s++){let h=t.maxValue;for(let u=Math.max(0,s-o);u<Math.min(t.width,s+o+1);u++)i[u]<h&&(h=i[u]);e.setValue(s,c,0,h)}}return e}function jr(t,e,n){const r=n[0].length,o=n.length,l=(r-1)/2,i=(o-1)/2;for(let c=0;c<t.height;c++)for(let s=0;s<t.width;s++){let h=1;for(let u=0;u<o;u++)for(let a=0;a<r;a++){if(n[u][a]!==1)continue;const d=a-l+s,f=u-i+c;if(f<0||d<0||d>=t.width||f>=t.height)continue;if(t.getBit(d,f)===0){h=0;break}}h===1&&e.setBit(s,c,1)}return e}function Hr(t,e,n,r){const o=(n-1)/2,l=(r-1)/2,i=[];for(let c=0;c<t.width;c++)i.push(0);for(let c=0;c<t.height;c++){for(let s=0;s<t.width;s++){i[s]=1;for(let h=Math.max(0,c-l);h<Math.min(t.height,c+l+1);h++)if(t.getBit(s,h)===0){i[s]=0;break}}for(let s=0;s<t.width;s++)if(e.getBit(s,c)!==0){for(let h=Math.max(0,s-o);h<Math.min(t.width,s+o+1);h++)if(i[h]===0){e.setBit(s,c,0);break}}}return e}function ie(t,e={}){let n=!1;e.kernel===void 0&&(n=!0);const{kernel:r=[[1,1,1],[1,1,1],[1,1,1]],iterations:o=1}=e;t instanceof V&&B(t,{bitDepth:[1,8,16],components:1,alpha:!1}),k(r);let l=!0;if(!n){t:for(const c of r)for(const s of c)if(s!==1){l=!1;break t}}let i=t;for(let c=0;c<o;c++)if(i instanceof P)if(l){const s=i.clone();i=Kr(i,s,r[0].length,r.length)}else{const s=P.createFrom(i);i=qr(i,s,r)}else if(l){const s=V.createFrom(i);i=Wr(i,s,r[0].length,r.length)}else{const s=V.createFrom(i);i=Ur(i,s,r)}return i}function Ur(t,e,n){const r=n[0].length,o=n.length,l=(r-1)/2,i=(o-1)/2;for(let c=0;c<t.height;c++)for(let s=0;s<t.width;s++){let h=0;for(let u=0;u<o;u++)for(let a=0;a<r;a++){if(n[u][a]!==1)continue;const d=a-l+s,f=u-i+c;if(d<0||f<0||d>=t.width||f>=t.height)continue;const w=t.getValue(d,f,0);w>h&&(h=w)}e.setValue(s,c,0,h)}return e}function Wr(t,e,n,r){const o=(n-1)/2,l=(r-1)/2,i=[];for(let c=0;c<t.width;c++)i.push(0);for(let c=0;c<t.height;c++){for(let s=0;s<t.width;s++){let h=0;for(let u=Math.max(0,c-l);u<Math.min(t.height,c+l+1);u++){const a=t.getValue(s,u,0);a>h&&(h=a)}i[s]=h}for(let s=0;s<t.width;s++){let h=0;for(let u=Math.max(0,s-o);u<Math.min(t.width,s+o+1);u++)i[u]>h&&(h=i[u]);e.setValue(s,c,0,h)}}return e}function qr(t,e,n){const r=n[0].length,o=n.length,l=(r-1)/2,i=(o-1)/2;for(let c=0;c<t.height;c++)for(let s=0;s<t.width;s++){let h=0;for(let u=0;u<o;u++)for(let a=0;a<r;a++){if(n[u][a]!==1)continue;const d=a-l+s,f=u-i+c;if(f<0||d<0||d>=t.width||f>=t.height)continue;if(t.getBit(d,f)===1){h=1;break}}h===1&&e.setBit(s,c,1)}return e}function Kr(t,e,n,r){const o=(n-1)/2,l=(r-1)/2,i=[];for(let c=0;c<t.width;c++)i.push(1);for(let c=0;c<t.height;c++){for(let s=0;s<t.width;s++){i[s]=0;for(let h=Math.max(0,c-l);h<Math.min(t.height,c+l+1);h++)if(t.getBit(s,h)===1){i[s]=1;break}}for(let s=0;s<t.width;s++)if(e.getBit(s,c)!==1){for(let h=Math.max(0,s-o);h<Math.min(t.width,s+o+1);h++)if(i[h]===1){e.setBit(s,c,1);break}}}return e}function ce(t,e={}){const{kernel:n=[[1,1,1],[1,1,1],[1,1,1]],iterations:r=1}=e;t instanceof V&&B(t,{bitDepth:[1,8,16],components:1,alpha:!1}),k(n);let o=t;for(let l=0;l<r;l++)o=o.erode({kernel:n}),o=o.dilate({kernel:n});return o}function se(t,e={}){const{kernel:n=[[1,1,1],[1,1,1],[1,1,1]],iterations:r=1}=e;t instanceof V&&B(t,{bitDepth:[1,8,16],components:1,alpha:!1}),k(n);let o=t;for(let l=0;l<r;l++)o=o.dilate({kernel:n}).erode({kernel:n});return o}function he(t,e={}){const{kernel:n=[[1,1,1],[1,1,1],[1,1,1]],iterations:r=1}=e;t instanceof V&&B(t,{bitDepth:[1,8,16],components:1,alpha:!1}),k(n);let o=t;for(let l=0;l<r;l++){const i=o.open({kernel:n});o=tt(i,o,{absolute:!0})}return o}function ue(t,e={}){const{kernel:n=[[1,1,1],[1,1,1],[1,1,1]],iterations:r=1}=e;t instanceof V&&B(t,{bitDepth:[1,8,16],components:1,alpha:!1}),k(n);let o=t;for(let l=0;l<r;l++){const i=o.close({kernel:n});o=tt(i,o,{absolute:!0})}return o}function ae(t,e={}){const{kernel:n=[[1,1,1],[1,1,1],[1,1,1]],iterations:r=1}=e;t instanceof V&&B(t,{bitDepth:[1,8,16],components:1,alpha:!1}),k(n);let o=t;for(let l=0;l<r;l++){const i=o.dilate({kernel:n}),c=o.erode({kernel:n});o=tt(i,c,{absolute:!0})}return o}function*_r(t){for(let e=0;e<t.width;e++)yield e;for(let e=2;e<t.height;e++)yield e*t.width-1;for(let e=0;e<t.width;e++)yield t.width*t.height-e-1;for(let e=t.height-2;e>=1;e--)yield e*t.width}const Z=65536,xt=new Uint32Array(Z);function fe(t,e={}){const{startPixels:n=[0],startPixelValue:r=0,newPixelValue:o=1,allowCorners:l=!1}=e,i=Y(t,e,{clone:!0}),c=P.createFrom(t);let s=0,h=0;for(const a of n)i.getBitByIndex(a)===r&&(xt[h++%Z]=a,c.setBitByIndex(a,1),i.setBitByIndex(a,o));for(;s<h;){T(h-s<=Z);const a=xt[s++%Z];i.setBitByIndex(a,o);const d=a<t.width,f=a%t.width===0,w=a%t.width===t.width-1,g=a>t.size-t.width;if(!g){const x=a+t.width;u(x)}if(!f){const x=a-1;u(x)}if(!d){const x=a-t.width;u(x)}if(!w){const x=a+1;u(x)}if(l){if(!d){if(!f){const x=a-t.width-1;u(x)}if(!w){const x=a-t.width+1;u(x)}}if(!g){if(!f){const x=a+t.width-1;u(x)}if(!w){const x=a+t.width+1;u(x)}}}}function u(a){c.getBitByIndex(a)||i.getBitByIndex(a)===r&&(xt[h++%Z]=a,c.setBitByIndex(a,1))}return i}function Zr(t,e={}){const{allowCorners:n=!1,out:r,color:o="white"}=e;return fe(t,{startPixels:_r(t),startPixelValue:o==="white"?1:0,newPixelValue:o==="white"?0:1,allowCorners:n,out:r})}const Jr=[[-1,0,1],[-2,0,2],[-1,0,1]],Qr=[[-1,-2,-1],[0,0,0],[1,2,1]];function to(t,e={}){const{hysteresis:n=!0,lowThreshold:r=.04,highThreshold:o=.1,gaussianBlurOptions:l={sigma:1}}=e,i=r*t.maxValue,c=o*t.maxValue;B(t,{colorModel:"GREY"});const s=t.width,h=t.height,u=t.gaussianBlur(l),a=u.rawDirectConvolution(Qr),d=u.rawDirectConvolution(Jr),f=new Float64Array(t.size);for(let y=0;y<t.size;y++)f[y]=Math.hypot(a[y],d[y]);const w=new Float64Array(t.size),g=new Float64Array(t.size),x=ye(t,e);for(let y=1;y<s-1;y++)for(let p=1;p<h-1;p++){const m=a[C(y,p,t,0)],R=d[C(y,p,t,0)],b=eo(m,R),M=f[C(y,p,t,0)];(b===0&&M>=f[C(y,p-1,t,0)]&&M>=f[C(y,p+1,t,0)]||b===1&&M>=f[C(y-1,p-1,t,0)]&&M>=f[C(y+1,p+1,t,0)]||b===2&&M>=f[C(y-1,p,t,0)]&&M>=f[C(y+1,p,t,0)]||b===3&&M>=f[C(y-1,p+1,t,0)]&&M>=f[C(y+1,p-1,t,0)])&&(w[C(y,p,t,0)]=M)}for(let y=0;y<s*h;++y){const p=w[y];let m=0;p>c&&(m++,x.setBitByIndex(y,1)),p>i&&m++,g[y]=m}if(n){let y=[];for(let p=1;p<s-1;++p)for(let m=1;m<h-1;++m)if(g[C(p,m,t,0)]===1){t:for(let R=p-1;R<p+2;++R)for(let b=m-1;b<m+2;++b)if(g[C(R,b,t,0)]===2){y.push([p,m]),x.setValue(p,m,0,1);break t}}for(;y.length>0;){const p=[];for(const m of y)for(let R=-1;R<2;++R)for(let b=-1;b<2;++b){if(R===0&&b===0)continue;const M=m[0]+R,v=m[1]+b;g[C(v,M,t,0)]===1&&x.getValue(v,M,0)===0&&(p.push([M,v]),x.setValue(v,M,0,1))}y=p}}return x}function eo(t,e){return(Math.round(Math.atan2(e,t)*(4/Math.PI))+4)%4}function no(t,e={}){const{origin:n={row:0,column:0},allowCorners:r=!1,out:o}=e,l=C(n.column,n.row,t);return fe(t,{startPixels:[l],allowCorners:r,out:o})}function ro(t,e={}){const{allowCorners:n=!1}=e,r=Y(t,e,{clone:!0}),l=t.invert().clearBorder({allowCorners:n});return r.or(l,{out:r})}function Nt(t){let e;return typeof t=="boolean"?e=t?1:0:e=t,e}class P{width;height;size;bitDepth;colorModel;components;channels;alpha;maxValue;origin;data;constructor(e,n,r={}){const{data:o,origin:l={row:0,column:0}}=r;if(e<1||!Number.isInteger(e))throw new RangeError(`width must be an integer and at least 1. Received ${e}`);if(n<1||!Number.isInteger(n))throw new RangeError(`height must be an integer and at least 1. Received ${n}`);this.width=e,this.height=n,this.size=e*n,this.bitDepth=1,this.colorModel="BINARY",this.origin=l;const i=Zt[this.colorModel];if(this.components=i.components,this.alpha=i.alpha,this.channels=i.channels,this.maxValue=1,o===void 0)this.data=new Uint8Array(this.size);else{const c=this.size*this.channels;if(o.length!==c)throw new RangeError(`incorrect data size: ${o.length}. Expected ${c}`);this.data=o}}static createFrom(e,n={}){const{width:r=e.width,height:o=e.height,origin:l=e.origin}=n;return new P(r,o,{origin:l,...n})}getPixel(e,n){const r=[],o=n*this.width+e;return r.push(this.data[o]),r}setPixel(e,n,r){const o=n*this.width+e;this.data[o]=r[0]}setVisiblePixel(e,n,r){e>=0&&e<this.width&&n>=0&&n<this.height&&this.setPixel(e,n,r)}getPixelByIndex(e){return[this.data[e]]}setPixelByIndex(e,n){this.data[e]=n[0]}static fromPoints(e,n,r){const o=new P(e,n);for(const l of r)o.setBit(l.column,l.row,1);return o}clone(){return P.createFrom(this,{data:this.data.slice()})}getBit(e,n){const r=n*this.width+e;return this.data[r]}setBit(e,n,r){const o=n*this.width+e;this.data[o]=r}getBitByIndex(e){return this.data[e*this.channels]}setBitByIndex(e,n){this.data[e*this.channels]=Nt(n)}getNbNonZeroPixels(){let e=0;for(const n of this.data)n&&e++;return e}getValue(e,n,r){return nt(r),this.getBit(e,n)}setValue(e,n,r,o){nt(r),this.setBit(e,n,o)}getValueByIndex(e,n){return nt(n),this.getBitByIndex(e)}setValueByIndex(e,n,r){nt(n),this.setBitByIndex(e,r)}getValueByPoint(e){return this.getValue(e.column,e.row,0)}setValueByPoint(e,n){this.setValue(e.column,e.row,0,n)}getRawImage(){return{width:this.width,height:this.height,data:this.data}}[Symbol.for("nodejs.util.inspect.custom")](){let e;return this.height>20||this.width>20?e="[...]":e=oo(this),`Mask {
  width: ${this.width}
  height: ${this.height}
  data: ${e}
}`}fill(e){const n=Nt(e);return this.data.fill(n),this}convertColor(e){return Jt(this,e)}invert(e){return ne(this,e)}subtract(e,n){return tt(this,e,n)}and(e,n){return ke(this,e,n)}or(e,n){return Mr(this,e,n)}getBorderPoints(e){return Er(this,e)}getConvexHull(){return zr(this)}getMbr(){return Sr(this)}getFeret(){return Tr(this)}erode(e){return le(this,e)}dilate(e){return ie(this,e)}open(e){return ce(this,e)}close(e){return se(this,e)}topHat(e){return he(this,e)}bottomHat(e){return ue(this,e)}morphologicalGradient(e){return ae(this,e)}clearBorder(e){return Zr(this,e)}floodFill(e){return no(this,e)}solidFill(e){return ro(this,e)}drawPoints(e,n={}){return qt(this,e,n)}drawLine(e,n,r={}){return Oe(this,e,n,r)}drawPolyline(e,n={}){return Le(this,e,n)}drawPolygon(e,n={}){return Se(this,e,n)}drawRectangle(e={}){return Wt(this,e)}copyTo(e,n={}){return ee(this,e,n)}paintMask(e,n){return br(this,e,n)}}function oo(t){const e=[];for(let n=0;n<t.height;n++){const r=[];for(let o=0;o<t.width;o++)r.push(String(t.getBit(o,n)));e.push(`[${r.join(" ")}]`)}return e.join(`
        `)}function nt(t){if(t!==0)throw new RangeError(`channel value must be 0 on type Mask. Received ${t}`)}function tt(t,e,n={}){const{absolute:r=!1}=n;t instanceof V&&B(t,{bitDepth:[1,8,16],components:[1,3],alpha:!1}),Ht(t,e);const o=t.clone();if(o instanceof V)for(let l=0;l<t.size;l++)for(let i=0;i<t.channels;i++){const c=t.getValueByIndex(l,i)-e.getValueByIndex(l,i);r?c<0?o.setValueByIndex(l,i,-c):o.setValueByIndex(l,i,c):c<0?o.setValueByIndex(l,i,0):o.setValueByIndex(l,i,c)}else if(t instanceof P&&e instanceof P)for(let l=0;l<t.size;l++){const i=t.getBitByIndex(l)-e.getBitByIndex(l);r?o.setBitByIndex(l,i?1:0):o.setBitByIndex(l,i>0?1:0)}return o}function lo(t,e){t instanceof V&&B(t,{bitDepth:[8,16],components:[1,3],alpha:!1}),Ht(t,e);const n=t.clone(),r=X(t);for(let o=0;o<t.size;o++)for(let l=0;l<t.channels;l++){const i=t.getValueByIndex(o,l)+e.getValueByIndex(o,l);n.setValueByIndex(o,l,r(i))}return n}function io(t,e,n={}){const{channels:r=new Array(t.channels).fill(0).map((l,i)=>i)}=n;ot(r,t);const o=I(t,n,{clone:!0});if(r.length===0)return o;for(const l of r)for(let i=0;i<o.height;i++)for(let c=0;c<o.width;c++){const s=o.getValue(c,i,l)*e;o.setClampedValue(c,i,l,s)}return o}function co(t,e){const n=new Array(t.channels).fill(0),r=e?e.points.length:t.size;if(r===0)throw new RangeError("Array of coordinates is empty.");if(e)for(const o of e.points)for(let l=0;l<t.channels;l++){if(o.column<0||o.column>=t.width||o.row<0||o.row>=t.height)throw new RangeError(`Invalid coordinate: {column: ${o.column}, row: ${o.row}}.`);n[l]+=t.getValueByPoint(o,l)}else for(let o=0;o<t.height;o++)for(let l=0;l<t.width;l++)for(let i=0;i<t.channels;i++)n[i]+=t.getValue(l,o,i);return n.map(o=>o/r)}function so(t,e={}){let{channel:n}=e;const{slots:r=2**t.bitDepth}=e;if(!(r!==0&&(r&r-1)===0))throw new RangeError("slots must be a power of 2, for example: 64, 256, 1024");if(typeof n!="number"){if(t.channels!==1)throw new TypeError("channel option is mandatory for multi-channel images");n=0}J(n,t);const o=new Uint32Array(r);let l=0;const i=Math.log2(r);l=t.bitDepth-i;for(let c=0;c<t.size;c++)o[t.getValueByIndex(c,n)>>l]++;return o}function ho(t,e){const n=new Array(t.channels).fill(0);if(e){if(e.points.length===0)throw new RangeError("Array of coordinates is empty.");for(let r=0;r<t.channels;r++){const o=[];for(const l of e.points){if(l.column<0||l.column>=t.width||l.row<0||l.row>=t.height)throw new RangeError(`Invalid coordinate: {column: ${l.column}, row: ${l.row}}.`);o.push(t.getValueByPoint(l,r))}n[r]=Rt(o)}}else for(let r=0;r<t.channels;r++){const o=t.getChannel(r);n[r]=Rt(o)}return n}function uo(t,e){const n=t.mean(e),r=new Array(t.channels).fill(0);if(e)for(const l of e.points)for(let i=0;i<t.channels;i++)r[i]+=(t.getValue(l.column,l.row,i)-n[i])**2;else for(let l=0;l<t.size;l++)for(let i=0;i<t.channels;i++)r[i]+=(t.getValueByIndex(l,i)-n[i])**2;const o=e?e.points.length*t.channels:t.size*t.channels;return r.map(l=>l/o)}pe([Me]);function ao(t,e){const n={r:[],g:[],b:[]};for(const r of t)n.r.push([r.r/e]),n.g.push([r.g/e]),n.b.push([r.b/e]);return n}function fo(t,e){const n=[];for(const r of t)n.push(de(r.r,r.g,r.b,e));return n}function wo(t,e,n){if(B(t,{colorModel:["RGB","RGBA"]}),e.length!==n.length)throw new RangeError("number of measured colors and reference colors must be the same");const r=fo(e,t.maxValue),o=ao(n,t.maxValue),l=new ft(r,o.r),i=new ft(r,o.g),c=new ft(r,o.b),s=V.createFrom(t);for(let h=0;h<t.height;h++)for(let u=0;u<t.width;u++){const a=t.getPixel(u,h),d=de(a[0],a[1],a[2],t.maxValue),f=X(t),w=[0,0,0],g=l.predict(d)[0]*t.maxValue,x=i.predict(d)[0]*t.maxValue,y=c.predict(d)[0]*t.maxValue;w[0]=f(g),w[1]=f(x),w[2]=f(y),t.alpha&&(w[3]=t.getValue(u,h,3)),s.setPixel(u,h,w)}return s}function de(t,e,n,r){return t/=r,e/=r,n/=r,[t,e,n,t**2,e**2,n**2,t**3,e**3,n**3,t*e,t*n,n*e]}function yo(t){const e=new Array(t.channels).fill(t.maxValue),n=new Array(t.channels).fill(0);for(let r=0;r<t.height;r++)for(let o=0;o<t.width;o++)for(let l=0;l<t.channels;l++){const i=t.getValue(o,r,l);i<e[l]&&(e[l]=i),i>n[l]&&(n[l]=i)}return{min:e,max:n}}class V{width;height;size;bitDepth;colorModel;components;channels;alpha;maxValue;origin;originalResolution;meta;data;constructor(e,n,r={}){const{bitDepth:o=8,data:l,colorModel:i="RGB",origin:c={row:0,column:0},meta:s,resolution:h}=r;if(e<1||!Number.isInteger(e))throw new RangeError(`width must be an integer and at least 1. Received ${e}`);if(n<1||!Number.isInteger(n))throw new RangeError(`height must be an integer and at least 1. Received ${n}`);this.width=e,this.height=n,this.size=e*n,this.bitDepth=o,this.colorModel=i,this.origin=c,this.meta=s,this.originalResolution=h;const u=Zt[i];if(this.components=u.components,this.alpha=u.alpha,this.channels=u.channels,this.maxValue=2**o-1,l===void 0)this.data=xo(this.size,this.channels,this.alpha,this.bitDepth,this.maxValue);else{if(o===8&&l instanceof Uint16Array)throw new RangeError(`bitDepth is ${o} but data is Uint16Array`);if(o===16&&l instanceof Uint8Array)throw new RangeError(`bitDepth is ${o} but data is Uint8Array`);const a=this.size*this.channels;if(l.length!==a)throw new RangeError(`incorrect data size: ${l.length}. Expected ${a}`);this.data=l}}get normalizedResolution(){if(!this.originalResolution)return;const e=2.54,n=100;switch(this.originalResolution.unit){case"inch":return{x:this.originalResolution.x/e,y:this.originalResolution.y/e};case"centimeter":return{x:this.originalResolution.x,y:this.originalResolution.y};case"meter":return{x:this.originalResolution.x/n,y:this.originalResolution.y/n};case"unknown":return null;default:throw new Error("Unknown resolution unit.")}}static createFrom(e,n={}){const{width:r=e.width,height:o=e.height}=n;let l;return e instanceof V?l=e.bitDepth:l=8,new V(r,o,{bitDepth:l,colorModel:e.colorModel,origin:e.origin,...n})}getPixel(e,n){const r=[],o=(n*this.width+e)*this.channels;for(let l=0;l<this.channels;l++)r.push(this.data[o+l]);return r}getColumn(e){const n=[];for(let r=0;r<this.channels;r++){const o=[];for(let l=0;l<this.height;l++)o.push(this.getValue(e,l,r));n.push(o)}return n}getRow(e){const n=[];for(let r=0;r<this.channels;r++){const o=[];for(let l=0;l<this.width;l++)o.push(this.getValue(l,e,r));n.push(o)}return n}setPixel(e,n,r){const o=(n*this.width+e)*this.channels;for(let l=0;l<this.channels;l++)this.data[o+l]=r[l]}setVisiblePixel(e,n,r){e>=0&&e<this.width&&n>=0&&n<this.height&&this.setPixel(e,n,r)}getPixelByIndex(e){const n=[],r=e*this.channels;for(let o=0;o<this.channels;o++)n.push(this.data[r+o]);return n}setPixelByIndex(e,n){const r=e*this.channels;for(let o=0;o<this.channels;o++)this.data[r+o]=n[o]}getValue(e,n,r){return this.data[(n*this.width+e)*this.channels+r]}setValue(e,n,r,o){this.data[(n*this.width+e)*this.channels+r]=o}setClampedValue(e,n,r,o){o<0?o=0:o>this.maxValue&&(o=this.maxValue),this.data[(n*this.width+e)*this.channels+r]=o}getValueByIndex(e,n){return this.data[e*this.channels+n]}setValueByIndex(e,n,r){this.data[e*this.channels+n]=r}setClampedValueByIndex(e,n,r){r<0?r=0:r>this.maxValue&&(r=this.maxValue),this.data[e*this.channels+n]=r}getValueByPoint(e,n){return this.getValue(e.column,e.row,n)}setValueByPoint(e,n,r){this.setValue(e.column,e.row,n,r)}minMax(){return yo(this)}getRawImage(){return{width:this.width,height:this.height,data:this.data,channels:this.channels,bitDepth:this.bitDepth}}[Symbol.for("nodejs.util.inspect.custom")](){let e;return this.height>20||this.width>20?e="[...]":e=bo(this),`Image {
  width: ${this.width}
  height: ${this.height}
  bitDepth: ${this.bitDepth}
  colorModel: ${this.colorModel}
  channels: ${this.channels}
  data: ${e}
}`}fill(e){if(typeof e=="number")return _(e,this),this.data.fill(e),this;if(e.length!==this.channels)throw new RangeError(`the size of value must match the number of channels (${this.channels}). Received ${e.length}`);for(const n of e)_(n,this);for(let n=0;n<this.data.length;n+=this.channels)for(let r=0;r<=this.channels;r++)this.data[n+r]=e[r];return this}fillChannel(e,n){J(e,this),_(n,this);for(let r=e;r<this.data.length;r+=this.channels)this.data[r]=n;return this}getChannel(e){J(e,this);const n=new Array(this.size);for(let r=0;r<this.size;r++)n[r]=this.data[e+r*this.channels];return n}fillAlpha(e){if(_(e,this),!this.alpha)throw new TypeError("fillAlpha can only be called if the image has an alpha channel");const n=this.channels-1;return this.fillChannel(n,e)}clone(){return V.createFrom(this,{data:this.data.slice()})}changeEach(e){for(let n=0;n<this.data.length;n++)this.data[n]=e(this.data[n])}getCoordinates(e,n=!1){return S(e).with("center",()=>{const r=(this.width-1)/2,o=(this.height-1)/2;return n?{column:Math.round(r),row:Math.round(o)}:{column:r,row:o}}).with("top-left",()=>({column:0,row:0})).with("top-right",()=>({column:this.width-1,row:0})).with("bottom-left",()=>({column:0,row:this.height-1})).with("bottom-right",()=>({column:this.width-1,row:this.height-1})).exhaustive()}subtract(e,n={}){return tt(this,e,n)}add(e){return lo(this,e)}multiply(e,n={}){return io(this,e,n)}divide(e,n={}){return Te(this,e,n)}histogram(e){return so(this,e)}mean(e){return co(this,e)}median(e){return ho(this,e)}variance(e){return uo(this,e)}drawPoints(e,n={}){return qt(this,e,n)}drawLine(e,n,r={}){return Ge(this,e,n,r)}drawRectangle(e={}){return Wt(this,e)}drawPolyline(e,n={}){return Fe(this,e,n)}drawPolygon(e,n={}){return Ne(this,e,n)}drawCircle(e,n,r={}){return $e(this,e,n,r)}drawMarker(e,n={}){return Kt(this,e,n)}drawMarkers(e,n={}){return Xe(this,e,n)}split(){return yn(this)}convertColor(e,n){return Jt(this,e,n)}convertBitDepth(e,n){return an(this,e,n)}grey(e){return _n(this,e)}copyTo(e,n={}){return ee(this,e,n)}threshold(e={}){return $n(this,e)}crop(e){return Zn(this,e)}cropRectangle(e,n){return dr(this,e,n)}cropAlpha(e={}){return Jn(this,e)}extract(e,n){return wn(this,e,n)}paintMask(e,n){return yr(this,e,n)}blur(e){return Qe(this,e)}pixelate(e){return Vr(this,e)}directConvolution(e,n){return _e(this,e,n)}rawDirectConvolution(e,n){return _t(this,e,n)}separableConvolution(e,n,r){return rt(this,e,n,r)}gaussianBlur(e){return nn(this,e)}flip(e){return gr(this,e)}invert(e){return ne(this,e)}hypotenuse(e,n){return on(this,e,n)}gradientFilter(e){return rn(this,e)}derivativeFilter(e){return tn(this,e)}level(e){return pr(this,e)}increaseContrast(e={}){return en(this,e)}correctColor(e,n){return wo(this,e,n)}medianFilter(e){return mr(this,e)}resize(e){return sr(this,e)}rotate(e){return ur(this,e)}transform(e,n){return ut(this,e,n)}transformRotate(e,n){return ar(this,e,n)}erode(e){return le(this,e)}dilate(e){return ie(this,e)}open(e){return ce(this,e)}close(e){return se(this,e)}topHat(e){return he(this,e)}bottomHat(e){return ue(this,e)}morphologicalGradient(e){return ae(this,e)}cannyEdgeDetector(e){return to(this,e)}}function xo(t,e,n,r,o){const l=e*t,i=S(r).with(8,()=>new Uint8Array(l)).with(16,()=>new Uint16Array(l)).otherwise(()=>{throw new RangeError(`invalid bitDepth: ${r}`)});if(n)for(let c=e-1;c<l;c+=e)i[c]=o;return i}function bo(t){const e=[],n=t.bitDepth===8?3:5;for(let r=0;r<t.height;r++){const o=[];for(let l=0;l<t.width;l++)for(let i=0;i<t.channels;i++)o.push(String(t.getValue(l,r,i)).padStart(n," "));e.push(`[${o.join(" ")}]`)}return`{
    [
     ${e.join(`
     `)}
    ]
  }`}function we(t,e){if(e.width!==t.width||e.height!==t.height||e.colorModel!==t.colorModel)throw new RangeError("images width, height or color model is different");e.data=t.data.slice()}function I(t,e={},n={}){const{out:r}=e,{newParameters:o,clone:l}=n;if(r===void 0)return l?t.clone():V.createFrom(t,o);{if(!(r instanceof V))throw new TypeError("out must be an Image");const i={width:t.width,height:t.height,bitDepth:t.bitDepth,colorModel:t.colorModel,...o};return at(i,r),l&&t!==r&&we(t,r),r}}function po(t,e={}){const{out:n}=e;if(n===void 0)return V.createFrom(t,{colorModel:"GREY"});{if(!(n instanceof V))throw new TypeError("out must be an Image");const r={width:t.width,height:t.height,bitDepth:8,colorModel:"GREY"};return at(r,n),n}}function ye(t,e={}){const{out:n}=e;if(n===void 0)return P.createFrom(t);{if(!(n instanceof P))throw new TypeError("out must be a Mask");const r={width:t.width,height:t.height,bitDepth:1,colorModel:"BINARY"};return at(r,n),n}}function at(t,e){for(const n in t){const r=n;if(e[r]!==t[r])throw new RangeError(`cannot use out image. Its ${n} property must be ${t[r]}. Received ${e[r]}`)}}function Y(t,e={},n={}){const{out:r}=e,{newParameters:o,clone:l}=n;if(r===void 0)return l?t.clone():P.createFrom(t,o);{if(!(r instanceof P))throw new TypeError("out must be a Mask");const i={width:t.width,height:t.height,bitDepth:1,colorModel:"BINARY"};return at(i,r),l&&t!==r&&we(t,r),r}}function Mo(t){const e=t.getContext("2d");T(e);const n=e.getImageData(0,0,t.width,t.height);return new V(n.width,n.height,{data:new Uint8Array(n.data.buffer,n.data.byteOffset,n.data.byteLength),colorModel:"RGBA"})}function mo(t){const e=document.createElement("canvas");e.width=t.width,e.height=t.height;const n=e.getContext("2d");return T(n),n.drawImage(t,0,0),Mo(e)}export{mo as r};
