import{a as __toCommonJS,i as __require,n as __esmMin,o as __toESM,r as __export,t as __commonJSMin}from"./rolldown-runtime-tX5UdD3f.js";var lib_esm_exports=__export({isAnyArray:()=>isAnyArray});function isAnyArray(value){let tag=toString$2.call(value);return tag.endsWith(`Array]`)&&!tag.includes(`Big`)}var toString$2,init_lib_esm=__esmMin((()=>{toString$2=Object.prototype.toString}));function max$1(input){var options=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};if(!isAnyArray(input))throw TypeError(`input must be an array`);if(input.length===0)throw TypeError(`input must not be empty`);var _options$fromIndex=options.fromIndex,fromIndex=_options$fromIndex===void 0?0:_options$fromIndex,_options$toIndex=options.toIndex,toIndex=_options$toIndex===void 0?input.length:_options$toIndex;if(fromIndex<0||fromIndex>=input.length||!Number.isInteger(fromIndex))throw Error(`fromIndex must be a positive integer smaller than length`);if(toIndex<=fromIndex||toIndex>input.length||!Number.isInteger(toIndex))throw Error(`toIndex must be an integer greater than fromIndex and at most equal to length`);for(var maxValue=input[fromIndex],i$3=fromIndex+1;i$3<toIndex;i$3++)input[i$3]>maxValue&&(maxValue=input[i$3]);return maxValue}var init_lib_es6$2=__esmMin((()=>{init_lib_esm()}));function min$1(input){var options=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};if(!isAnyArray(input))throw TypeError(`input must be an array`);if(input.length===0)throw TypeError(`input must not be empty`);var _options$fromIndex=options.fromIndex,fromIndex=_options$fromIndex===void 0?0:_options$fromIndex,_options$toIndex=options.toIndex,toIndex=_options$toIndex===void 0?input.length:_options$toIndex;if(fromIndex<0||fromIndex>=input.length||!Number.isInteger(fromIndex))throw Error(`fromIndex must be a positive integer smaller than length`);if(toIndex<=fromIndex||toIndex>input.length||!Number.isInteger(toIndex))throw Error(`toIndex must be an integer greater than fromIndex and at most equal to length`);for(var minValue=input[fromIndex],i$3=fromIndex+1;i$3<toIndex;i$3++)input[i$3]<minValue&&(minValue=input[i$3]);return minValue}var init_lib_es6$1=__esmMin((()=>{init_lib_esm()})),lib_es6_exports=__export({default:()=>rescale$1});function rescale$1(input){var options=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};if(isAnyArray(input)){if(input.length===0)throw TypeError(`input must not be empty`)}else throw TypeError(`input must be an array`);var output;if(options.output!==void 0){if(!isAnyArray(options.output))throw TypeError(`output option must be an array if specified`);output=options.output}else output=Array(input.length);var currentMin=min$1(input),currentMax=max$1(input);if(currentMin===currentMax)throw RangeError(`minimum and maximum input values are equal. Cannot rescale a constant array`);var _options$min=options.min,minValue=_options$min===void 0?options.autoMinMax?currentMin:0:_options$min,_options$max=options.max,maxValue=_options$max===void 0?options.autoMinMax?currentMax:1:_options$max;if(minValue>=maxValue)throw RangeError(`min option must be smaller than max option`);for(var factor=(maxValue-minValue)/(currentMax-currentMin),i$3=0;i$3<input.length;i$3++)output[i$3]=(input[i$3]-currentMin)*factor+minValue;return output}var init_lib_es6=__esmMin((()=>{init_lib_esm(),init_lib_es6$2(),init_lib_es6$1()})),import_matrix=__toESM(__commonJSMin((exports=>{Object.defineProperty(exports,`__esModule`,{value:!0});var isAnyArray$1=(init_lib_esm(),__toCommonJS(lib_esm_exports)),rescale=(init_lib_es6(),__toCommonJS(lib_es6_exports)),indent=` `.repeat(2),indentData=` `.repeat(4);function inspectMatrix(){return inspectMatrixWithOptions(this)}function inspectMatrixWithOptions(matrix,options={}){let{maxRows=15,maxColumns=10,maxNumSize=8,padMinus=`auto`}=options;return`${matrix.constructor.name} {
${indent}[
${indentData}${inspectData(matrix,maxRows,maxColumns,maxNumSize,padMinus)}
${indent}]
${indent}rows: ${matrix.rows}
${indent}columns: ${matrix.columns}
}`}function inspectData(matrix,maxRows,maxColumns,maxNumSize,padMinus){let{rows,columns}=matrix,maxI=Math.min(rows,maxRows),maxJ=Math.min(columns,maxColumns),result=[];if(padMinus===`auto`){padMinus=!1;loop:for(let i$3=0;i$3<maxI;i$3++)for(let j$2=0;j$2<maxJ;j$2++)if(matrix.get(i$3,j$2)<0){padMinus=!0;break loop}}for(let i$3=0;i$3<maxI;i$3++){let line$3=[];for(let j$2=0;j$2<maxJ;j$2++)line$3.push(formatNumber(matrix.get(i$3,j$2),maxNumSize,padMinus));result.push(`${line$3.join(` `)}`)}return maxJ!==columns&&(result[result.length-1]+=` ... ${columns-maxColumns} more columns`),maxI!==rows&&result.push(`... ${rows-maxRows} more rows`),result.join(`\n${indentData}`)}function formatNumber(num,maxNumSize,padMinus){return(num>=0&&padMinus?` ${formatNumber2(num,maxNumSize-1)}`:formatNumber2(num,maxNumSize)).padEnd(maxNumSize)}function formatNumber2(num,len){let str=num.toString();if(str.length<=len)return str;let fix=num.toFixed(len);if(fix.length>len&&(fix=num.toFixed(Math.max(0,len-(fix.length-len)))),fix.length<=len&&!fix.startsWith(`0.000`)&&!fix.startsWith(`-0.000`))return fix;let exp=num.toExponential(len);return exp.length>len&&(exp=num.toExponential(Math.max(0,len-(exp.length-len)))),exp.slice(0)}function installMathOperations(AbstractMatrix$2,Matrix$2){AbstractMatrix$2.prototype.add=function(value){return typeof value==`number`?this.addS(value):this.addM(value)},AbstractMatrix$2.prototype.addS=function(value){for(let i$3=0;i$3<this.rows;i$3++)for(let j$2=0;j$2<this.columns;j$2++)this.set(i$3,j$2,this.get(i$3,j$2)+value);return this},AbstractMatrix$2.prototype.addM=function(matrix){if(matrix=Matrix$2.checkMatrix(matrix),this.rows!==matrix.rows||this.columns!==matrix.columns)throw RangeError(`Matrices dimensions must be equal`);for(let i$3=0;i$3<this.rows;i$3++)for(let j$2=0;j$2<this.columns;j$2++)this.set(i$3,j$2,this.get(i$3,j$2)+matrix.get(i$3,j$2));return this},AbstractMatrix$2.add=function(matrix,value){return new Matrix$2(matrix).add(value)},AbstractMatrix$2.prototype.sub=function(value){return typeof value==`number`?this.subS(value):this.subM(value)},AbstractMatrix$2.prototype.subS=function(value){for(let i$3=0;i$3<this.rows;i$3++)for(let j$2=0;j$2<this.columns;j$2++)this.set(i$3,j$2,this.get(i$3,j$2)-value);return this},AbstractMatrix$2.prototype.subM=function(matrix){if(matrix=Matrix$2.checkMatrix(matrix),this.rows!==matrix.rows||this.columns!==matrix.columns)throw RangeError(`Matrices dimensions must be equal`);for(let i$3=0;i$3<this.rows;i$3++)for(let j$2=0;j$2<this.columns;j$2++)this.set(i$3,j$2,this.get(i$3,j$2)-matrix.get(i$3,j$2));return this},AbstractMatrix$2.sub=function(matrix,value){return new Matrix$2(matrix).sub(value)},AbstractMatrix$2.prototype.subtract=AbstractMatrix$2.prototype.sub,AbstractMatrix$2.prototype.subtractS=AbstractMatrix$2.prototype.subS,AbstractMatrix$2.prototype.subtractM=AbstractMatrix$2.prototype.subM,AbstractMatrix$2.subtract=AbstractMatrix$2.sub,AbstractMatrix$2.prototype.mul=function(value){return typeof value==`number`?this.mulS(value):this.mulM(value)},AbstractMatrix$2.prototype.mulS=function(value){for(let i$3=0;i$3<this.rows;i$3++)for(let j$2=0;j$2<this.columns;j$2++)this.set(i$3,j$2,this.get(i$3,j$2)*value);return this},AbstractMatrix$2.prototype.mulM=function(matrix){if(matrix=Matrix$2.checkMatrix(matrix),this.rows!==matrix.rows||this.columns!==matrix.columns)throw RangeError(`Matrices dimensions must be equal`);for(let i$3=0;i$3<this.rows;i$3++)for(let j$2=0;j$2<this.columns;j$2++)this.set(i$3,j$2,this.get(i$3,j$2)*matrix.get(i$3,j$2));return this},AbstractMatrix$2.mul=function(matrix,value){return new Matrix$2(matrix).mul(value)},AbstractMatrix$2.prototype.multiply=AbstractMatrix$2.prototype.mul,AbstractMatrix$2.prototype.multiplyS=AbstractMatrix$2.prototype.mulS,AbstractMatrix$2.prototype.multiplyM=AbstractMatrix$2.prototype.mulM,AbstractMatrix$2.multiply=AbstractMatrix$2.mul,AbstractMatrix$2.prototype.div=function(value){return typeof value==`number`?this.divS(value):this.divM(value)},AbstractMatrix$2.prototype.divS=function(value){for(let i$3=0;i$3<this.rows;i$3++)for(let j$2=0;j$2<this.columns;j$2++)this.set(i$3,j$2,this.get(i$3,j$2)/value);return this},AbstractMatrix$2.prototype.divM=function(matrix){if(matrix=Matrix$2.checkMatrix(matrix),this.rows!==matrix.rows||this.columns!==matrix.columns)throw RangeError(`Matrices dimensions must be equal`);for(let i$3=0;i$3<this.rows;i$3++)for(let j$2=0;j$2<this.columns;j$2++)this.set(i$3,j$2,this.get(i$3,j$2)/matrix.get(i$3,j$2));return this},AbstractMatrix$2.div=function(matrix,value){return new Matrix$2(matrix).div(value)},AbstractMatrix$2.prototype.divide=AbstractMatrix$2.prototype.div,AbstractMatrix$2.prototype.divideS=AbstractMatrix$2.prototype.divS,AbstractMatrix$2.prototype.divideM=AbstractMatrix$2.prototype.divM,AbstractMatrix$2.divide=AbstractMatrix$2.div,AbstractMatrix$2.prototype.mod=function(value){return typeof value==`number`?this.modS(value):this.modM(value)},AbstractMatrix$2.prototype.modS=function(value){for(let i$3=0;i$3<this.rows;i$3++)for(let j$2=0;j$2<this.columns;j$2++)this.set(i$3,j$2,this.get(i$3,j$2)%value);return this},AbstractMatrix$2.prototype.modM=function(matrix){if(matrix=Matrix$2.checkMatrix(matrix),this.rows!==matrix.rows||this.columns!==matrix.columns)throw RangeError(`Matrices dimensions must be equal`);for(let i$3=0;i$3<this.rows;i$3++)for(let j$2=0;j$2<this.columns;j$2++)this.set(i$3,j$2,this.get(i$3,j$2)%matrix.get(i$3,j$2));return this},AbstractMatrix$2.mod=function(matrix,value){return new Matrix$2(matrix).mod(value)},AbstractMatrix$2.prototype.modulus=AbstractMatrix$2.prototype.mod,AbstractMatrix$2.prototype.modulusS=AbstractMatrix$2.prototype.modS,AbstractMatrix$2.prototype.modulusM=AbstractMatrix$2.prototype.modM,AbstractMatrix$2.modulus=AbstractMatrix$2.mod,AbstractMatrix$2.prototype.and=function(value){return typeof value==`number`?this.andS(value):this.andM(value)},AbstractMatrix$2.prototype.andS=function(value){for(let i$3=0;i$3<this.rows;i$3++)for(let j$2=0;j$2<this.columns;j$2++)this.set(i$3,j$2,this.get(i$3,j$2)&value);return this},AbstractMatrix$2.prototype.andM=function(matrix){if(matrix=Matrix$2.checkMatrix(matrix),this.rows!==matrix.rows||this.columns!==matrix.columns)throw RangeError(`Matrices dimensions must be equal`);for(let i$3=0;i$3<this.rows;i$3++)for(let j$2=0;j$2<this.columns;j$2++)this.set(i$3,j$2,this.get(i$3,j$2)&matrix.get(i$3,j$2));return this},AbstractMatrix$2.and=function(matrix,value){return new Matrix$2(matrix).and(value)},AbstractMatrix$2.prototype.or=function(value){return typeof value==`number`?this.orS(value):this.orM(value)},AbstractMatrix$2.prototype.orS=function(value){for(let i$3=0;i$3<this.rows;i$3++)for(let j$2=0;j$2<this.columns;j$2++)this.set(i$3,j$2,this.get(i$3,j$2)|value);return this},AbstractMatrix$2.prototype.orM=function(matrix){if(matrix=Matrix$2.checkMatrix(matrix),this.rows!==matrix.rows||this.columns!==matrix.columns)throw RangeError(`Matrices dimensions must be equal`);for(let i$3=0;i$3<this.rows;i$3++)for(let j$2=0;j$2<this.columns;j$2++)this.set(i$3,j$2,this.get(i$3,j$2)|matrix.get(i$3,j$2));return this},AbstractMatrix$2.or=function(matrix,value){return new Matrix$2(matrix).or(value)},AbstractMatrix$2.prototype.xor=function(value){return typeof value==`number`?this.xorS(value):this.xorM(value)},AbstractMatrix$2.prototype.xorS=function(value){for(let i$3=0;i$3<this.rows;i$3++)for(let j$2=0;j$2<this.columns;j$2++)this.set(i$3,j$2,this.get(i$3,j$2)^value);return this},AbstractMatrix$2.prototype.xorM=function(matrix){if(matrix=Matrix$2.checkMatrix(matrix),this.rows!==matrix.rows||this.columns!==matrix.columns)throw RangeError(`Matrices dimensions must be equal`);for(let i$3=0;i$3<this.rows;i$3++)for(let j$2=0;j$2<this.columns;j$2++)this.set(i$3,j$2,this.get(i$3,j$2)^matrix.get(i$3,j$2));return this},AbstractMatrix$2.xor=function(matrix,value){return new Matrix$2(matrix).xor(value)},AbstractMatrix$2.prototype.leftShift=function(value){return typeof value==`number`?this.leftShiftS(value):this.leftShiftM(value)},AbstractMatrix$2.prototype.leftShiftS=function(value){for(let i$3=0;i$3<this.rows;i$3++)for(let j$2=0;j$2<this.columns;j$2++)this.set(i$3,j$2,this.get(i$3,j$2)<<value);return this},AbstractMatrix$2.prototype.leftShiftM=function(matrix){if(matrix=Matrix$2.checkMatrix(matrix),this.rows!==matrix.rows||this.columns!==matrix.columns)throw RangeError(`Matrices dimensions must be equal`);for(let i$3=0;i$3<this.rows;i$3++)for(let j$2=0;j$2<this.columns;j$2++)this.set(i$3,j$2,this.get(i$3,j$2)<<matrix.get(i$3,j$2));return this},AbstractMatrix$2.leftShift=function(matrix,value){return new Matrix$2(matrix).leftShift(value)},AbstractMatrix$2.prototype.signPropagatingRightShift=function(value){return typeof value==`number`?this.signPropagatingRightShiftS(value):this.signPropagatingRightShiftM(value)},AbstractMatrix$2.prototype.signPropagatingRightShiftS=function(value){for(let i$3=0;i$3<this.rows;i$3++)for(let j$2=0;j$2<this.columns;j$2++)this.set(i$3,j$2,this.get(i$3,j$2)>>value);return this},AbstractMatrix$2.prototype.signPropagatingRightShiftM=function(matrix){if(matrix=Matrix$2.checkMatrix(matrix),this.rows!==matrix.rows||this.columns!==matrix.columns)throw RangeError(`Matrices dimensions must be equal`);for(let i$3=0;i$3<this.rows;i$3++)for(let j$2=0;j$2<this.columns;j$2++)this.set(i$3,j$2,this.get(i$3,j$2)>>matrix.get(i$3,j$2));return this},AbstractMatrix$2.signPropagatingRightShift=function(matrix,value){return new Matrix$2(matrix).signPropagatingRightShift(value)},AbstractMatrix$2.prototype.rightShift=function(value){return typeof value==`number`?this.rightShiftS(value):this.rightShiftM(value)},AbstractMatrix$2.prototype.rightShiftS=function(value){for(let i$3=0;i$3<this.rows;i$3++)for(let j$2=0;j$2<this.columns;j$2++)this.set(i$3,j$2,this.get(i$3,j$2)>>>value);return this},AbstractMatrix$2.prototype.rightShiftM=function(matrix){if(matrix=Matrix$2.checkMatrix(matrix),this.rows!==matrix.rows||this.columns!==matrix.columns)throw RangeError(`Matrices dimensions must be equal`);for(let i$3=0;i$3<this.rows;i$3++)for(let j$2=0;j$2<this.columns;j$2++)this.set(i$3,j$2,this.get(i$3,j$2)>>>matrix.get(i$3,j$2));return this},AbstractMatrix$2.rightShift=function(matrix,value){return new Matrix$2(matrix).rightShift(value)},AbstractMatrix$2.prototype.zeroFillRightShift=AbstractMatrix$2.prototype.rightShift,AbstractMatrix$2.prototype.zeroFillRightShiftS=AbstractMatrix$2.prototype.rightShiftS,AbstractMatrix$2.prototype.zeroFillRightShiftM=AbstractMatrix$2.prototype.rightShiftM,AbstractMatrix$2.zeroFillRightShift=AbstractMatrix$2.rightShift,AbstractMatrix$2.prototype.not=function(){for(let i$3=0;i$3<this.rows;i$3++)for(let j$2=0;j$2<this.columns;j$2++)this.set(i$3,j$2,~this.get(i$3,j$2));return this},AbstractMatrix$2.not=function(matrix){return new Matrix$2(matrix).not()},AbstractMatrix$2.prototype.abs=function(){for(let i$3=0;i$3<this.rows;i$3++)for(let j$2=0;j$2<this.columns;j$2++)this.set(i$3,j$2,Math.abs(this.get(i$3,j$2)));return this},AbstractMatrix$2.abs=function(matrix){return new Matrix$2(matrix).abs()},AbstractMatrix$2.prototype.acos=function(){for(let i$3=0;i$3<this.rows;i$3++)for(let j$2=0;j$2<this.columns;j$2++)this.set(i$3,j$2,Math.acos(this.get(i$3,j$2)));return this},AbstractMatrix$2.acos=function(matrix){return new Matrix$2(matrix).acos()},AbstractMatrix$2.prototype.acosh=function(){for(let i$3=0;i$3<this.rows;i$3++)for(let j$2=0;j$2<this.columns;j$2++)this.set(i$3,j$2,Math.acosh(this.get(i$3,j$2)));return this},AbstractMatrix$2.acosh=function(matrix){return new Matrix$2(matrix).acosh()},AbstractMatrix$2.prototype.asin=function(){for(let i$3=0;i$3<this.rows;i$3++)for(let j$2=0;j$2<this.columns;j$2++)this.set(i$3,j$2,Math.asin(this.get(i$3,j$2)));return this},AbstractMatrix$2.asin=function(matrix){return new Matrix$2(matrix).asin()},AbstractMatrix$2.prototype.asinh=function(){for(let i$3=0;i$3<this.rows;i$3++)for(let j$2=0;j$2<this.columns;j$2++)this.set(i$3,j$2,Math.asinh(this.get(i$3,j$2)));return this},AbstractMatrix$2.asinh=function(matrix){return new Matrix$2(matrix).asinh()},AbstractMatrix$2.prototype.atan=function(){for(let i$3=0;i$3<this.rows;i$3++)for(let j$2=0;j$2<this.columns;j$2++)this.set(i$3,j$2,Math.atan(this.get(i$3,j$2)));return this},AbstractMatrix$2.atan=function(matrix){return new Matrix$2(matrix).atan()},AbstractMatrix$2.prototype.atanh=function(){for(let i$3=0;i$3<this.rows;i$3++)for(let j$2=0;j$2<this.columns;j$2++)this.set(i$3,j$2,Math.atanh(this.get(i$3,j$2)));return this},AbstractMatrix$2.atanh=function(matrix){return new Matrix$2(matrix).atanh()},AbstractMatrix$2.prototype.cbrt=function(){for(let i$3=0;i$3<this.rows;i$3++)for(let j$2=0;j$2<this.columns;j$2++)this.set(i$3,j$2,Math.cbrt(this.get(i$3,j$2)));return this},AbstractMatrix$2.cbrt=function(matrix){return new Matrix$2(matrix).cbrt()},AbstractMatrix$2.prototype.ceil=function(){for(let i$3=0;i$3<this.rows;i$3++)for(let j$2=0;j$2<this.columns;j$2++)this.set(i$3,j$2,Math.ceil(this.get(i$3,j$2)));return this},AbstractMatrix$2.ceil=function(matrix){return new Matrix$2(matrix).ceil()},AbstractMatrix$2.prototype.clz32=function(){for(let i$3=0;i$3<this.rows;i$3++)for(let j$2=0;j$2<this.columns;j$2++)this.set(i$3,j$2,Math.clz32(this.get(i$3,j$2)));return this},AbstractMatrix$2.clz32=function(matrix){return new Matrix$2(matrix).clz32()},AbstractMatrix$2.prototype.cos=function(){for(let i$3=0;i$3<this.rows;i$3++)for(let j$2=0;j$2<this.columns;j$2++)this.set(i$3,j$2,Math.cos(this.get(i$3,j$2)));return this},AbstractMatrix$2.cos=function(matrix){return new Matrix$2(matrix).cos()},AbstractMatrix$2.prototype.cosh=function(){for(let i$3=0;i$3<this.rows;i$3++)for(let j$2=0;j$2<this.columns;j$2++)this.set(i$3,j$2,Math.cosh(this.get(i$3,j$2)));return this},AbstractMatrix$2.cosh=function(matrix){return new Matrix$2(matrix).cosh()},AbstractMatrix$2.prototype.exp=function(){for(let i$3=0;i$3<this.rows;i$3++)for(let j$2=0;j$2<this.columns;j$2++)this.set(i$3,j$2,Math.exp(this.get(i$3,j$2)));return this},AbstractMatrix$2.exp=function(matrix){return new Matrix$2(matrix).exp()},AbstractMatrix$2.prototype.expm1=function(){for(let i$3=0;i$3<this.rows;i$3++)for(let j$2=0;j$2<this.columns;j$2++)this.set(i$3,j$2,Math.expm1(this.get(i$3,j$2)));return this},AbstractMatrix$2.expm1=function(matrix){return new Matrix$2(matrix).expm1()},AbstractMatrix$2.prototype.floor=function(){for(let i$3=0;i$3<this.rows;i$3++)for(let j$2=0;j$2<this.columns;j$2++)this.set(i$3,j$2,Math.floor(this.get(i$3,j$2)));return this},AbstractMatrix$2.floor=function(matrix){return new Matrix$2(matrix).floor()},AbstractMatrix$2.prototype.fround=function(){for(let i$3=0;i$3<this.rows;i$3++)for(let j$2=0;j$2<this.columns;j$2++)this.set(i$3,j$2,Math.fround(this.get(i$3,j$2)));return this},AbstractMatrix$2.fround=function(matrix){return new Matrix$2(matrix).fround()},AbstractMatrix$2.prototype.log=function(){for(let i$3=0;i$3<this.rows;i$3++)for(let j$2=0;j$2<this.columns;j$2++)this.set(i$3,j$2,Math.log(this.get(i$3,j$2)));return this},AbstractMatrix$2.log=function(matrix){return new Matrix$2(matrix).log()},AbstractMatrix$2.prototype.log1p=function(){for(let i$3=0;i$3<this.rows;i$3++)for(let j$2=0;j$2<this.columns;j$2++)this.set(i$3,j$2,Math.log1p(this.get(i$3,j$2)));return this},AbstractMatrix$2.log1p=function(matrix){return new Matrix$2(matrix).log1p()},AbstractMatrix$2.prototype.log10=function(){for(let i$3=0;i$3<this.rows;i$3++)for(let j$2=0;j$2<this.columns;j$2++)this.set(i$3,j$2,Math.log10(this.get(i$3,j$2)));return this},AbstractMatrix$2.log10=function(matrix){return new Matrix$2(matrix).log10()},AbstractMatrix$2.prototype.log2=function(){for(let i$3=0;i$3<this.rows;i$3++)for(let j$2=0;j$2<this.columns;j$2++)this.set(i$3,j$2,Math.log2(this.get(i$3,j$2)));return this},AbstractMatrix$2.log2=function(matrix){return new Matrix$2(matrix).log2()},AbstractMatrix$2.prototype.round=function(){for(let i$3=0;i$3<this.rows;i$3++)for(let j$2=0;j$2<this.columns;j$2++)this.set(i$3,j$2,Math.round(this.get(i$3,j$2)));return this},AbstractMatrix$2.round=function(matrix){return new Matrix$2(matrix).round()},AbstractMatrix$2.prototype.sign=function(){for(let i$3=0;i$3<this.rows;i$3++)for(let j$2=0;j$2<this.columns;j$2++)this.set(i$3,j$2,Math.sign(this.get(i$3,j$2)));return this},AbstractMatrix$2.sign=function(matrix){return new Matrix$2(matrix).sign()},AbstractMatrix$2.prototype.sin=function(){for(let i$3=0;i$3<this.rows;i$3++)for(let j$2=0;j$2<this.columns;j$2++)this.set(i$3,j$2,Math.sin(this.get(i$3,j$2)));return this},AbstractMatrix$2.sin=function(matrix){return new Matrix$2(matrix).sin()},AbstractMatrix$2.prototype.sinh=function(){for(let i$3=0;i$3<this.rows;i$3++)for(let j$2=0;j$2<this.columns;j$2++)this.set(i$3,j$2,Math.sinh(this.get(i$3,j$2)));return this},AbstractMatrix$2.sinh=function(matrix){return new Matrix$2(matrix).sinh()},AbstractMatrix$2.prototype.sqrt=function(){for(let i$3=0;i$3<this.rows;i$3++)for(let j$2=0;j$2<this.columns;j$2++)this.set(i$3,j$2,Math.sqrt(this.get(i$3,j$2)));return this},AbstractMatrix$2.sqrt=function(matrix){return new Matrix$2(matrix).sqrt()},AbstractMatrix$2.prototype.tan=function(){for(let i$3=0;i$3<this.rows;i$3++)for(let j$2=0;j$2<this.columns;j$2++)this.set(i$3,j$2,Math.tan(this.get(i$3,j$2)));return this},AbstractMatrix$2.tan=function(matrix){return new Matrix$2(matrix).tan()},AbstractMatrix$2.prototype.tanh=function(){for(let i$3=0;i$3<this.rows;i$3++)for(let j$2=0;j$2<this.columns;j$2++)this.set(i$3,j$2,Math.tanh(this.get(i$3,j$2)));return this},AbstractMatrix$2.tanh=function(matrix){return new Matrix$2(matrix).tanh()},AbstractMatrix$2.prototype.trunc=function(){for(let i$3=0;i$3<this.rows;i$3++)for(let j$2=0;j$2<this.columns;j$2++)this.set(i$3,j$2,Math.trunc(this.get(i$3,j$2)));return this},AbstractMatrix$2.trunc=function(matrix){return new Matrix$2(matrix).trunc()},AbstractMatrix$2.pow=function(matrix,arg0){return new Matrix$2(matrix).pow(arg0)},AbstractMatrix$2.prototype.pow=function(value){return typeof value==`number`?this.powS(value):this.powM(value)},AbstractMatrix$2.prototype.powS=function(value){for(let i$3=0;i$3<this.rows;i$3++)for(let j$2=0;j$2<this.columns;j$2++)this.set(i$3,j$2,this.get(i$3,j$2)**value);return this},AbstractMatrix$2.prototype.powM=function(matrix){if(matrix=Matrix$2.checkMatrix(matrix),this.rows!==matrix.rows||this.columns!==matrix.columns)throw RangeError(`Matrices dimensions must be equal`);for(let i$3=0;i$3<this.rows;i$3++)for(let j$2=0;j$2<this.columns;j$2++)this.set(i$3,j$2,this.get(i$3,j$2)**matrix.get(i$3,j$2));return this}}function checkRowIndex(matrix,index,outer){let max$2=outer?matrix.rows:matrix.rows-1;if(index<0||index>max$2)throw RangeError(`Row index out of range`)}function checkColumnIndex(matrix,index,outer){let max$2=outer?matrix.columns:matrix.columns-1;if(index<0||index>max$2)throw RangeError(`Column index out of range`)}function checkRowVector(matrix,vector){if(vector.to1DArray&&(vector=vector.to1DArray()),vector.length!==matrix.columns)throw RangeError(`vector size must be the same as the number of columns`);return vector}function checkColumnVector(matrix,vector){if(vector.to1DArray&&(vector=vector.to1DArray()),vector.length!==matrix.rows)throw RangeError(`vector size must be the same as the number of rows`);return vector}function checkRowIndices(matrix,rowIndices){if(!isAnyArray$1.isAnyArray(rowIndices))throw TypeError(`row indices must be an array`);for(let i$3=0;i$3<rowIndices.length;i$3++)if(rowIndices[i$3]<0||rowIndices[i$3]>=matrix.rows)throw RangeError(`row indices are out of range`)}function checkColumnIndices(matrix,columnIndices){if(!isAnyArray$1.isAnyArray(columnIndices))throw TypeError(`column indices must be an array`);for(let i$3=0;i$3<columnIndices.length;i$3++)if(columnIndices[i$3]<0||columnIndices[i$3]>=matrix.columns)throw RangeError(`column indices are out of range`)}function checkRange$1(matrix,startRow,endRow,startColumn,endColumn){if(arguments.length!==5)throw RangeError(`expected 4 arguments`);if(checkNumber(`startRow`,startRow),checkNumber(`endRow`,endRow),checkNumber(`startColumn`,startColumn),checkNumber(`endColumn`,endColumn),startRow>endRow||startColumn>endColumn||startRow<0||startRow>=matrix.rows||endRow<0||endRow>=matrix.rows||startColumn<0||startColumn>=matrix.columns||endColumn<0||endColumn>=matrix.columns)throw RangeError(`Submatrix indices are out of range`)}function newArray(length,value=0){let array=[];for(let i$3=0;i$3<length;i$3++)array.push(value);return array}function checkNumber(name,value){if(typeof value!=`number`)throw TypeError(`${name} must be a number`)}function checkNonEmpty(matrix){if(matrix.isEmpty())throw Error(`Empty matrix has no elements to index`)}function sumByRow(matrix){let sum=newArray(matrix.rows);for(let i$3=0;i$3<matrix.rows;++i$3)for(let j$2=0;j$2<matrix.columns;++j$2)sum[i$3]+=matrix.get(i$3,j$2);return sum}function sumByColumn(matrix){let sum=newArray(matrix.columns);for(let i$3=0;i$3<matrix.rows;++i$3)for(let j$2=0;j$2<matrix.columns;++j$2)sum[j$2]+=matrix.get(i$3,j$2);return sum}function sumAll(matrix){let v$2=0;for(let i$3=0;i$3<matrix.rows;i$3++)for(let j$2=0;j$2<matrix.columns;j$2++)v$2+=matrix.get(i$3,j$2);return v$2}function productByRow(matrix){let sum=newArray(matrix.rows,1);for(let i$3=0;i$3<matrix.rows;++i$3)for(let j$2=0;j$2<matrix.columns;++j$2)sum[i$3]*=matrix.get(i$3,j$2);return sum}function productByColumn(matrix){let sum=newArray(matrix.columns,1);for(let i$3=0;i$3<matrix.rows;++i$3)for(let j$2=0;j$2<matrix.columns;++j$2)sum[j$2]*=matrix.get(i$3,j$2);return sum}function productAll(matrix){let v$2=1;for(let i$3=0;i$3<matrix.rows;i$3++)for(let j$2=0;j$2<matrix.columns;j$2++)v$2*=matrix.get(i$3,j$2);return v$2}function varianceByRow(matrix,unbiased,mean$2){let rows=matrix.rows,cols=matrix.columns,variance$1=[];for(let i$3=0;i$3<rows;i$3++){let sum1=0,sum2=0,x$2=0;for(let j$2=0;j$2<cols;j$2++)x$2=matrix.get(i$3,j$2)-mean$2[i$3],sum1+=x$2,sum2+=x$2*x$2;unbiased?variance$1.push((sum2-sum1*sum1/cols)/(cols-1)):variance$1.push((sum2-sum1*sum1/cols)/cols)}return variance$1}function varianceByColumn(matrix,unbiased,mean$2){let rows=matrix.rows,cols=matrix.columns,variance$1=[];for(let j$2=0;j$2<cols;j$2++){let sum1=0,sum2=0,x$2=0;for(let i$3=0;i$3<rows;i$3++)x$2=matrix.get(i$3,j$2)-mean$2[j$2],sum1+=x$2,sum2+=x$2*x$2;unbiased?variance$1.push((sum2-sum1*sum1/rows)/(rows-1)):variance$1.push((sum2-sum1*sum1/rows)/rows)}return variance$1}function varianceAll(matrix,unbiased,mean$2){let rows=matrix.rows,cols=matrix.columns,size=rows*cols,sum1=0,sum2=0,x$2=0;for(let i$3=0;i$3<rows;i$3++)for(let j$2=0;j$2<cols;j$2++)x$2=matrix.get(i$3,j$2)-mean$2,sum1+=x$2,sum2+=x$2*x$2;return unbiased?(sum2-sum1*sum1/size)/(size-1):(sum2-sum1*sum1/size)/size}function centerByRow(matrix,mean$2){for(let i$3=0;i$3<matrix.rows;i$3++)for(let j$2=0;j$2<matrix.columns;j$2++)matrix.set(i$3,j$2,matrix.get(i$3,j$2)-mean$2[i$3])}function centerByColumn(matrix,mean$2){for(let i$3=0;i$3<matrix.rows;i$3++)for(let j$2=0;j$2<matrix.columns;j$2++)matrix.set(i$3,j$2,matrix.get(i$3,j$2)-mean$2[j$2])}function centerAll(matrix,mean$2){for(let i$3=0;i$3<matrix.rows;i$3++)for(let j$2=0;j$2<matrix.columns;j$2++)matrix.set(i$3,j$2,matrix.get(i$3,j$2)-mean$2)}function getScaleByRow(matrix){let scale=[];for(let i$3=0;i$3<matrix.rows;i$3++){let sum=0;for(let j$2=0;j$2<matrix.columns;j$2++)sum+=matrix.get(i$3,j$2)**2/(matrix.columns-1);scale.push(Math.sqrt(sum))}return scale}function scaleByRow(matrix,scale){for(let i$3=0;i$3<matrix.rows;i$3++)for(let j$2=0;j$2<matrix.columns;j$2++)matrix.set(i$3,j$2,matrix.get(i$3,j$2)/scale[i$3])}function getScaleByColumn(matrix){let scale=[];for(let j$2=0;j$2<matrix.columns;j$2++){let sum=0;for(let i$3=0;i$3<matrix.rows;i$3++)sum+=matrix.get(i$3,j$2)**2/(matrix.rows-1);scale.push(Math.sqrt(sum))}return scale}function scaleByColumn(matrix,scale){for(let i$3=0;i$3<matrix.rows;i$3++)for(let j$2=0;j$2<matrix.columns;j$2++)matrix.set(i$3,j$2,matrix.get(i$3,j$2)/scale[j$2])}function getScaleAll(matrix){let divider=matrix.size-1,sum=0;for(let j$2=0;j$2<matrix.columns;j$2++)for(let i$3=0;i$3<matrix.rows;i$3++)sum+=matrix.get(i$3,j$2)**2/divider;return Math.sqrt(sum)}function scaleAll(matrix,scale){for(let i$3=0;i$3<matrix.rows;i$3++)for(let j$2=0;j$2<matrix.columns;j$2++)matrix.set(i$3,j$2,matrix.get(i$3,j$2)/scale)}var AbstractMatrix$1=class AbstractMatrix$1{static from1DArray(newRows,newColumns,newData){if(newRows*newColumns!==newData.length)throw RangeError(`data length does not match given dimensions`);let newMatrix=new Matrix$1(newRows,newColumns);for(let row=0;row<newRows;row++)for(let column=0;column<newColumns;column++)newMatrix.set(row,column,newData[row*newColumns+column]);return newMatrix}static rowVector(newData){let vector=new Matrix$1(1,newData.length);for(let i$3=0;i$3<newData.length;i$3++)vector.set(0,i$3,newData[i$3]);return vector}static columnVector(newData){let vector=new Matrix$1(newData.length,1);for(let i$3=0;i$3<newData.length;i$3++)vector.set(i$3,0,newData[i$3]);return vector}static zeros(rows,columns){return new Matrix$1(rows,columns)}static ones(rows,columns){return new Matrix$1(rows,columns).fill(1)}static rand(rows,columns,options={}){if(typeof options!=`object`)throw TypeError(`options must be an object`);let{random=Math.random}=options,matrix=new Matrix$1(rows,columns);for(let i$3=0;i$3<rows;i$3++)for(let j$2=0;j$2<columns;j$2++)matrix.set(i$3,j$2,random());return matrix}static randInt(rows,columns,options={}){if(typeof options!=`object`)throw TypeError(`options must be an object`);let{min:min$2=0,max:max$2=1e3,random=Math.random}=options;if(!Number.isInteger(min$2))throw TypeError(`min must be an integer`);if(!Number.isInteger(max$2))throw TypeError(`max must be an integer`);if(min$2>=max$2)throw RangeError(`min must be smaller than max`);let interval=max$2-min$2,matrix=new Matrix$1(rows,columns);for(let i$3=0;i$3<rows;i$3++)for(let j$2=0;j$2<columns;j$2++){let value=min$2+Math.round(random()*interval);matrix.set(i$3,j$2,value)}return matrix}static eye(rows,columns,value){columns===void 0&&(columns=rows),value===void 0&&(value=1);let min$2=Math.min(rows,columns),matrix=this.zeros(rows,columns);for(let i$3=0;i$3<min$2;i$3++)matrix.set(i$3,i$3,value);return matrix}static diag(data,rows,columns){let l$2=data.length;rows===void 0&&(rows=l$2),columns===void 0&&(columns=rows);let min$2=Math.min(l$2,rows,columns),matrix=this.zeros(rows,columns);for(let i$3=0;i$3<min$2;i$3++)matrix.set(i$3,i$3,data[i$3]);return matrix}static min(matrix1,matrix2){matrix1=this.checkMatrix(matrix1),matrix2=this.checkMatrix(matrix2);let rows=matrix1.rows,columns=matrix1.columns,result=new Matrix$1(rows,columns);for(let i$3=0;i$3<rows;i$3++)for(let j$2=0;j$2<columns;j$2++)result.set(i$3,j$2,Math.min(matrix1.get(i$3,j$2),matrix2.get(i$3,j$2)));return result}static max(matrix1,matrix2){matrix1=this.checkMatrix(matrix1),matrix2=this.checkMatrix(matrix2);let rows=matrix1.rows,columns=matrix1.columns,result=new this(rows,columns);for(let i$3=0;i$3<rows;i$3++)for(let j$2=0;j$2<columns;j$2++)result.set(i$3,j$2,Math.max(matrix1.get(i$3,j$2),matrix2.get(i$3,j$2)));return result}static checkMatrix(value){return AbstractMatrix$1.isMatrix(value)?value:new Matrix$1(value)}static isMatrix(value){return value!=null&&value.klass===`Matrix`}get size(){return this.rows*this.columns}apply(callback){if(typeof callback!=`function`)throw TypeError(`callback must be a function`);for(let i$3=0;i$3<this.rows;i$3++)for(let j$2=0;j$2<this.columns;j$2++)callback.call(this,i$3,j$2);return this}to1DArray(){let array=[];for(let i$3=0;i$3<this.rows;i$3++)for(let j$2=0;j$2<this.columns;j$2++)array.push(this.get(i$3,j$2));return array}to2DArray(){let copy=[];for(let i$3=0;i$3<this.rows;i$3++){copy.push([]);for(let j$2=0;j$2<this.columns;j$2++)copy[i$3].push(this.get(i$3,j$2))}return copy}toJSON(){return this.to2DArray()}isRowVector(){return this.rows===1}isColumnVector(){return this.columns===1}isVector(){return this.rows===1||this.columns===1}isSquare(){return this.rows===this.columns}isEmpty(){return this.rows===0||this.columns===0}isSymmetric(){if(this.isSquare()){for(let i$3=0;i$3<this.rows;i$3++)for(let j$2=0;j$2<=i$3;j$2++)if(this.get(i$3,j$2)!==this.get(j$2,i$3))return!1;return!0}return!1}isDistance(){if(!this.isSymmetric())return!1;for(let i$3=0;i$3<this.rows;i$3++)if(this.get(i$3,i$3)!==0)return!1;return!0}isEchelonForm(){let i$3=0,j$2=0,previousColumn=-1,isEchelonForm=!0,checked=!1;for(;i$3<this.rows&&isEchelonForm;){for(j$2=0,checked=!1;j$2<this.columns&&checked===!1;)this.get(i$3,j$2)===0?j$2++:this.get(i$3,j$2)===1&&j$2>previousColumn?(checked=!0,previousColumn=j$2):(isEchelonForm=!1,checked=!0);i$3++}return isEchelonForm}isReducedEchelonForm(){let i$3=0,j$2=0,previousColumn=-1,isReducedEchelonForm=!0,checked=!1;for(;i$3<this.rows&&isReducedEchelonForm;){for(j$2=0,checked=!1;j$2<this.columns&&checked===!1;)this.get(i$3,j$2)===0?j$2++:this.get(i$3,j$2)===1&&j$2>previousColumn?(checked=!0,previousColumn=j$2):(isReducedEchelonForm=!1,checked=!0);for(let k$2=j$2+1;k$2<this.rows;k$2++)this.get(i$3,k$2)!==0&&(isReducedEchelonForm=!1);i$3++}return isReducedEchelonForm}echelonForm(){let result=this.clone(),h$3=0,k$2=0;for(;h$3<result.rows&&k$2<result.columns;){let iMax=h$3;for(let i$3=h$3;i$3<result.rows;i$3++)result.get(i$3,k$2)>result.get(iMax,k$2)&&(iMax=i$3);if(result.get(iMax,k$2)===0)k$2++;else{result.swapRows(h$3,iMax);let tmp=result.get(h$3,k$2);for(let j$2=k$2;j$2<result.columns;j$2++)result.set(h$3,j$2,result.get(h$3,j$2)/tmp);for(let i$3=h$3+1;i$3<result.rows;i$3++){let factor=result.get(i$3,k$2)/result.get(h$3,k$2);result.set(i$3,k$2,0);for(let j$2=k$2+1;j$2<result.columns;j$2++)result.set(i$3,j$2,result.get(i$3,j$2)-result.get(h$3,j$2)*factor)}h$3++,k$2++}}return result}reducedEchelonForm(){let result=this.echelonForm(),m$1=result.columns,n$3=result.rows,h$3=n$3-1;for(;h$3>=0;)if(result.maxRow(h$3)===0)h$3--;else{let p$3=0,pivot=!1;for(;p$3<n$3&&pivot===!1;)result.get(h$3,p$3)===1?pivot=!0:p$3++;for(let i$3=0;i$3<h$3;i$3++){let factor=result.get(i$3,p$3);for(let j$2=p$3;j$2<m$1;j$2++){let tmp=result.get(i$3,j$2)-factor*result.get(h$3,j$2);result.set(i$3,j$2,tmp)}}h$3--}return result}set(){throw Error(`set method is unimplemented`)}get(){throw Error(`get method is unimplemented`)}repeat(options={}){if(typeof options!=`object`)throw TypeError(`options must be an object`);let{rows=1,columns=1}=options;if(!Number.isInteger(rows)||rows<=0)throw TypeError(`rows must be a positive integer`);if(!Number.isInteger(columns)||columns<=0)throw TypeError(`columns must be a positive integer`);let matrix=new Matrix$1(this.rows*rows,this.columns*columns);for(let i$3=0;i$3<rows;i$3++)for(let j$2=0;j$2<columns;j$2++)matrix.setSubMatrix(this,this.rows*i$3,this.columns*j$2);return matrix}fill(value){for(let i$3=0;i$3<this.rows;i$3++)for(let j$2=0;j$2<this.columns;j$2++)this.set(i$3,j$2,value);return this}neg(){return this.mulS(-1)}getRow(index){checkRowIndex(this,index);let row=[];for(let i$3=0;i$3<this.columns;i$3++)row.push(this.get(index,i$3));return row}getRowVector(index){return Matrix$1.rowVector(this.getRow(index))}setRow(index,array){checkRowIndex(this,index),array=checkRowVector(this,array);for(let i$3=0;i$3<this.columns;i$3++)this.set(index,i$3,array[i$3]);return this}swapRows(row1,row2){checkRowIndex(this,row1),checkRowIndex(this,row2);for(let i$3=0;i$3<this.columns;i$3++){let temp=this.get(row1,i$3);this.set(row1,i$3,this.get(row2,i$3)),this.set(row2,i$3,temp)}return this}getColumn(index){checkColumnIndex(this,index);let column=[];for(let i$3=0;i$3<this.rows;i$3++)column.push(this.get(i$3,index));return column}getColumnVector(index){return Matrix$1.columnVector(this.getColumn(index))}setColumn(index,array){checkColumnIndex(this,index),array=checkColumnVector(this,array);for(let i$3=0;i$3<this.rows;i$3++)this.set(i$3,index,array[i$3]);return this}swapColumns(column1,column2){checkColumnIndex(this,column1),checkColumnIndex(this,column2);for(let i$3=0;i$3<this.rows;i$3++){let temp=this.get(i$3,column1);this.set(i$3,column1,this.get(i$3,column2)),this.set(i$3,column2,temp)}return this}addRowVector(vector){vector=checkRowVector(this,vector);for(let i$3=0;i$3<this.rows;i$3++)for(let j$2=0;j$2<this.columns;j$2++)this.set(i$3,j$2,this.get(i$3,j$2)+vector[j$2]);return this}subRowVector(vector){vector=checkRowVector(this,vector);for(let i$3=0;i$3<this.rows;i$3++)for(let j$2=0;j$2<this.columns;j$2++)this.set(i$3,j$2,this.get(i$3,j$2)-vector[j$2]);return this}mulRowVector(vector){vector=checkRowVector(this,vector);for(let i$3=0;i$3<this.rows;i$3++)for(let j$2=0;j$2<this.columns;j$2++)this.set(i$3,j$2,this.get(i$3,j$2)*vector[j$2]);return this}divRowVector(vector){vector=checkRowVector(this,vector);for(let i$3=0;i$3<this.rows;i$3++)for(let j$2=0;j$2<this.columns;j$2++)this.set(i$3,j$2,this.get(i$3,j$2)/vector[j$2]);return this}addColumnVector(vector){vector=checkColumnVector(this,vector);for(let i$3=0;i$3<this.rows;i$3++)for(let j$2=0;j$2<this.columns;j$2++)this.set(i$3,j$2,this.get(i$3,j$2)+vector[i$3]);return this}subColumnVector(vector){vector=checkColumnVector(this,vector);for(let i$3=0;i$3<this.rows;i$3++)for(let j$2=0;j$2<this.columns;j$2++)this.set(i$3,j$2,this.get(i$3,j$2)-vector[i$3]);return this}mulColumnVector(vector){vector=checkColumnVector(this,vector);for(let i$3=0;i$3<this.rows;i$3++)for(let j$2=0;j$2<this.columns;j$2++)this.set(i$3,j$2,this.get(i$3,j$2)*vector[i$3]);return this}divColumnVector(vector){vector=checkColumnVector(this,vector);for(let i$3=0;i$3<this.rows;i$3++)for(let j$2=0;j$2<this.columns;j$2++)this.set(i$3,j$2,this.get(i$3,j$2)/vector[i$3]);return this}mulRow(index,value){checkRowIndex(this,index);for(let i$3=0;i$3<this.columns;i$3++)this.set(index,i$3,this.get(index,i$3)*value);return this}mulColumn(index,value){checkColumnIndex(this,index);for(let i$3=0;i$3<this.rows;i$3++)this.set(i$3,index,this.get(i$3,index)*value);return this}max(by){if(this.isEmpty())return NaN;switch(by){case`row`:{let max$2=Array(this.rows).fill(-1/0);for(let row=0;row<this.rows;row++)for(let column=0;column<this.columns;column++)this.get(row,column)>max$2[row]&&(max$2[row]=this.get(row,column));return max$2}case`column`:{let max$2=Array(this.columns).fill(-1/0);for(let row=0;row<this.rows;row++)for(let column=0;column<this.columns;column++)this.get(row,column)>max$2[column]&&(max$2[column]=this.get(row,column));return max$2}case void 0:{let max$2=this.get(0,0);for(let row=0;row<this.rows;row++)for(let column=0;column<this.columns;column++)this.get(row,column)>max$2&&(max$2=this.get(row,column));return max$2}default:throw Error(`invalid option: ${by}`)}}maxIndex(){checkNonEmpty(this);let v$2=this.get(0,0),idx=[0,0];for(let i$3=0;i$3<this.rows;i$3++)for(let j$2=0;j$2<this.columns;j$2++)this.get(i$3,j$2)>v$2&&(v$2=this.get(i$3,j$2),idx[0]=i$3,idx[1]=j$2);return idx}min(by){if(this.isEmpty())return NaN;switch(by){case`row`:{let min$2=Array(this.rows).fill(1/0);for(let row=0;row<this.rows;row++)for(let column=0;column<this.columns;column++)this.get(row,column)<min$2[row]&&(min$2[row]=this.get(row,column));return min$2}case`column`:{let min$2=Array(this.columns).fill(1/0);for(let row=0;row<this.rows;row++)for(let column=0;column<this.columns;column++)this.get(row,column)<min$2[column]&&(min$2[column]=this.get(row,column));return min$2}case void 0:{let min$2=this.get(0,0);for(let row=0;row<this.rows;row++)for(let column=0;column<this.columns;column++)this.get(row,column)<min$2&&(min$2=this.get(row,column));return min$2}default:throw Error(`invalid option: ${by}`)}}minIndex(){checkNonEmpty(this);let v$2=this.get(0,0),idx=[0,0];for(let i$3=0;i$3<this.rows;i$3++)for(let j$2=0;j$2<this.columns;j$2++)this.get(i$3,j$2)<v$2&&(v$2=this.get(i$3,j$2),idx[0]=i$3,idx[1]=j$2);return idx}maxRow(row){if(checkRowIndex(this,row),this.isEmpty())return NaN;let v$2=this.get(row,0);for(let i$3=1;i$3<this.columns;i$3++)this.get(row,i$3)>v$2&&(v$2=this.get(row,i$3));return v$2}maxRowIndex(row){checkRowIndex(this,row),checkNonEmpty(this);let v$2=this.get(row,0),idx=[row,0];for(let i$3=1;i$3<this.columns;i$3++)this.get(row,i$3)>v$2&&(v$2=this.get(row,i$3),idx[1]=i$3);return idx}minRow(row){if(checkRowIndex(this,row),this.isEmpty())return NaN;let v$2=this.get(row,0);for(let i$3=1;i$3<this.columns;i$3++)this.get(row,i$3)<v$2&&(v$2=this.get(row,i$3));return v$2}minRowIndex(row){checkRowIndex(this,row),checkNonEmpty(this);let v$2=this.get(row,0),idx=[row,0];for(let i$3=1;i$3<this.columns;i$3++)this.get(row,i$3)<v$2&&(v$2=this.get(row,i$3),idx[1]=i$3);return idx}maxColumn(column){if(checkColumnIndex(this,column),this.isEmpty())return NaN;let v$2=this.get(0,column);for(let i$3=1;i$3<this.rows;i$3++)this.get(i$3,column)>v$2&&(v$2=this.get(i$3,column));return v$2}maxColumnIndex(column){checkColumnIndex(this,column),checkNonEmpty(this);let v$2=this.get(0,column),idx=[0,column];for(let i$3=1;i$3<this.rows;i$3++)this.get(i$3,column)>v$2&&(v$2=this.get(i$3,column),idx[0]=i$3);return idx}minColumn(column){if(checkColumnIndex(this,column),this.isEmpty())return NaN;let v$2=this.get(0,column);for(let i$3=1;i$3<this.rows;i$3++)this.get(i$3,column)<v$2&&(v$2=this.get(i$3,column));return v$2}minColumnIndex(column){checkColumnIndex(this,column),checkNonEmpty(this);let v$2=this.get(0,column),idx=[0,column];for(let i$3=1;i$3<this.rows;i$3++)this.get(i$3,column)<v$2&&(v$2=this.get(i$3,column),idx[0]=i$3);return idx}diag(){let min$2=Math.min(this.rows,this.columns),diag=[];for(let i$3=0;i$3<min$2;i$3++)diag.push(this.get(i$3,i$3));return diag}norm(type=`frobenius`){switch(type){case`max`:return this.max();case`frobenius`:return Math.sqrt(this.dot(this));default:throw RangeError(`unknown norm type: ${type}`)}}cumulativeSum(){let sum=0;for(let i$3=0;i$3<this.rows;i$3++)for(let j$2=0;j$2<this.columns;j$2++)sum+=this.get(i$3,j$2),this.set(i$3,j$2,sum);return this}dot(vector2){AbstractMatrix$1.isMatrix(vector2)&&(vector2=vector2.to1DArray());let vector1=this.to1DArray();if(vector1.length!==vector2.length)throw RangeError(`vectors do not have the same size`);let dot=0;for(let i$3=0;i$3<vector1.length;i$3++)dot+=vector1[i$3]*vector2[i$3];return dot}mmul(other){other=Matrix$1.checkMatrix(other);let m$1=this.rows,n$3=this.columns,p$3=other.columns,result=new Matrix$1(m$1,p$3),Bcolj=new Float64Array(n$3);for(let j$2=0;j$2<p$3;j$2++){for(let k$2=0;k$2<n$3;k$2++)Bcolj[k$2]=other.get(k$2,j$2);for(let i$3=0;i$3<m$1;i$3++){let s$2=0;for(let k$2=0;k$2<n$3;k$2++)s$2+=this.get(i$3,k$2)*Bcolj[k$2];result.set(i$3,j$2,s$2)}}return result}mpow(scalar){if(!this.isSquare())throw RangeError(`Matrix must be square`);if(!Number.isInteger(scalar)||scalar<0)throw RangeError(`Exponent must be a non-negative integer`);let result=Matrix$1.eye(this.rows),bb=this;for(let e$3=scalar;e$3>=1;e$3/=2)e$3&1&&(result=result.mmul(bb)),bb=bb.mmul(bb);return result}strassen2x2(other){other=Matrix$1.checkMatrix(other);let result=new Matrix$1(2,2),a11=this.get(0,0),b11=other.get(0,0),a12=this.get(0,1),b12=other.get(0,1),a21=this.get(1,0),b21=other.get(1,0),a22=this.get(1,1),b22=other.get(1,1),m1=(a11+a22)*(b11+b22),m2=(a21+a22)*b11,m3=a11*(b12-b22),m4=a22*(b21-b11),m5=(a11+a12)*b22,m6=(a21-a11)*(b11+b12),m7=(a12-a22)*(b21+b22),c00=m1+m4-m5+m7,c01=m3+m5,c10=m2+m4,c11=m1-m2+m3+m6;return result.set(0,0,c00),result.set(0,1,c01),result.set(1,0,c10),result.set(1,1,c11),result}strassen3x3(other){other=Matrix$1.checkMatrix(other);let result=new Matrix$1(3,3),a00=this.get(0,0),a01=this.get(0,1),a02=this.get(0,2),a10=this.get(1,0),a11=this.get(1,1),a12=this.get(1,2),a20=this.get(2,0),a21=this.get(2,1),a22=this.get(2,2),b00=other.get(0,0),b01=other.get(0,1),b02=other.get(0,2),b10=other.get(1,0),b11=other.get(1,1),b12=other.get(1,2),b20=other.get(2,0),b21=other.get(2,1),b22=other.get(2,2),m1=(a00+a01+a02-a10-a11-a21-a22)*b11,m2=(a00-a10)*(-b01+b11),m3=a11*(-b00+b01+b10-b11-b12-b20+b22),m4=(-a00+a10+a11)*(b00-b01+b11),m5=(a10+a11)*(-b00+b01),m6=a00*b00,m7=(-a00+a20+a21)*(b00-b02+b12),m8=(-a00+a20)*(b02-b12),m9=(a20+a21)*(-b00+b02),m10=(a00+a01+a02-a11-a12-a20-a21)*b12,m11=a21*(-b00+b02+b10-b11-b12-b20+b21),m12=(-a02+a21+a22)*(b11+b20-b21),m13=(a02-a22)*(b11-b21),m14=a02*b20,m15=(a21+a22)*(-b20+b21),m16=(-a02+a11+a12)*(b12+b20-b22),m17=(a02-a12)*(b12-b22),m18=(a11+a12)*(-b20+b22),m19=a01*b10,m20=a12*b21,m21=a10*b02,m22=a20*b01,m23=a22*b22,c00=m6+m14+m19,c01=m1+m4+m5+m6+m12+m14+m15,c02=m6+m7+m9+m10+m14+m16+m18,c10=m2+m3+m4+m6+m14+m16+m17,c11=m2+m4+m5+m6+m20,c12=m14+m16+m17+m18+m21,c20=m6+m7+m8+m11+m12+m13+m14,c21=m12+m13+m14+m15+m22,c22=m6+m7+m8+m9+m23;return result.set(0,0,c00),result.set(0,1,c01),result.set(0,2,c02),result.set(1,0,c10),result.set(1,1,c11),result.set(1,2,c12),result.set(2,0,c20),result.set(2,1,c21),result.set(2,2,c22),result}mmulStrassen(y$2){y$2=Matrix$1.checkMatrix(y$2);let x$2=this.clone(),r1=x$2.rows,c1=x$2.columns,r2=y$2.rows,c2=y$2.columns;c1!==r2&&console.warn(`Multiplying ${r1} x ${c1} and ${r2} x ${c2} matrix: dimensions do not match.`);function embed(mat,rows,cols){let r$4=mat.rows,c$3=mat.columns;if(r$4===rows&&c$3===cols)return mat;{let resultat=AbstractMatrix$1.zeros(rows,cols);return resultat=resultat.setSubMatrix(mat,0,0),resultat}}let r$3=Math.max(r1,r2),c$2=Math.max(c1,c2);x$2=embed(x$2,r$3,c$2),y$2=embed(y$2,r$3,c$2);function blockMult(a$3,b$3,rows,cols){if(rows<=512||cols<=512)return a$3.mmul(b$3);rows%2==1&&cols%2==1?(a$3=embed(a$3,rows+1,cols+1),b$3=embed(b$3,rows+1,cols+1)):rows%2==1?(a$3=embed(a$3,rows+1,cols),b$3=embed(b$3,rows+1,cols)):cols%2==1&&(a$3=embed(a$3,rows,cols+1),b$3=embed(b$3,rows,cols+1));let halfRows=parseInt(a$3.rows/2,10),halfCols=parseInt(a$3.columns/2,10),a11=a$3.subMatrix(0,halfRows-1,0,halfCols-1),b11=b$3.subMatrix(0,halfRows-1,0,halfCols-1),a12=a$3.subMatrix(0,halfRows-1,halfCols,a$3.columns-1),b12=b$3.subMatrix(0,halfRows-1,halfCols,b$3.columns-1),a21=a$3.subMatrix(halfRows,a$3.rows-1,0,halfCols-1),b21=b$3.subMatrix(halfRows,b$3.rows-1,0,halfCols-1),a22=a$3.subMatrix(halfRows,a$3.rows-1,halfCols,a$3.columns-1),b22=b$3.subMatrix(halfRows,b$3.rows-1,halfCols,b$3.columns-1),m1=blockMult(AbstractMatrix$1.add(a11,a22),AbstractMatrix$1.add(b11,b22),halfRows,halfCols),m2=blockMult(AbstractMatrix$1.add(a21,a22),b11,halfRows,halfCols),m3=blockMult(a11,AbstractMatrix$1.sub(b12,b22),halfRows,halfCols),m4=blockMult(a22,AbstractMatrix$1.sub(b21,b11),halfRows,halfCols),m5=blockMult(AbstractMatrix$1.add(a11,a12),b22,halfRows,halfCols),m6=blockMult(AbstractMatrix$1.sub(a21,a11),AbstractMatrix$1.add(b11,b12),halfRows,halfCols),m7=blockMult(AbstractMatrix$1.sub(a12,a22),AbstractMatrix$1.add(b21,b22),halfRows,halfCols),c11=AbstractMatrix$1.add(m1,m4);c11.sub(m5),c11.add(m7);let c12=AbstractMatrix$1.add(m3,m5),c21=AbstractMatrix$1.add(m2,m4),c22=AbstractMatrix$1.sub(m1,m2);c22.add(m3),c22.add(m6);let result=AbstractMatrix$1.zeros(2*c11.rows,2*c11.columns);return result=result.setSubMatrix(c11,0,0),result=result.setSubMatrix(c12,c11.rows,0),result=result.setSubMatrix(c21,0,c11.columns),result=result.setSubMatrix(c22,c11.rows,c11.columns),result.subMatrix(0,rows-1,0,cols-1)}return blockMult(x$2,y$2,r$3,c$2)}scaleRows(options={}){if(typeof options!=`object`)throw TypeError(`options must be an object`);let{min:min$2=0,max:max$2=1}=options;if(!Number.isFinite(min$2))throw TypeError(`min must be a number`);if(!Number.isFinite(max$2))throw TypeError(`max must be a number`);if(min$2>=max$2)throw RangeError(`min must be smaller than max`);let newMatrix=new Matrix$1(this.rows,this.columns);for(let i$3=0;i$3<this.rows;i$3++){let row=this.getRow(i$3);row.length>0&&rescale(row,{min:min$2,max:max$2,output:row}),newMatrix.setRow(i$3,row)}return newMatrix}scaleColumns(options={}){if(typeof options!=`object`)throw TypeError(`options must be an object`);let{min:min$2=0,max:max$2=1}=options;if(!Number.isFinite(min$2))throw TypeError(`min must be a number`);if(!Number.isFinite(max$2))throw TypeError(`max must be a number`);if(min$2>=max$2)throw RangeError(`min must be smaller than max`);let newMatrix=new Matrix$1(this.rows,this.columns);for(let i$3=0;i$3<this.columns;i$3++){let column=this.getColumn(i$3);column.length&&rescale(column,{min:min$2,max:max$2,output:column}),newMatrix.setColumn(i$3,column)}return newMatrix}flipRows(){let middle=Math.ceil(this.columns/2);for(let i$3=0;i$3<this.rows;i$3++)for(let j$2=0;j$2<middle;j$2++){let first=this.get(i$3,j$2),last=this.get(i$3,this.columns-1-j$2);this.set(i$3,j$2,last),this.set(i$3,this.columns-1-j$2,first)}return this}flipColumns(){let middle=Math.ceil(this.rows/2);for(let j$2=0;j$2<this.columns;j$2++)for(let i$3=0;i$3<middle;i$3++){let first=this.get(i$3,j$2),last=this.get(this.rows-1-i$3,j$2);this.set(i$3,j$2,last),this.set(this.rows-1-i$3,j$2,first)}return this}kroneckerProduct(other){other=Matrix$1.checkMatrix(other);let m$1=this.rows,n$3=this.columns,p$3=other.rows,q=other.columns,result=new Matrix$1(m$1*p$3,n$3*q);for(let i$3=0;i$3<m$1;i$3++)for(let j$2=0;j$2<n$3;j$2++)for(let k$2=0;k$2<p$3;k$2++)for(let l$2=0;l$2<q;l$2++)result.set(p$3*i$3+k$2,q*j$2+l$2,this.get(i$3,j$2)*other.get(k$2,l$2));return result}kroneckerSum(other){if(other=Matrix$1.checkMatrix(other),!this.isSquare()||!other.isSquare())throw Error(`Kronecker Sum needs two Square Matrices`);let m$1=this.rows,n$3=other.rows,AxI=this.kroneckerProduct(Matrix$1.eye(n$3,n$3)),IxB=Matrix$1.eye(m$1,m$1).kroneckerProduct(other);return AxI.add(IxB)}transpose(){let result=new Matrix$1(this.columns,this.rows);for(let i$3=0;i$3<this.rows;i$3++)for(let j$2=0;j$2<this.columns;j$2++)result.set(j$2,i$3,this.get(i$3,j$2));return result}sortRows(compareFunction=compareNumbers){for(let i$3=0;i$3<this.rows;i$3++)this.setRow(i$3,this.getRow(i$3).sort(compareFunction));return this}sortColumns(compareFunction=compareNumbers){for(let i$3=0;i$3<this.columns;i$3++)this.setColumn(i$3,this.getColumn(i$3).sort(compareFunction));return this}subMatrix(startRow,endRow,startColumn,endColumn){checkRange$1(this,startRow,endRow,startColumn,endColumn);let newMatrix=new Matrix$1(endRow-startRow+1,endColumn-startColumn+1);for(let i$3=startRow;i$3<=endRow;i$3++)for(let j$2=startColumn;j$2<=endColumn;j$2++)newMatrix.set(i$3-startRow,j$2-startColumn,this.get(i$3,j$2));return newMatrix}subMatrixRow(indices,startColumn,endColumn){if(startColumn===void 0&&(startColumn=0),endColumn===void 0&&(endColumn=this.columns-1),startColumn>endColumn||startColumn<0||startColumn>=this.columns||endColumn<0||endColumn>=this.columns)throw RangeError(`Argument out of range`);let newMatrix=new Matrix$1(indices.length,endColumn-startColumn+1);for(let i$3=0;i$3<indices.length;i$3++)for(let j$2=startColumn;j$2<=endColumn;j$2++){if(indices[i$3]<0||indices[i$3]>=this.rows)throw RangeError(`Row index out of range: ${indices[i$3]}`);newMatrix.set(i$3,j$2-startColumn,this.get(indices[i$3],j$2))}return newMatrix}subMatrixColumn(indices,startRow,endRow){if(startRow===void 0&&(startRow=0),endRow===void 0&&(endRow=this.rows-1),startRow>endRow||startRow<0||startRow>=this.rows||endRow<0||endRow>=this.rows)throw RangeError(`Argument out of range`);let newMatrix=new Matrix$1(endRow-startRow+1,indices.length);for(let i$3=0;i$3<indices.length;i$3++)for(let j$2=startRow;j$2<=endRow;j$2++){if(indices[i$3]<0||indices[i$3]>=this.columns)throw RangeError(`Column index out of range: ${indices[i$3]}`);newMatrix.set(j$2-startRow,i$3,this.get(j$2,indices[i$3]))}return newMatrix}setSubMatrix(matrix,startRow,startColumn){if(matrix=Matrix$1.checkMatrix(matrix),matrix.isEmpty())return this;let endRow=startRow+matrix.rows-1,endColumn=startColumn+matrix.columns-1;checkRange$1(this,startRow,endRow,startColumn,endColumn);for(let i$3=0;i$3<matrix.rows;i$3++)for(let j$2=0;j$2<matrix.columns;j$2++)this.set(startRow+i$3,startColumn+j$2,matrix.get(i$3,j$2));return this}selection(rowIndices,columnIndices){checkRowIndices(this,rowIndices),checkColumnIndices(this,columnIndices);let newMatrix=new Matrix$1(rowIndices.length,columnIndices.length);for(let i$3=0;i$3<rowIndices.length;i$3++){let rowIndex=rowIndices[i$3];for(let j$2=0;j$2<columnIndices.length;j$2++){let columnIndex=columnIndices[j$2];newMatrix.set(i$3,j$2,this.get(rowIndex,columnIndex))}}return newMatrix}trace(){let min$2=Math.min(this.rows,this.columns),trace=0;for(let i$3=0;i$3<min$2;i$3++)trace+=this.get(i$3,i$3);return trace}clone(){return this.constructor.copy(this,new Matrix$1(this.rows,this.columns))}static copy(from,to){for(let[row,column,value]of from.entries())to.set(row,column,value);return to}sum(by){switch(by){case`row`:return sumByRow(this);case`column`:return sumByColumn(this);case void 0:return sumAll(this);default:throw Error(`invalid option: ${by}`)}}product(by){switch(by){case`row`:return productByRow(this);case`column`:return productByColumn(this);case void 0:return productAll(this);default:throw Error(`invalid option: ${by}`)}}mean(by){let sum=this.sum(by);switch(by){case`row`:for(let i$3=0;i$3<this.rows;i$3++)sum[i$3]/=this.columns;return sum;case`column`:for(let i$3=0;i$3<this.columns;i$3++)sum[i$3]/=this.rows;return sum;case void 0:return sum/this.size;default:throw Error(`invalid option: ${by}`)}}variance(by,options={}){if(typeof by==`object`&&(options=by,by=void 0),typeof options!=`object`)throw TypeError(`options must be an object`);let{unbiased=!0,mean:mean$2=this.mean(by)}=options;if(typeof unbiased!=`boolean`)throw TypeError(`unbiased must be a boolean`);switch(by){case`row`:if(!isAnyArray$1.isAnyArray(mean$2))throw TypeError(`mean must be an array`);return varianceByRow(this,unbiased,mean$2);case`column`:if(!isAnyArray$1.isAnyArray(mean$2))throw TypeError(`mean must be an array`);return varianceByColumn(this,unbiased,mean$2);case void 0:if(typeof mean$2!=`number`)throw TypeError(`mean must be a number`);return varianceAll(this,unbiased,mean$2);default:throw Error(`invalid option: ${by}`)}}standardDeviation(by,options){typeof by==`object`&&(options=by,by=void 0);let variance$1=this.variance(by,options);if(by===void 0)return Math.sqrt(variance$1);for(let i$3=0;i$3<variance$1.length;i$3++)variance$1[i$3]=Math.sqrt(variance$1[i$3]);return variance$1}center(by,options={}){if(typeof by==`object`&&(options=by,by=void 0),typeof options!=`object`)throw TypeError(`options must be an object`);let{center=this.mean(by)}=options;switch(by){case`row`:if(!isAnyArray$1.isAnyArray(center))throw TypeError(`center must be an array`);return centerByRow(this,center),this;case`column`:if(!isAnyArray$1.isAnyArray(center))throw TypeError(`center must be an array`);return centerByColumn(this,center),this;case void 0:if(typeof center!=`number`)throw TypeError(`center must be a number`);return centerAll(this,center),this;default:throw Error(`invalid option: ${by}`)}}scale(by,options={}){if(typeof by==`object`&&(options=by,by=void 0),typeof options!=`object`)throw TypeError(`options must be an object`);let scale=options.scale;switch(by){case`row`:if(scale===void 0)scale=getScaleByRow(this);else if(!isAnyArray$1.isAnyArray(scale))throw TypeError(`scale must be an array`);return scaleByRow(this,scale),this;case`column`:if(scale===void 0)scale=getScaleByColumn(this);else if(!isAnyArray$1.isAnyArray(scale))throw TypeError(`scale must be an array`);return scaleByColumn(this,scale),this;case void 0:if(scale===void 0)scale=getScaleAll(this);else if(typeof scale!=`number`)throw TypeError(`scale must be a number`);return scaleAll(this,scale),this;default:throw Error(`invalid option: ${by}`)}}toString(options){return inspectMatrixWithOptions(this,options)}[Symbol.iterator](){return this.entries()}*entries(){for(let row=0;row<this.rows;row++)for(let col=0;col<this.columns;col++)yield[row,col,this.get(row,col)]}*values(){for(let row=0;row<this.rows;row++)for(let col=0;col<this.columns;col++)yield this.get(row,col)}};AbstractMatrix$1.prototype.klass=`Matrix`,typeof Symbol<`u`&&(AbstractMatrix$1.prototype[Symbol.for(`nodejs.util.inspect.custom`)]=inspectMatrix);function compareNumbers(a$3,b$3){return a$3-b$3}function isArrayOfNumbers(array){return array.every(element=>typeof element==`number`)}AbstractMatrix$1.random=AbstractMatrix$1.rand,AbstractMatrix$1.randomInt=AbstractMatrix$1.randInt,AbstractMatrix$1.diagonal=AbstractMatrix$1.diag,AbstractMatrix$1.prototype.diagonal=AbstractMatrix$1.prototype.diag,AbstractMatrix$1.identity=AbstractMatrix$1.eye,AbstractMatrix$1.prototype.negate=AbstractMatrix$1.prototype.neg,AbstractMatrix$1.prototype.tensorProduct=AbstractMatrix$1.prototype.kroneckerProduct;var Matrix$1=class Matrix$1 extends AbstractMatrix$1{data;#initData(nRows,nColumns){if(this.data=[],Number.isInteger(nColumns)&&nColumns>=0)for(let i$3=0;i$3<nRows;i$3++)this.data.push(new Float64Array(nColumns));else throw TypeError(`nColumns must be a positive integer`);this.rows=nRows,this.columns=nColumns}constructor(nRows,nColumns){if(super(),Matrix$1.isMatrix(nRows))this.#initData(nRows.rows,nRows.columns),Matrix$1.copy(nRows,this);else if(Number.isInteger(nRows)&&nRows>=0)this.#initData(nRows,nColumns);else if(isAnyArray$1.isAnyArray(nRows)){let arrayData=nRows;if(nRows=arrayData.length,nColumns=nRows?arrayData[0].length:0,typeof nColumns!=`number`)throw TypeError(`Data must be a 2D array with at least one element`);this.data=[];for(let i$3=0;i$3<nRows;i$3++){if(arrayData[i$3].length!==nColumns)throw RangeError(`Inconsistent array dimensions`);if(!isArrayOfNumbers(arrayData[i$3]))throw TypeError(`Input data contains non-numeric values`);this.data.push(Float64Array.from(arrayData[i$3]))}this.rows=nRows,this.columns=nColumns}else throw TypeError(`First argument must be a positive number or an array`)}set(rowIndex,columnIndex,value){return this.data[rowIndex][columnIndex]=value,this}get(rowIndex,columnIndex){return this.data[rowIndex][columnIndex]}removeRow(index){return checkRowIndex(this,index),this.data.splice(index,1),--this.rows,this}addRow(index,array){return array===void 0&&(array=index,index=this.rows),checkRowIndex(this,index,!0),array=Float64Array.from(checkRowVector(this,array)),this.data.splice(index,0,array),this.rows+=1,this}removeColumn(index){checkColumnIndex(this,index);for(let i$3=0;i$3<this.rows;i$3++){let newRow=new Float64Array(this.columns-1);for(let j$2=0;j$2<index;j$2++)newRow[j$2]=this.data[i$3][j$2];for(let j$2=index+1;j$2<this.columns;j$2++)newRow[j$2-1]=this.data[i$3][j$2];this.data[i$3]=newRow}return--this.columns,this}addColumn(index,array){array===void 0&&(array=index,index=this.columns),checkColumnIndex(this,index,!0),array=checkColumnVector(this,array);for(let i$3=0;i$3<this.rows;i$3++){let newRow=new Float64Array(this.columns+1),j$2=0;for(;j$2<index;j$2++)newRow[j$2]=this.data[i$3][j$2];for(newRow[j$2++]=array[i$3];j$2<this.columns+1;j$2++)newRow[j$2]=this.data[i$3][j$2-1];this.data[i$3]=newRow}return this.columns+=1,this}};installMathOperations(AbstractMatrix$1,Matrix$1);var SymmetricMatrix$1=class SymmetricMatrix$1 extends AbstractMatrix$1{#matrix;get size(){return this.#matrix.size}get rows(){return this.#matrix.rows}get columns(){return this.#matrix.columns}get diagonalSize(){return this.rows}static isSymmetricMatrix(value){return Matrix$1.isMatrix(value)&&value.klassType===`SymmetricMatrix`}static zeros(diagonalSize){return new this(diagonalSize)}static ones(diagonalSize){return new this(diagonalSize).fill(1)}constructor(diagonalSize){if(super(),Matrix$1.isMatrix(diagonalSize)){if(!diagonalSize.isSymmetric())throw TypeError(`not symmetric data`);this.#matrix=Matrix$1.copy(diagonalSize,new Matrix$1(diagonalSize.rows,diagonalSize.rows))}else if(Number.isInteger(diagonalSize)&&diagonalSize>=0)this.#matrix=new Matrix$1(diagonalSize,diagonalSize);else if(this.#matrix=new Matrix$1(diagonalSize),!this.isSymmetric())throw TypeError(`not symmetric data`)}clone(){let matrix=new SymmetricMatrix$1(this.diagonalSize);for(let[row,col,value]of this.upperRightEntries())matrix.set(row,col,value);return matrix}toMatrix(){return new Matrix$1(this)}get(rowIndex,columnIndex){return this.#matrix.get(rowIndex,columnIndex)}set(rowIndex,columnIndex,value){return this.#matrix.set(rowIndex,columnIndex,value),this.#matrix.set(columnIndex,rowIndex,value),this}removeCross(index){return this.#matrix.removeRow(index),this.#matrix.removeColumn(index),this}addCross(index,array){array===void 0&&(array=index,index=this.diagonalSize);let row=array.slice();return row.splice(index,1),this.#matrix.addRow(index,row),this.#matrix.addColumn(index,array),this}applyMask(mask){if(mask.length!==this.diagonalSize)throw RangeError(`Mask size do not match with matrix size`);let sidesToRemove=[];for(let[index,passthroughs]of mask.entries())passthroughs||sidesToRemove.push(index);sidesToRemove.reverse();for(let sideIndex of sidesToRemove)this.removeCross(sideIndex);return this}toCompact(){let{diagonalSize}=this,compact=Array(diagonalSize*(diagonalSize+1)/2);for(let col=0,row=0,index=0;index<compact.length;index++)compact[index]=this.get(row,col),++col>=diagonalSize&&(col=++row);return compact}static fromCompact(compact){let compactSize=compact.length,diagonalSize=(Math.sqrt(8*compactSize+1)-1)/2;if(!Number.isInteger(diagonalSize))throw TypeError(`This array is not a compact representation of a Symmetric Matrix, ${JSON.stringify(compact)}`);let matrix=new SymmetricMatrix$1(diagonalSize);for(let col=0,row=0,index=0;index<compactSize;index++)matrix.set(col,row,compact[index]),++col>=diagonalSize&&(col=++row);return matrix}*upperRightEntries(){for(let row=0,col=0;row<this.diagonalSize;){let value=this.get(row,col);yield[row,col,value],++col>=this.diagonalSize&&(col=++row)}}*upperRightValues(){for(let row=0,col=0;row<this.diagonalSize;)yield this.get(row,col),++col>=this.diagonalSize&&(col=++row)}};SymmetricMatrix$1.prototype.klassType=`SymmetricMatrix`;var DistanceMatrix$1=class DistanceMatrix$1 extends SymmetricMatrix$1{static isDistanceMatrix(value){return SymmetricMatrix$1.isSymmetricMatrix(value)&&value.klassSubType===`DistanceMatrix`}constructor(sideSize){if(super(sideSize),!this.isDistance())throw TypeError(`Provided arguments do no produce a distance matrix`)}set(rowIndex,columnIndex,value){return rowIndex===columnIndex&&(value=0),super.set(rowIndex,columnIndex,value)}addCross(index,array){return array===void 0&&(array=index,index=this.diagonalSize),array=array.slice(),array[index]=0,super.addCross(index,array)}toSymmetricMatrix(){return new SymmetricMatrix$1(this)}clone(){let matrix=new DistanceMatrix$1(this.diagonalSize);for(let[row,col,value]of this.upperRightEntries())row!==col&&matrix.set(row,col,value);return matrix}toCompact(){let{diagonalSize}=this,compactLength=(diagonalSize-1)*diagonalSize/2,compact=Array(compactLength);for(let col=1,row=0,index=0;index<compact.length;index++)compact[index]=this.get(row,col),++col>=diagonalSize&&(col=++row+1);return compact}static fromCompact(compact){let compactSize=compact.length;if(compactSize===0)return new this(0);let diagonalSize=(Math.sqrt(8*compactSize+1)+1)/2;if(!Number.isInteger(diagonalSize))throw TypeError(`This array is not a compact representation of a DistanceMatrix, ${JSON.stringify(compact)}`);let matrix=new this(diagonalSize);for(let col=1,row=0,index=0;index<compactSize;index++)matrix.set(col,row,compact[index]),++col>=diagonalSize&&(col=++row+1);return matrix}};DistanceMatrix$1.prototype.klassSubType=`DistanceMatrix`;var BaseView=class extends AbstractMatrix$1{constructor(matrix,rows,columns){super(),this.matrix=matrix,this.rows=rows,this.columns=columns}},MatrixColumnView$1=class extends BaseView{constructor(matrix,column){checkColumnIndex(matrix,column),super(matrix,matrix.rows,1),this.column=column}set(rowIndex,columnIndex,value){return this.matrix.set(rowIndex,this.column,value),this}get(rowIndex){return this.matrix.get(rowIndex,this.column)}},MatrixColumnSelectionView$1=class extends BaseView{constructor(matrix,columnIndices){checkColumnIndices(matrix,columnIndices),super(matrix,matrix.rows,columnIndices.length),this.columnIndices=columnIndices}set(rowIndex,columnIndex,value){return this.matrix.set(rowIndex,this.columnIndices[columnIndex],value),this}get(rowIndex,columnIndex){return this.matrix.get(rowIndex,this.columnIndices[columnIndex])}},MatrixFlipColumnView$1=class extends BaseView{constructor(matrix){super(matrix,matrix.rows,matrix.columns)}set(rowIndex,columnIndex,value){return this.matrix.set(rowIndex,this.columns-columnIndex-1,value),this}get(rowIndex,columnIndex){return this.matrix.get(rowIndex,this.columns-columnIndex-1)}},MatrixFlipRowView$1=class extends BaseView{constructor(matrix){super(matrix,matrix.rows,matrix.columns)}set(rowIndex,columnIndex,value){return this.matrix.set(this.rows-rowIndex-1,columnIndex,value),this}get(rowIndex,columnIndex){return this.matrix.get(this.rows-rowIndex-1,columnIndex)}},MatrixRowView$1=class extends BaseView{constructor(matrix,row){checkRowIndex(matrix,row),super(matrix,1,matrix.columns),this.row=row}set(rowIndex,columnIndex,value){return this.matrix.set(this.row,columnIndex,value),this}get(rowIndex,columnIndex){return this.matrix.get(this.row,columnIndex)}},MatrixRowSelectionView$1=class extends BaseView{constructor(matrix,rowIndices){checkRowIndices(matrix,rowIndices),super(matrix,rowIndices.length,matrix.columns),this.rowIndices=rowIndices}set(rowIndex,columnIndex,value){return this.matrix.set(this.rowIndices[rowIndex],columnIndex,value),this}get(rowIndex,columnIndex){return this.matrix.get(this.rowIndices[rowIndex],columnIndex)}},MatrixSelectionView$1=class extends BaseView{constructor(matrix,rowIndices,columnIndices){checkRowIndices(matrix,rowIndices),checkColumnIndices(matrix,columnIndices),super(matrix,rowIndices.length,columnIndices.length),this.rowIndices=rowIndices,this.columnIndices=columnIndices}set(rowIndex,columnIndex,value){return this.matrix.set(this.rowIndices[rowIndex],this.columnIndices[columnIndex],value),this}get(rowIndex,columnIndex){return this.matrix.get(this.rowIndices[rowIndex],this.columnIndices[columnIndex])}},MatrixSubView$1=class extends BaseView{constructor(matrix,startRow,endRow,startColumn,endColumn){checkRange$1(matrix,startRow,endRow,startColumn,endColumn),super(matrix,endRow-startRow+1,endColumn-startColumn+1),this.startRow=startRow,this.startColumn=startColumn}set(rowIndex,columnIndex,value){return this.matrix.set(this.startRow+rowIndex,this.startColumn+columnIndex,value),this}get(rowIndex,columnIndex){return this.matrix.get(this.startRow+rowIndex,this.startColumn+columnIndex)}},MatrixTransposeView$1=class extends BaseView{constructor(matrix){super(matrix,matrix.columns,matrix.rows)}set(rowIndex,columnIndex,value){return this.matrix.set(columnIndex,rowIndex,value),this}get(rowIndex,columnIndex){return this.matrix.get(columnIndex,rowIndex)}},WrapperMatrix1D$1=class extends AbstractMatrix$1{constructor(data,options={}){let{rows=1}=options;if(data.length%rows!==0)throw Error(`the data length is not divisible by the number of rows`);super(),this.rows=rows,this.columns=data.length/rows,this.data=data}set(rowIndex,columnIndex,value){let index=this._calculateIndex(rowIndex,columnIndex);return this.data[index]=value,this}get(rowIndex,columnIndex){let index=this._calculateIndex(rowIndex,columnIndex);return this.data[index]}_calculateIndex(row,column){return row*this.columns+column}},WrapperMatrix2D$1=class extends AbstractMatrix$1{constructor(data){super(),this.data=data,this.rows=data.length,this.columns=data[0].length}set(rowIndex,columnIndex,value){return this.data[rowIndex][columnIndex]=value,this}get(rowIndex,columnIndex){return this.data[rowIndex][columnIndex]}};function wrap$1(array,options){if(isAnyArray$1.isAnyArray(array))return array[0]&&isAnyArray$1.isAnyArray(array[0])?new WrapperMatrix2D$1(array):new WrapperMatrix1D$1(array,options);throw Error(`the argument is not an array`)}var LuDecomposition$1=class{constructor(matrix){matrix=WrapperMatrix2D$1.checkMatrix(matrix);let lu=matrix.clone(),rows=lu.rows,columns=lu.columns,pivotVector=new Float64Array(rows),pivotSign=1,i$3,j$2,k$2,p$3,s$2,t$3,v$2,LUcolj,kmax;for(i$3=0;i$3<rows;i$3++)pivotVector[i$3]=i$3;for(LUcolj=new Float64Array(rows),j$2=0;j$2<columns;j$2++){for(i$3=0;i$3<rows;i$3++)LUcolj[i$3]=lu.get(i$3,j$2);for(i$3=0;i$3<rows;i$3++){for(kmax=Math.min(i$3,j$2),s$2=0,k$2=0;k$2<kmax;k$2++)s$2+=lu.get(i$3,k$2)*LUcolj[k$2];LUcolj[i$3]-=s$2,lu.set(i$3,j$2,LUcolj[i$3])}for(p$3=j$2,i$3=j$2+1;i$3<rows;i$3++)Math.abs(LUcolj[i$3])>Math.abs(LUcolj[p$3])&&(p$3=i$3);if(p$3!==j$2){for(k$2=0;k$2<columns;k$2++)t$3=lu.get(p$3,k$2),lu.set(p$3,k$2,lu.get(j$2,k$2)),lu.set(j$2,k$2,t$3);v$2=pivotVector[p$3],pivotVector[p$3]=pivotVector[j$2],pivotVector[j$2]=v$2,pivotSign=-pivotSign}if(j$2<rows&&lu.get(j$2,j$2)!==0)for(i$3=j$2+1;i$3<rows;i$3++)lu.set(i$3,j$2,lu.get(i$3,j$2)/lu.get(j$2,j$2))}this.LU=lu,this.pivotVector=pivotVector,this.pivotSign=pivotSign}isSingular(){let data=this.LU,col=data.columns;for(let j$2=0;j$2<col;j$2++)if(data.get(j$2,j$2)===0)return!0;return!1}solve(value){value=Matrix$1.checkMatrix(value);let lu=this.LU;if(lu.rows!==value.rows)throw Error(`Invalid matrix dimensions`);if(this.isSingular())throw Error(`LU matrix is singular`);let count=value.columns,X=value.subMatrixRow(this.pivotVector,0,count-1),columns=lu.columns,i$3,j$2,k$2;for(k$2=0;k$2<columns;k$2++)for(i$3=k$2+1;i$3<columns;i$3++)for(j$2=0;j$2<count;j$2++)X.set(i$3,j$2,X.get(i$3,j$2)-X.get(k$2,j$2)*lu.get(i$3,k$2));for(k$2=columns-1;k$2>=0;k$2--){for(j$2=0;j$2<count;j$2++)X.set(k$2,j$2,X.get(k$2,j$2)/lu.get(k$2,k$2));for(i$3=0;i$3<k$2;i$3++)for(j$2=0;j$2<count;j$2++)X.set(i$3,j$2,X.get(i$3,j$2)-X.get(k$2,j$2)*lu.get(i$3,k$2))}return X}get determinant(){let data=this.LU;if(!data.isSquare())throw Error(`Matrix must be square`);let determinant$2=this.pivotSign,col=data.columns;for(let j$2=0;j$2<col;j$2++)determinant$2*=data.get(j$2,j$2);return determinant$2}get lowerTriangularMatrix(){let data=this.LU,rows=data.rows,columns=data.columns,X=new Matrix$1(rows,columns);for(let i$3=0;i$3<rows;i$3++)for(let j$2=0;j$2<columns;j$2++)i$3>j$2?X.set(i$3,j$2,data.get(i$3,j$2)):i$3===j$2?X.set(i$3,j$2,1):X.set(i$3,j$2,0);return X}get upperTriangularMatrix(){let data=this.LU,rows=data.rows,columns=data.columns,X=new Matrix$1(rows,columns);for(let i$3=0;i$3<rows;i$3++)for(let j$2=0;j$2<columns;j$2++)i$3<=j$2?X.set(i$3,j$2,data.get(i$3,j$2)):X.set(i$3,j$2,0);return X}get pivotPermutationVector(){return Array.from(this.pivotVector)}};function hypotenuse$1(a$3,b$3){let r$3=0;return Math.abs(a$3)>Math.abs(b$3)?(r$3=b$3/a$3,Math.abs(a$3)*Math.sqrt(1+r$3*r$3)):b$3===0?0:(r$3=a$3/b$3,Math.abs(b$3)*Math.sqrt(1+r$3*r$3))}var QrDecomposition$1=class{constructor(value){value=WrapperMatrix2D$1.checkMatrix(value);let qr=value.clone(),m$1=value.rows,n$3=value.columns,rdiag=new Float64Array(n$3),i$3,j$2,k$2,s$2;for(k$2=0;k$2<n$3;k$2++){let nrm=0;for(i$3=k$2;i$3<m$1;i$3++)nrm=hypotenuse$1(nrm,qr.get(i$3,k$2));if(nrm!==0){for(qr.get(k$2,k$2)<0&&(nrm=-nrm),i$3=k$2;i$3<m$1;i$3++)qr.set(i$3,k$2,qr.get(i$3,k$2)/nrm);for(qr.set(k$2,k$2,qr.get(k$2,k$2)+1),j$2=k$2+1;j$2<n$3;j$2++){for(s$2=0,i$3=k$2;i$3<m$1;i$3++)s$2+=qr.get(i$3,k$2)*qr.get(i$3,j$2);for(s$2=-s$2/qr.get(k$2,k$2),i$3=k$2;i$3<m$1;i$3++)qr.set(i$3,j$2,qr.get(i$3,j$2)+s$2*qr.get(i$3,k$2))}}rdiag[k$2]=-nrm}this.QR=qr,this.Rdiag=rdiag}solve(value){value=Matrix$1.checkMatrix(value);let qr=this.QR,m$1=qr.rows;if(value.rows!==m$1)throw Error(`Matrix row dimensions must agree`);if(!this.isFullRank())throw Error(`Matrix is rank deficient`);let count=value.columns,X=value.clone(),n$3=qr.columns,i$3,j$2,k$2,s$2;for(k$2=0;k$2<n$3;k$2++)for(j$2=0;j$2<count;j$2++){for(s$2=0,i$3=k$2;i$3<m$1;i$3++)s$2+=qr.get(i$3,k$2)*X.get(i$3,j$2);for(s$2=-s$2/qr.get(k$2,k$2),i$3=k$2;i$3<m$1;i$3++)X.set(i$3,j$2,X.get(i$3,j$2)+s$2*qr.get(i$3,k$2))}for(k$2=n$3-1;k$2>=0;k$2--){for(j$2=0;j$2<count;j$2++)X.set(k$2,j$2,X.get(k$2,j$2)/this.Rdiag[k$2]);for(i$3=0;i$3<k$2;i$3++)for(j$2=0;j$2<count;j$2++)X.set(i$3,j$2,X.get(i$3,j$2)-X.get(k$2,j$2)*qr.get(i$3,k$2))}return X.subMatrix(0,n$3-1,0,count-1)}isFullRank(){let columns=this.QR.columns;for(let i$3=0;i$3<columns;i$3++)if(this.Rdiag[i$3]===0)return!1;return!0}get upperTriangularMatrix(){let qr=this.QR,n$3=qr.columns,X=new Matrix$1(n$3,n$3),i$3,j$2;for(i$3=0;i$3<n$3;i$3++)for(j$2=0;j$2<n$3;j$2++)i$3<j$2?X.set(i$3,j$2,qr.get(i$3,j$2)):i$3===j$2?X.set(i$3,j$2,this.Rdiag[i$3]):X.set(i$3,j$2,0);return X}get orthogonalMatrix(){let qr=this.QR,rows=qr.rows,columns=qr.columns,X=new Matrix$1(rows,columns),i$3,j$2,k$2,s$2;for(k$2=columns-1;k$2>=0;k$2--){for(i$3=0;i$3<rows;i$3++)X.set(i$3,k$2,0);for(X.set(k$2,k$2,1),j$2=k$2;j$2<columns;j$2++)if(qr.get(k$2,k$2)!==0){for(s$2=0,i$3=k$2;i$3<rows;i$3++)s$2+=qr.get(i$3,k$2)*X.get(i$3,j$2);for(s$2=-s$2/qr.get(k$2,k$2),i$3=k$2;i$3<rows;i$3++)X.set(i$3,j$2,X.get(i$3,j$2)+s$2*qr.get(i$3,k$2))}}return X}},SingularValueDecomposition$1=class{constructor(value,options={}){if(value=WrapperMatrix2D$1.checkMatrix(value),value.isEmpty())throw Error(`Matrix must be non-empty`);let m$1=value.rows,n$3=value.columns,{computeLeftSingularVectors=!0,computeRightSingularVectors=!0,autoTranspose=!1}=options,wantu=!!computeLeftSingularVectors,wantv=!!computeRightSingularVectors,swapped=!1,a$3;if(m$1<n$3)if(!autoTranspose)a$3=value.clone(),console.warn(`Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose`);else{a$3=value.transpose(),m$1=a$3.rows,n$3=a$3.columns,swapped=!0;let aux=wantu;wantu=wantv,wantv=aux}else a$3=value.clone();let nu=Math.min(m$1,n$3),ni=Math.min(m$1+1,n$3),s$2=new Float64Array(ni),U=new Matrix$1(m$1,nu),V=new Matrix$1(n$3,n$3),e$3=new Float64Array(n$3),work=new Float64Array(m$1),si=new Float64Array(ni);for(let i$3=0;i$3<ni;i$3++)si[i$3]=i$3;let nct=Math.min(m$1-1,n$3),nrt=Math.max(0,Math.min(n$3-2,m$1)),mrc=Math.max(nct,nrt);for(let k$2=0;k$2<mrc;k$2++){if(k$2<nct){s$2[k$2]=0;for(let i$3=k$2;i$3<m$1;i$3++)s$2[k$2]=hypotenuse$1(s$2[k$2],a$3.get(i$3,k$2));if(s$2[k$2]!==0){a$3.get(k$2,k$2)<0&&(s$2[k$2]=-s$2[k$2]);for(let i$3=k$2;i$3<m$1;i$3++)a$3.set(i$3,k$2,a$3.get(i$3,k$2)/s$2[k$2]);a$3.set(k$2,k$2,a$3.get(k$2,k$2)+1)}s$2[k$2]=-s$2[k$2]}for(let j$2=k$2+1;j$2<n$3;j$2++){if(k$2<nct&&s$2[k$2]!==0){let t$3=0;for(let i$3=k$2;i$3<m$1;i$3++)t$3+=a$3.get(i$3,k$2)*a$3.get(i$3,j$2);t$3=-t$3/a$3.get(k$2,k$2);for(let i$3=k$2;i$3<m$1;i$3++)a$3.set(i$3,j$2,a$3.get(i$3,j$2)+t$3*a$3.get(i$3,k$2))}e$3[j$2]=a$3.get(k$2,j$2)}if(wantu&&k$2<nct)for(let i$3=k$2;i$3<m$1;i$3++)U.set(i$3,k$2,a$3.get(i$3,k$2));if(k$2<nrt){e$3[k$2]=0;for(let i$3=k$2+1;i$3<n$3;i$3++)e$3[k$2]=hypotenuse$1(e$3[k$2],e$3[i$3]);if(e$3[k$2]!==0){e$3[k$2+1]<0&&(e$3[k$2]=0-e$3[k$2]);for(let i$3=k$2+1;i$3<n$3;i$3++)e$3[i$3]/=e$3[k$2];e$3[k$2+1]+=1}if(e$3[k$2]=-e$3[k$2],k$2+1<m$1&&e$3[k$2]!==0){for(let i$3=k$2+1;i$3<m$1;i$3++)work[i$3]=0;for(let i$3=k$2+1;i$3<m$1;i$3++)for(let j$2=k$2+1;j$2<n$3;j$2++)work[i$3]+=e$3[j$2]*a$3.get(i$3,j$2);for(let j$2=k$2+1;j$2<n$3;j$2++){let t$3=-e$3[j$2]/e$3[k$2+1];for(let i$3=k$2+1;i$3<m$1;i$3++)a$3.set(i$3,j$2,a$3.get(i$3,j$2)+t$3*work[i$3])}}if(wantv)for(let i$3=k$2+1;i$3<n$3;i$3++)V.set(i$3,k$2,e$3[i$3])}}let p$3=Math.min(n$3,m$1+1);if(nct<n$3&&(s$2[nct]=a$3.get(nct,nct)),m$1<p$3&&(s$2[p$3-1]=0),nrt+1<p$3&&(e$3[nrt]=a$3.get(nrt,p$3-1)),e$3[p$3-1]=0,wantu){for(let j$2=nct;j$2<nu;j$2++){for(let i$3=0;i$3<m$1;i$3++)U.set(i$3,j$2,0);U.set(j$2,j$2,1)}for(let k$2=nct-1;k$2>=0;k$2--)if(s$2[k$2]!==0){for(let j$2=k$2+1;j$2<nu;j$2++){let t$3=0;for(let i$3=k$2;i$3<m$1;i$3++)t$3+=U.get(i$3,k$2)*U.get(i$3,j$2);t$3=-t$3/U.get(k$2,k$2);for(let i$3=k$2;i$3<m$1;i$3++)U.set(i$3,j$2,U.get(i$3,j$2)+t$3*U.get(i$3,k$2))}for(let i$3=k$2;i$3<m$1;i$3++)U.set(i$3,k$2,-U.get(i$3,k$2));U.set(k$2,k$2,1+U.get(k$2,k$2));for(let i$3=0;i$3<k$2-1;i$3++)U.set(i$3,k$2,0)}else{for(let i$3=0;i$3<m$1;i$3++)U.set(i$3,k$2,0);U.set(k$2,k$2,1)}}if(wantv)for(let k$2=n$3-1;k$2>=0;k$2--){if(k$2<nrt&&e$3[k$2]!==0)for(let j$2=k$2+1;j$2<n$3;j$2++){let t$3=0;for(let i$3=k$2+1;i$3<n$3;i$3++)t$3+=V.get(i$3,k$2)*V.get(i$3,j$2);t$3=-t$3/V.get(k$2+1,k$2);for(let i$3=k$2+1;i$3<n$3;i$3++)V.set(i$3,j$2,V.get(i$3,j$2)+t$3*V.get(i$3,k$2))}for(let i$3=0;i$3<n$3;i$3++)V.set(i$3,k$2,0);V.set(k$2,k$2,1)}let pp=p$3-1,eps=2**-52;for(;p$3>0;){let k$2,kase;for(k$2=p$3-2;k$2>=-1&&k$2!==-1;k$2--){let alpha=Number.MIN_VALUE+eps*Math.abs(s$2[k$2]+Math.abs(s$2[k$2+1]));if(Math.abs(e$3[k$2])<=alpha||Number.isNaN(e$3[k$2])){e$3[k$2]=0;break}}if(k$2===p$3-2)kase=4;else{let ks;for(ks=p$3-1;ks>=k$2&&ks!==k$2;ks--){let t$3=(ks===p$3?0:Math.abs(e$3[ks]))+(ks===k$2+1?0:Math.abs(e$3[ks-1]));if(Math.abs(s$2[ks])<=eps*t$3){s$2[ks]=0;break}}ks===k$2?kase=3:ks===p$3-1?kase=1:(kase=2,k$2=ks)}switch(k$2++,kase){case 1:{let f$1=e$3[p$3-2];e$3[p$3-2]=0;for(let j$2=p$3-2;j$2>=k$2;j$2--){let t$3=hypotenuse$1(s$2[j$2],f$1),cs=s$2[j$2]/t$3,sn=f$1/t$3;if(s$2[j$2]=t$3,j$2!==k$2&&(f$1=-sn*e$3[j$2-1],e$3[j$2-1]=cs*e$3[j$2-1]),wantv)for(let i$3=0;i$3<n$3;i$3++)t$3=cs*V.get(i$3,j$2)+sn*V.get(i$3,p$3-1),V.set(i$3,p$3-1,-sn*V.get(i$3,j$2)+cs*V.get(i$3,p$3-1)),V.set(i$3,j$2,t$3)}break}case 2:{let f$1=e$3[k$2-1];e$3[k$2-1]=0;for(let j$2=k$2;j$2<p$3;j$2++){let t$3=hypotenuse$1(s$2[j$2],f$1),cs=s$2[j$2]/t$3,sn=f$1/t$3;if(s$2[j$2]=t$3,f$1=-sn*e$3[j$2],e$3[j$2]=cs*e$3[j$2],wantu)for(let i$3=0;i$3<m$1;i$3++)t$3=cs*U.get(i$3,j$2)+sn*U.get(i$3,k$2-1),U.set(i$3,k$2-1,-sn*U.get(i$3,j$2)+cs*U.get(i$3,k$2-1)),U.set(i$3,j$2,t$3)}break}case 3:{let scale=Math.max(Math.abs(s$2[p$3-1]),Math.abs(s$2[p$3-2]),Math.abs(e$3[p$3-2]),Math.abs(s$2[k$2]),Math.abs(e$3[k$2])),sp=s$2[p$3-1]/scale,spm1=s$2[p$3-2]/scale,epm1=e$3[p$3-2]/scale,sk=s$2[k$2]/scale,ek=e$3[k$2]/scale,b$3=((spm1+sp)*(spm1-sp)+epm1*epm1)/2,c$2=sp*epm1*(sp*epm1),shift=0;(b$3!==0||c$2!==0)&&(shift=b$3<0?0-Math.sqrt(b$3*b$3+c$2):Math.sqrt(b$3*b$3+c$2),shift=c$2/(b$3+shift));let f$1=(sk+sp)*(sk-sp)+shift,g$1=sk*ek;for(let j$2=k$2;j$2<p$3-1;j$2++){let t$3=hypotenuse$1(f$1,g$1);t$3===0&&(t$3=Number.MIN_VALUE);let cs=f$1/t$3,sn=g$1/t$3;if(j$2!==k$2&&(e$3[j$2-1]=t$3),f$1=cs*s$2[j$2]+sn*e$3[j$2],e$3[j$2]=cs*e$3[j$2]-sn*s$2[j$2],g$1=sn*s$2[j$2+1],s$2[j$2+1]=cs*s$2[j$2+1],wantv)for(let i$3=0;i$3<n$3;i$3++)t$3=cs*V.get(i$3,j$2)+sn*V.get(i$3,j$2+1),V.set(i$3,j$2+1,-sn*V.get(i$3,j$2)+cs*V.get(i$3,j$2+1)),V.set(i$3,j$2,t$3);if(t$3=hypotenuse$1(f$1,g$1),t$3===0&&(t$3=Number.MIN_VALUE),cs=f$1/t$3,sn=g$1/t$3,s$2[j$2]=t$3,f$1=cs*e$3[j$2]+sn*s$2[j$2+1],s$2[j$2+1]=-sn*e$3[j$2]+cs*s$2[j$2+1],g$1=sn*e$3[j$2+1],e$3[j$2+1]=cs*e$3[j$2+1],wantu&&j$2<m$1-1)for(let i$3=0;i$3<m$1;i$3++)t$3=cs*U.get(i$3,j$2)+sn*U.get(i$3,j$2+1),U.set(i$3,j$2+1,-sn*U.get(i$3,j$2)+cs*U.get(i$3,j$2+1)),U.set(i$3,j$2,t$3)}e$3[p$3-2]=f$1;break}case 4:if(s$2[k$2]<=0&&(s$2[k$2]=s$2[k$2]<0?-s$2[k$2]:0,wantv))for(let i$3=0;i$3<=pp;i$3++)V.set(i$3,k$2,-V.get(i$3,k$2));for(;k$2<pp&&!(s$2[k$2]>=s$2[k$2+1]);){let t$3=s$2[k$2];if(s$2[k$2]=s$2[k$2+1],s$2[k$2+1]=t$3,wantv&&k$2<n$3-1)for(let i$3=0;i$3<n$3;i$3++)t$3=V.get(i$3,k$2+1),V.set(i$3,k$2+1,V.get(i$3,k$2)),V.set(i$3,k$2,t$3);if(wantu&&k$2<m$1-1)for(let i$3=0;i$3<m$1;i$3++)t$3=U.get(i$3,k$2+1),U.set(i$3,k$2+1,U.get(i$3,k$2)),U.set(i$3,k$2,t$3);k$2++}p$3--;break}}if(swapped){let tmp=V;V=U,U=tmp}this.m=m$1,this.n=n$3,this.s=s$2,this.U=U,this.V=V}solve(value){let Y=value,e$3=this.threshold,scols=this.s.length,Ls=Matrix$1.zeros(scols,scols);for(let i$3=0;i$3<scols;i$3++)Math.abs(this.s[i$3])<=e$3?Ls.set(i$3,i$3,0):Ls.set(i$3,i$3,1/this.s[i$3]);let U=this.U,V=this.rightSingularVectors,VL=V.mmul(Ls),vrows=V.rows,urows=U.rows,VLU=Matrix$1.zeros(vrows,urows);for(let i$3=0;i$3<vrows;i$3++)for(let j$2=0;j$2<urows;j$2++){let sum=0;for(let k$2=0;k$2<scols;k$2++)sum+=VL.get(i$3,k$2)*U.get(j$2,k$2);VLU.set(i$3,j$2,sum)}return VLU.mmul(Y)}solveForDiagonal(value){return this.solve(Matrix$1.diag(value))}inverse(){let V=this.V,e$3=this.threshold,vrows=V.rows,vcols=V.columns,X=new Matrix$1(vrows,this.s.length);for(let i$3=0;i$3<vrows;i$3++)for(let j$2=0;j$2<vcols;j$2++)Math.abs(this.s[j$2])>e$3&&X.set(i$3,j$2,V.get(i$3,j$2)/this.s[j$2]);let U=this.U,urows=U.rows,ucols=U.columns,Y=new Matrix$1(vrows,urows);for(let i$3=0;i$3<vrows;i$3++)for(let j$2=0;j$2<urows;j$2++){let sum=0;for(let k$2=0;k$2<ucols;k$2++)sum+=X.get(i$3,k$2)*U.get(j$2,k$2);Y.set(i$3,j$2,sum)}return Y}get condition(){return this.s[0]/this.s[Math.min(this.m,this.n)-1]}get norm2(){return this.s[0]}get rank(){let tol=Math.max(this.m,this.n)*this.s[0]*2**-52,r$3=0,s$2=this.s;for(let i$3=0,ii=s$2.length;i$3<ii;i$3++)s$2[i$3]>tol&&r$3++;return r$3}get diagonal(){return Array.from(this.s)}get threshold(){return 2**-52/2*Math.max(this.m,this.n)*this.s[0]}get leftSingularVectors(){return this.U}get rightSingularVectors(){return this.V}get diagonalMatrix(){return Matrix$1.diag(this.s)}};function inverse$1(matrix,useSVD=!1){return matrix=WrapperMatrix2D$1.checkMatrix(matrix),useSVD?new SingularValueDecomposition$1(matrix).inverse():solve$1(matrix,Matrix$1.eye(matrix.rows))}function solve$1(leftHandSide,rightHandSide,useSVD=!1){return leftHandSide=WrapperMatrix2D$1.checkMatrix(leftHandSide),rightHandSide=WrapperMatrix2D$1.checkMatrix(rightHandSide),useSVD?new SingularValueDecomposition$1(leftHandSide).solve(rightHandSide):leftHandSide.isSquare()?new LuDecomposition$1(leftHandSide).solve(rightHandSide):new QrDecomposition$1(leftHandSide).solve(rightHandSide)}function determinant$1(matrix){if(matrix=Matrix$1.checkMatrix(matrix),matrix.isSquare()){if(matrix.columns===0)return 1;let a$3,b$3,c$2,d$2;if(matrix.columns===2)return a$3=matrix.get(0,0),b$3=matrix.get(0,1),c$2=matrix.get(1,0),d$2=matrix.get(1,1),a$3*d$2-b$3*c$2;if(matrix.columns===3){let subMatrix0,subMatrix1,subMatrix2;return subMatrix0=new MatrixSelectionView$1(matrix,[1,2],[1,2]),subMatrix1=new MatrixSelectionView$1(matrix,[1,2],[0,2]),subMatrix2=new MatrixSelectionView$1(matrix,[1,2],[0,1]),a$3=matrix.get(0,0),b$3=matrix.get(0,1),c$2=matrix.get(0,2),a$3*determinant$1(subMatrix0)-b$3*determinant$1(subMatrix1)+c$2*determinant$1(subMatrix2)}else return new LuDecomposition$1(matrix).determinant}else throw Error(`determinant can only be calculated for a square matrix`)}function xrange(n$3,exception){let range=[];for(let i$3=0;i$3<n$3;i$3++)i$3!==exception&&range.push(i$3);return range}function dependenciesOneRow(error,matrix,index,thresholdValue=1e-9,thresholdError=1e-9){if(error>thresholdError)return Array(matrix.rows+1).fill(0);{let returnArray=matrix.addRow(index,[0]);for(let i$3=0;i$3<returnArray.rows;i$3++)Math.abs(returnArray.get(i$3,0))<thresholdValue&&returnArray.set(i$3,0,0);return returnArray.to1DArray()}}function linearDependencies$1(matrix,options={}){let{thresholdValue=1e-9,thresholdError=1e-9}=options;matrix=Matrix$1.checkMatrix(matrix);let n$3=matrix.rows,results=new Matrix$1(n$3,n$3);for(let i$3=0;i$3<n$3;i$3++){let b$3=Matrix$1.columnVector(matrix.getRow(i$3)),Abis=matrix.subMatrixRow(xrange(n$3,i$3)).transpose(),x$2=new SingularValueDecomposition$1(Abis).solve(b$3),error=Matrix$1.sub(b$3,Abis.mmul(x$2)).abs().max();results.setRow(i$3,dependenciesOneRow(error,x$2,i$3,thresholdValue,thresholdError))}return results}function pseudoInverse$1(matrix,threshold$1=2**-52){if(matrix=Matrix$1.checkMatrix(matrix),matrix.isEmpty())return matrix.transpose();let svdSolution=new SingularValueDecomposition$1(matrix,{autoTranspose:!0}),U=svdSolution.leftSingularVectors,V=svdSolution.rightSingularVectors,s$2=svdSolution.diagonal;for(let i$3=0;i$3<s$2.length;i$3++)Math.abs(s$2[i$3])>threshold$1?s$2[i$3]=1/s$2[i$3]:s$2[i$3]=0;return V.mmul(Matrix$1.diag(s$2).mmul(U.transpose()))}function covariance$1(xMatrix,yMatrix=xMatrix,options={}){xMatrix=new Matrix$1(xMatrix);let yIsSame=!1;if(typeof yMatrix==`object`&&!Matrix$1.isMatrix(yMatrix)&&!isAnyArray$1.isAnyArray(yMatrix)?(options=yMatrix,yMatrix=xMatrix,yIsSame=!0):yMatrix=new Matrix$1(yMatrix),xMatrix.rows!==yMatrix.rows)throw TypeError(`Both matrices must have the same number of rows`);let{center=!0}=options;center&&(xMatrix=xMatrix.center(`column`),yIsSame||(yMatrix=yMatrix.center(`column`)));let cov=xMatrix.transpose().mmul(yMatrix);for(let i$3=0;i$3<cov.rows;i$3++)for(let j$2=0;j$2<cov.columns;j$2++)cov.set(i$3,j$2,cov.get(i$3,j$2)*(1/(xMatrix.rows-1)));return cov}function correlation$1(xMatrix,yMatrix=xMatrix,options={}){xMatrix=new Matrix$1(xMatrix);let yIsSame=!1;if(typeof yMatrix==`object`&&!Matrix$1.isMatrix(yMatrix)&&!isAnyArray$1.isAnyArray(yMatrix)?(options=yMatrix,yMatrix=xMatrix,yIsSame=!0):yMatrix=new Matrix$1(yMatrix),xMatrix.rows!==yMatrix.rows)throw TypeError(`Both matrices must have the same number of rows`);let{center=!0,scale=!0}=options;center&&(xMatrix.center(`column`),yIsSame||yMatrix.center(`column`)),scale&&(xMatrix.scale(`column`),yIsSame||yMatrix.scale(`column`));let sdx=xMatrix.standardDeviation(`column`,{unbiased:!0}),sdy=yIsSame?sdx:yMatrix.standardDeviation(`column`,{unbiased:!0}),corr=xMatrix.transpose().mmul(yMatrix);for(let i$3=0;i$3<corr.rows;i$3++)for(let j$2=0;j$2<corr.columns;j$2++)corr.set(i$3,j$2,corr.get(i$3,j$2)*(1/(sdx[i$3]*sdy[j$2]))*(1/(xMatrix.rows-1)));return corr}var EigenvalueDecomposition$1=class{constructor(matrix,options={}){let{assumeSymmetric=!1}=options;if(matrix=WrapperMatrix2D$1.checkMatrix(matrix),!matrix.isSquare())throw Error(`Matrix is not a square matrix`);if(matrix.isEmpty())throw Error(`Matrix must be non-empty`);let n$3=matrix.columns,V=new Matrix$1(n$3,n$3),d$2=new Float64Array(n$3),e$3=new Float64Array(n$3),value=matrix,i$3,j$2,isSymmetric=!1;if(isSymmetric=assumeSymmetric?!0:matrix.isSymmetric(),isSymmetric){for(i$3=0;i$3<n$3;i$3++)for(j$2=0;j$2<n$3;j$2++)V.set(i$3,j$2,value.get(i$3,j$2));tred2(n$3,e$3,d$2,V),tql2(n$3,e$3,d$2,V)}else{let H$1=new Matrix$1(n$3,n$3),ort=new Float64Array(n$3);for(j$2=0;j$2<n$3;j$2++)for(i$3=0;i$3<n$3;i$3++)H$1.set(i$3,j$2,value.get(i$3,j$2));orthes(n$3,H$1,ort,V),hqr2(n$3,e$3,d$2,V,H$1)}this.n=n$3,this.e=e$3,this.d=d$2,this.V=V}get realEigenvalues(){return Array.from(this.d)}get imaginaryEigenvalues(){return Array.from(this.e)}get eigenvectorMatrix(){return this.V}get diagonalMatrix(){let n$3=this.n,e$3=this.e,d$2=this.d,X=new Matrix$1(n$3,n$3),i$3,j$2;for(i$3=0;i$3<n$3;i$3++){for(j$2=0;j$2<n$3;j$2++)X.set(i$3,j$2,0);X.set(i$3,i$3,d$2[i$3]),e$3[i$3]>0?X.set(i$3,i$3+1,e$3[i$3]):e$3[i$3]<0&&X.set(i$3,i$3-1,e$3[i$3])}return X}};function tred2(n$3,e$3,d$2,V){let f$1,g$1,h$3,i$3,j$2,k$2,hh,scale;for(j$2=0;j$2<n$3;j$2++)d$2[j$2]=V.get(n$3-1,j$2);for(i$3=n$3-1;i$3>0;i$3--){for(scale=0,h$3=0,k$2=0;k$2<i$3;k$2++)scale+=Math.abs(d$2[k$2]);if(scale===0)for(e$3[i$3]=d$2[i$3-1],j$2=0;j$2<i$3;j$2++)d$2[j$2]=V.get(i$3-1,j$2),V.set(i$3,j$2,0),V.set(j$2,i$3,0);else{for(k$2=0;k$2<i$3;k$2++)d$2[k$2]/=scale,h$3+=d$2[k$2]*d$2[k$2];for(f$1=d$2[i$3-1],g$1=Math.sqrt(h$3),f$1>0&&(g$1=-g$1),e$3[i$3]=scale*g$1,h$3-=f$1*g$1,d$2[i$3-1]=f$1-g$1,j$2=0;j$2<i$3;j$2++)e$3[j$2]=0;for(j$2=0;j$2<i$3;j$2++){for(f$1=d$2[j$2],V.set(j$2,i$3,f$1),g$1=e$3[j$2]+V.get(j$2,j$2)*f$1,k$2=j$2+1;k$2<=i$3-1;k$2++)g$1+=V.get(k$2,j$2)*d$2[k$2],e$3[k$2]+=V.get(k$2,j$2)*f$1;e$3[j$2]=g$1}for(f$1=0,j$2=0;j$2<i$3;j$2++)e$3[j$2]/=h$3,f$1+=e$3[j$2]*d$2[j$2];for(hh=f$1/(h$3+h$3),j$2=0;j$2<i$3;j$2++)e$3[j$2]-=hh*d$2[j$2];for(j$2=0;j$2<i$3;j$2++){for(f$1=d$2[j$2],g$1=e$3[j$2],k$2=j$2;k$2<=i$3-1;k$2++)V.set(k$2,j$2,V.get(k$2,j$2)-(f$1*e$3[k$2]+g$1*d$2[k$2]));d$2[j$2]=V.get(i$3-1,j$2),V.set(i$3,j$2,0)}}d$2[i$3]=h$3}for(i$3=0;i$3<n$3-1;i$3++){if(V.set(n$3-1,i$3,V.get(i$3,i$3)),V.set(i$3,i$3,1),h$3=d$2[i$3+1],h$3!==0){for(k$2=0;k$2<=i$3;k$2++)d$2[k$2]=V.get(k$2,i$3+1)/h$3;for(j$2=0;j$2<=i$3;j$2++){for(g$1=0,k$2=0;k$2<=i$3;k$2++)g$1+=V.get(k$2,i$3+1)*V.get(k$2,j$2);for(k$2=0;k$2<=i$3;k$2++)V.set(k$2,j$2,V.get(k$2,j$2)-g$1*d$2[k$2])}}for(k$2=0;k$2<=i$3;k$2++)V.set(k$2,i$3+1,0)}for(j$2=0;j$2<n$3;j$2++)d$2[j$2]=V.get(n$3-1,j$2),V.set(n$3-1,j$2,0);V.set(n$3-1,n$3-1,1),e$3[0]=0}function tql2(n$3,e$3,d$2,V){let g$1,h$3,i$3,j$2,k$2,l$2,m$1,p$3,r$3,dl1,c$2,c2,c3,el1,s$2,s2;for(i$3=1;i$3<n$3;i$3++)e$3[i$3-1]=e$3[i$3];e$3[n$3-1]=0;let f$1=0,tst1=0,eps=2**-52;for(l$2=0;l$2<n$3;l$2++){for(tst1=Math.max(tst1,Math.abs(d$2[l$2])+Math.abs(e$3[l$2])),m$1=l$2;m$1<n$3&&!(Math.abs(e$3[m$1])<=eps*tst1);)m$1++;if(m$1>l$2)do{for(g$1=d$2[l$2],p$3=(d$2[l$2+1]-g$1)/(2*e$3[l$2]),r$3=hypotenuse$1(p$3,1),p$3<0&&(r$3=-r$3),d$2[l$2]=e$3[l$2]/(p$3+r$3),d$2[l$2+1]=e$3[l$2]*(p$3+r$3),dl1=d$2[l$2+1],h$3=g$1-d$2[l$2],i$3=l$2+2;i$3<n$3;i$3++)d$2[i$3]-=h$3;for(f$1+=h$3,p$3=d$2[m$1],c$2=1,c2=c$2,c3=c$2,el1=e$3[l$2+1],s$2=0,s2=0,i$3=m$1-1;i$3>=l$2;i$3--)for(c3=c2,c2=c$2,s2=s$2,g$1=c$2*e$3[i$3],h$3=c$2*p$3,r$3=hypotenuse$1(p$3,e$3[i$3]),e$3[i$3+1]=s$2*r$3,s$2=e$3[i$3]/r$3,c$2=p$3/r$3,p$3=c$2*d$2[i$3]-s$2*g$1,d$2[i$3+1]=h$3+s$2*(c$2*g$1+s$2*d$2[i$3]),k$2=0;k$2<n$3;k$2++)h$3=V.get(k$2,i$3+1),V.set(k$2,i$3+1,s$2*V.get(k$2,i$3)+c$2*h$3),V.set(k$2,i$3,c$2*V.get(k$2,i$3)-s$2*h$3);p$3=-s$2*s2*c3*el1*e$3[l$2]/dl1,e$3[l$2]=s$2*p$3,d$2[l$2]=c$2*p$3}while(Math.abs(e$3[l$2])>eps*tst1);d$2[l$2]=d$2[l$2]+f$1,e$3[l$2]=0}for(i$3=0;i$3<n$3-1;i$3++){for(k$2=i$3,p$3=d$2[i$3],j$2=i$3+1;j$2<n$3;j$2++)d$2[j$2]<p$3&&(k$2=j$2,p$3=d$2[j$2]);if(k$2!==i$3)for(d$2[k$2]=d$2[i$3],d$2[i$3]=p$3,j$2=0;j$2<n$3;j$2++)p$3=V.get(j$2,i$3),V.set(j$2,i$3,V.get(j$2,k$2)),V.set(j$2,k$2,p$3)}}function orthes(n$3,H$1,ort,V){let low=0,high=n$3-1,f$1,g$1,h$3,i$3,j$2,m$1,scale;for(m$1=1;m$1<=high-1;m$1++){for(scale=0,i$3=m$1;i$3<=high;i$3++)scale+=Math.abs(H$1.get(i$3,m$1-1));if(scale!==0){for(h$3=0,i$3=high;i$3>=m$1;i$3--)ort[i$3]=H$1.get(i$3,m$1-1)/scale,h$3+=ort[i$3]*ort[i$3];for(g$1=Math.sqrt(h$3),ort[m$1]>0&&(g$1=-g$1),h$3-=ort[m$1]*g$1,ort[m$1]=ort[m$1]-g$1,j$2=m$1;j$2<n$3;j$2++){for(f$1=0,i$3=high;i$3>=m$1;i$3--)f$1+=ort[i$3]*H$1.get(i$3,j$2);for(f$1/=h$3,i$3=m$1;i$3<=high;i$3++)H$1.set(i$3,j$2,H$1.get(i$3,j$2)-f$1*ort[i$3])}for(i$3=0;i$3<=high;i$3++){for(f$1=0,j$2=high;j$2>=m$1;j$2--)f$1+=ort[j$2]*H$1.get(i$3,j$2);for(f$1/=h$3,j$2=m$1;j$2<=high;j$2++)H$1.set(i$3,j$2,H$1.get(i$3,j$2)-f$1*ort[j$2])}ort[m$1]=scale*ort[m$1],H$1.set(m$1,m$1-1,scale*g$1)}}for(i$3=0;i$3<n$3;i$3++)for(j$2=0;j$2<n$3;j$2++)V.set(i$3,j$2,i$3===j$2?1:0);for(m$1=high-1;m$1>=1;m$1--)if(H$1.get(m$1,m$1-1)!==0){for(i$3=m$1+1;i$3<=high;i$3++)ort[i$3]=H$1.get(i$3,m$1-1);for(j$2=m$1;j$2<=high;j$2++){for(g$1=0,i$3=m$1;i$3<=high;i$3++)g$1+=ort[i$3]*V.get(i$3,j$2);for(g$1=g$1/ort[m$1]/H$1.get(m$1,m$1-1),i$3=m$1;i$3<=high;i$3++)V.set(i$3,j$2,V.get(i$3,j$2)+g$1*ort[i$3])}}}function hqr2(nn,e$3,d$2,V,H$1){let n$3=nn-1,low=0,high=nn-1,eps=2**-52,exshift=0,norm=0,p$3=0,q=0,r$3=0,s$2=0,z=0,iter=0,i$3,j$2,k$2,l$2,m$1,t$3,w$3,x$2,y$2,ra,sa,vr,vi,notlast,cdivres;for(i$3=0;i$3<nn;i$3++)for((i$3<0||i$3>high)&&(d$2[i$3]=H$1.get(i$3,i$3),e$3[i$3]=0),j$2=Math.max(i$3-1,0);j$2<nn;j$2++)norm+=Math.abs(H$1.get(i$3,j$2));for(;n$3>=0;){for(l$2=n$3;l$2>0&&(s$2=Math.abs(H$1.get(l$2-1,l$2-1))+Math.abs(H$1.get(l$2,l$2)),s$2===0&&(s$2=norm),!(Math.abs(H$1.get(l$2,l$2-1))<eps*s$2));)l$2--;if(l$2===n$3)H$1.set(n$3,n$3,H$1.get(n$3,n$3)+exshift),d$2[n$3]=H$1.get(n$3,n$3),e$3[n$3]=0,n$3--,iter=0;else if(l$2===n$3-1){if(w$3=H$1.get(n$3,n$3-1)*H$1.get(n$3-1,n$3),p$3=(H$1.get(n$3-1,n$3-1)-H$1.get(n$3,n$3))/2,q=p$3*p$3+w$3,z=Math.sqrt(Math.abs(q)),H$1.set(n$3,n$3,H$1.get(n$3,n$3)+exshift),H$1.set(n$3-1,n$3-1,H$1.get(n$3-1,n$3-1)+exshift),x$2=H$1.get(n$3,n$3),q>=0){for(z=p$3>=0?p$3+z:p$3-z,d$2[n$3-1]=x$2+z,d$2[n$3]=d$2[n$3-1],z!==0&&(d$2[n$3]=x$2-w$3/z),e$3[n$3-1]=0,e$3[n$3]=0,x$2=H$1.get(n$3,n$3-1),s$2=Math.abs(x$2)+Math.abs(z),p$3=x$2/s$2,q=z/s$2,r$3=Math.sqrt(p$3*p$3+q*q),p$3/=r$3,q/=r$3,j$2=n$3-1;j$2<nn;j$2++)z=H$1.get(n$3-1,j$2),H$1.set(n$3-1,j$2,q*z+p$3*H$1.get(n$3,j$2)),H$1.set(n$3,j$2,q*H$1.get(n$3,j$2)-p$3*z);for(i$3=0;i$3<=n$3;i$3++)z=H$1.get(i$3,n$3-1),H$1.set(i$3,n$3-1,q*z+p$3*H$1.get(i$3,n$3)),H$1.set(i$3,n$3,q*H$1.get(i$3,n$3)-p$3*z);for(i$3=0;i$3<=high;i$3++)z=V.get(i$3,n$3-1),V.set(i$3,n$3-1,q*z+p$3*V.get(i$3,n$3)),V.set(i$3,n$3,q*V.get(i$3,n$3)-p$3*z)}else d$2[n$3-1]=x$2+p$3,d$2[n$3]=x$2+p$3,e$3[n$3-1]=z,e$3[n$3]=-z;n$3-=2,iter=0}else{if(x$2=H$1.get(n$3,n$3),y$2=0,w$3=0,l$2<n$3&&(y$2=H$1.get(n$3-1,n$3-1),w$3=H$1.get(n$3,n$3-1)*H$1.get(n$3-1,n$3)),iter===10){for(exshift+=x$2,i$3=0;i$3<=n$3;i$3++)H$1.set(i$3,i$3,H$1.get(i$3,i$3)-x$2);s$2=Math.abs(H$1.get(n$3,n$3-1))+Math.abs(H$1.get(n$3-1,n$3-2)),x$2=y$2=.75*s$2,w$3=-.4375*s$2*s$2}if(iter===30&&(s$2=(y$2-x$2)/2,s$2=s$2*s$2+w$3,s$2>0)){for(s$2=Math.sqrt(s$2),y$2<x$2&&(s$2=-s$2),s$2=x$2-w$3/((y$2-x$2)/2+s$2),i$3=0;i$3<=n$3;i$3++)H$1.set(i$3,i$3,H$1.get(i$3,i$3)-s$2);exshift+=s$2,x$2=y$2=w$3=.964}for(iter+=1,m$1=n$3-2;m$1>=l$2&&(z=H$1.get(m$1,m$1),r$3=x$2-z,s$2=y$2-z,p$3=(r$3*s$2-w$3)/H$1.get(m$1+1,m$1)+H$1.get(m$1,m$1+1),q=H$1.get(m$1+1,m$1+1)-z-r$3-s$2,r$3=H$1.get(m$1+2,m$1+1),s$2=Math.abs(p$3)+Math.abs(q)+Math.abs(r$3),p$3/=s$2,q/=s$2,r$3/=s$2,!(m$1===l$2||Math.abs(H$1.get(m$1,m$1-1))*(Math.abs(q)+Math.abs(r$3))<eps*(Math.abs(p$3)*(Math.abs(H$1.get(m$1-1,m$1-1))+Math.abs(z)+Math.abs(H$1.get(m$1+1,m$1+1))))));)m$1--;for(i$3=m$1+2;i$3<=n$3;i$3++)H$1.set(i$3,i$3-2,0),i$3>m$1+2&&H$1.set(i$3,i$3-3,0);for(k$2=m$1;k$2<=n$3-1&&(notlast=k$2!==n$3-1,k$2!==m$1&&(p$3=H$1.get(k$2,k$2-1),q=H$1.get(k$2+1,k$2-1),r$3=notlast?H$1.get(k$2+2,k$2-1):0,x$2=Math.abs(p$3)+Math.abs(q)+Math.abs(r$3),x$2!==0&&(p$3/=x$2,q/=x$2,r$3/=x$2)),x$2!==0);k$2++)if(s$2=Math.sqrt(p$3*p$3+q*q+r$3*r$3),p$3<0&&(s$2=-s$2),s$2!==0){for(k$2===m$1?l$2!==m$1&&H$1.set(k$2,k$2-1,-H$1.get(k$2,k$2-1)):H$1.set(k$2,k$2-1,-s$2*x$2),p$3+=s$2,x$2=p$3/s$2,y$2=q/s$2,z=r$3/s$2,q/=p$3,r$3/=p$3,j$2=k$2;j$2<nn;j$2++)p$3=H$1.get(k$2,j$2)+q*H$1.get(k$2+1,j$2),notlast&&(p$3+=r$3*H$1.get(k$2+2,j$2),H$1.set(k$2+2,j$2,H$1.get(k$2+2,j$2)-p$3*z)),H$1.set(k$2,j$2,H$1.get(k$2,j$2)-p$3*x$2),H$1.set(k$2+1,j$2,H$1.get(k$2+1,j$2)-p$3*y$2);for(i$3=0;i$3<=Math.min(n$3,k$2+3);i$3++)p$3=x$2*H$1.get(i$3,k$2)+y$2*H$1.get(i$3,k$2+1),notlast&&(p$3+=z*H$1.get(i$3,k$2+2),H$1.set(i$3,k$2+2,H$1.get(i$3,k$2+2)-p$3*r$3)),H$1.set(i$3,k$2,H$1.get(i$3,k$2)-p$3),H$1.set(i$3,k$2+1,H$1.get(i$3,k$2+1)-p$3*q);for(i$3=0;i$3<=high;i$3++)p$3=x$2*V.get(i$3,k$2)+y$2*V.get(i$3,k$2+1),notlast&&(p$3+=z*V.get(i$3,k$2+2),V.set(i$3,k$2+2,V.get(i$3,k$2+2)-p$3*r$3)),V.set(i$3,k$2,V.get(i$3,k$2)-p$3),V.set(i$3,k$2+1,V.get(i$3,k$2+1)-p$3*q)}}}if(norm!==0){for(n$3=nn-1;n$3>=0;n$3--)if(p$3=d$2[n$3],q=e$3[n$3],q===0)for(l$2=n$3,H$1.set(n$3,n$3,1),i$3=n$3-1;i$3>=0;i$3--){for(w$3=H$1.get(i$3,i$3)-p$3,r$3=0,j$2=l$2;j$2<=n$3;j$2++)r$3+=H$1.get(i$3,j$2)*H$1.get(j$2,n$3);if(e$3[i$3]<0)z=w$3,s$2=r$3;else if(l$2=i$3,e$3[i$3]===0?H$1.set(i$3,n$3,w$3===0?-r$3/(eps*norm):-r$3/w$3):(x$2=H$1.get(i$3,i$3+1),y$2=H$1.get(i$3+1,i$3),q=(d$2[i$3]-p$3)*(d$2[i$3]-p$3)+e$3[i$3]*e$3[i$3],t$3=(x$2*s$2-z*r$3)/q,H$1.set(i$3,n$3,t$3),H$1.set(i$3+1,n$3,Math.abs(x$2)>Math.abs(z)?(-r$3-w$3*t$3)/x$2:(-s$2-y$2*t$3)/z)),t$3=Math.abs(H$1.get(i$3,n$3)),eps*t$3*t$3>1)for(j$2=i$3;j$2<=n$3;j$2++)H$1.set(j$2,n$3,H$1.get(j$2,n$3)/t$3)}else if(q<0)for(l$2=n$3-1,Math.abs(H$1.get(n$3,n$3-1))>Math.abs(H$1.get(n$3-1,n$3))?(H$1.set(n$3-1,n$3-1,q/H$1.get(n$3,n$3-1)),H$1.set(n$3-1,n$3,-(H$1.get(n$3,n$3)-p$3)/H$1.get(n$3,n$3-1))):(cdivres=cdiv(0,-H$1.get(n$3-1,n$3),H$1.get(n$3-1,n$3-1)-p$3,q),H$1.set(n$3-1,n$3-1,cdivres[0]),H$1.set(n$3-1,n$3,cdivres[1])),H$1.set(n$3,n$3-1,0),H$1.set(n$3,n$3,1),i$3=n$3-2;i$3>=0;i$3--){for(ra=0,sa=0,j$2=l$2;j$2<=n$3;j$2++)ra+=H$1.get(i$3,j$2)*H$1.get(j$2,n$3-1),sa+=H$1.get(i$3,j$2)*H$1.get(j$2,n$3);if(w$3=H$1.get(i$3,i$3)-p$3,e$3[i$3]<0)z=w$3,r$3=ra,s$2=sa;else if(l$2=i$3,e$3[i$3]===0?(cdivres=cdiv(-ra,-sa,w$3,q),H$1.set(i$3,n$3-1,cdivres[0]),H$1.set(i$3,n$3,cdivres[1])):(x$2=H$1.get(i$3,i$3+1),y$2=H$1.get(i$3+1,i$3),vr=(d$2[i$3]-p$3)*(d$2[i$3]-p$3)+e$3[i$3]*e$3[i$3]-q*q,vi=(d$2[i$3]-p$3)*2*q,vr===0&&vi===0&&(vr=eps*norm*(Math.abs(w$3)+Math.abs(q)+Math.abs(x$2)+Math.abs(y$2)+Math.abs(z))),cdivres=cdiv(x$2*r$3-z*ra+q*sa,x$2*s$2-z*sa-q*ra,vr,vi),H$1.set(i$3,n$3-1,cdivres[0]),H$1.set(i$3,n$3,cdivres[1]),Math.abs(x$2)>Math.abs(z)+Math.abs(q)?(H$1.set(i$3+1,n$3-1,(-ra-w$3*H$1.get(i$3,n$3-1)+q*H$1.get(i$3,n$3))/x$2),H$1.set(i$3+1,n$3,(-sa-w$3*H$1.get(i$3,n$3)-q*H$1.get(i$3,n$3-1))/x$2)):(cdivres=cdiv(-r$3-y$2*H$1.get(i$3,n$3-1),-s$2-y$2*H$1.get(i$3,n$3),z,q),H$1.set(i$3+1,n$3-1,cdivres[0]),H$1.set(i$3+1,n$3,cdivres[1]))),t$3=Math.max(Math.abs(H$1.get(i$3,n$3-1)),Math.abs(H$1.get(i$3,n$3))),eps*t$3*t$3>1)for(j$2=i$3;j$2<=n$3;j$2++)H$1.set(j$2,n$3-1,H$1.get(j$2,n$3-1)/t$3),H$1.set(j$2,n$3,H$1.get(j$2,n$3)/t$3)}for(i$3=0;i$3<nn;i$3++)if(i$3<0||i$3>high)for(j$2=i$3;j$2<nn;j$2++)V.set(i$3,j$2,H$1.get(i$3,j$2));for(j$2=nn-1;j$2>=0;j$2--)for(i$3=0;i$3<=high;i$3++){for(z=0,k$2=0;k$2<=Math.min(j$2,high);k$2++)z+=V.get(i$3,k$2)*H$1.get(k$2,j$2);V.set(i$3,j$2,z)}}}function cdiv(xr,xi,yr,yi){let r$3,d$2;return Math.abs(yr)>Math.abs(yi)?(r$3=yi/yr,d$2=yr+r$3*yi,[(xr+r$3*xi)/d$2,(xi-r$3*xr)/d$2]):(r$3=yr/yi,d$2=yi+r$3*yr,[(r$3*xr+xi)/d$2,(r$3*xi-xr)/d$2])}var CholeskyDecomposition$1=class{constructor(value){if(value=WrapperMatrix2D$1.checkMatrix(value),!value.isSymmetric())throw Error(`Matrix is not symmetric`);let a$3=value,dimension=a$3.rows,l$2=new Matrix$1(dimension,dimension),positiveDefinite=!0,i$3,j$2,k$2;for(j$2=0;j$2<dimension;j$2++){let d$2=0;for(k$2=0;k$2<j$2;k$2++){let s$2=0;for(i$3=0;i$3<k$2;i$3++)s$2+=l$2.get(k$2,i$3)*l$2.get(j$2,i$3);s$2=(a$3.get(j$2,k$2)-s$2)/l$2.get(k$2,k$2),l$2.set(j$2,k$2,s$2),d$2+=s$2*s$2}for(d$2=a$3.get(j$2,j$2)-d$2,positiveDefinite&&=d$2>0,l$2.set(j$2,j$2,Math.sqrt(Math.max(d$2,0))),k$2=j$2+1;k$2<dimension;k$2++)l$2.set(j$2,k$2,0)}this.L=l$2,this.positiveDefinite=positiveDefinite}isPositiveDefinite(){return this.positiveDefinite}solve(value){value=WrapperMatrix2D$1.checkMatrix(value);let l$2=this.L,dimension=l$2.rows;if(value.rows!==dimension)throw Error(`Matrix dimensions do not match`);if(this.isPositiveDefinite()===!1)throw Error(`Matrix is not positive definite`);let count=value.columns,B$1=value.clone(),i$3,j$2,k$2;for(k$2=0;k$2<dimension;k$2++)for(j$2=0;j$2<count;j$2++){for(i$3=0;i$3<k$2;i$3++)B$1.set(k$2,j$2,B$1.get(k$2,j$2)-B$1.get(i$3,j$2)*l$2.get(k$2,i$3));B$1.set(k$2,j$2,B$1.get(k$2,j$2)/l$2.get(k$2,k$2))}for(k$2=dimension-1;k$2>=0;k$2--)for(j$2=0;j$2<count;j$2++){for(i$3=k$2+1;i$3<dimension;i$3++)B$1.set(k$2,j$2,B$1.get(k$2,j$2)-B$1.get(i$3,j$2)*l$2.get(i$3,k$2));B$1.set(k$2,j$2,B$1.get(k$2,j$2)/l$2.get(k$2,k$2))}return B$1}get lowerTriangularMatrix(){return this.L}},nipals=class{constructor(X,options={}){X=WrapperMatrix2D$1.checkMatrix(X);let{Y}=options,{scaleScores=!1,maxIterations=1e3,terminationCriteria=1e-10}=options,u$2;if(Y){if(Y=isAnyArray$1.isAnyArray(Y)&&typeof Y[0]==`number`?Matrix$1.columnVector(Y):WrapperMatrix2D$1.checkMatrix(Y),Y.rows!==X.rows)throw Error(`Y should have the same number of rows as X`);u$2=Y.getColumnVector(0)}else u$2=X.getColumnVector(0);let diff=1,t$3,q,w$3,tOld;for(let counter=0;counter<maxIterations&&diff>terminationCriteria;counter++)w$3=X.transpose().mmul(u$2).div(u$2.transpose().mmul(u$2).get(0,0)),w$3=w$3.div(w$3.norm()),t$3=X.mmul(w$3).div(w$3.transpose().mmul(w$3).get(0,0)),counter>0&&(diff=t$3.clone().sub(tOld).pow(2).sum()),tOld=t$3.clone(),Y?(q=Y.transpose().mmul(t$3).div(t$3.transpose().mmul(t$3).get(0,0)),q=q.div(q.norm()),u$2=Y.mmul(q).div(q.transpose().mmul(q).get(0,0))):u$2=t$3;if(Y){let p$3=X.transpose().mmul(t$3).div(t$3.transpose().mmul(t$3).get(0,0));p$3=p$3.div(p$3.norm());let xResidual=X.clone().sub(t$3.clone().mmul(p$3.transpose())),residual=u$2.transpose().mmul(t$3).div(t$3.transpose().mmul(t$3).get(0,0)),yResidual=Y.clone().sub(t$3.clone().mulS(residual.get(0,0)).mmul(q.transpose()));this.t=t$3,this.p=p$3.transpose(),this.w=w$3.transpose(),this.q=q,this.u=u$2,this.s=t$3.transpose().mmul(t$3),this.xResidual=xResidual,this.yResidual=yResidual,this.betas=residual}else this.w=w$3.transpose(),this.s=t$3.transpose().mmul(t$3).sqrt(),scaleScores?this.t=t$3.clone().div(this.s.get(0,0)):this.t=t$3,this.xResidual=X.sub(t$3.mmul(w$3.transpose()))}};exports.AbstractMatrix=AbstractMatrix$1,exports.CHO=CholeskyDecomposition$1,exports.CholeskyDecomposition=CholeskyDecomposition$1,exports.DistanceMatrix=DistanceMatrix$1,exports.EVD=EigenvalueDecomposition$1,exports.EigenvalueDecomposition=EigenvalueDecomposition$1,exports.LU=LuDecomposition$1,exports.LuDecomposition=LuDecomposition$1,exports.Matrix=Matrix$1,exports.MatrixColumnSelectionView=MatrixColumnSelectionView$1,exports.MatrixColumnView=MatrixColumnView$1,exports.MatrixFlipColumnView=MatrixFlipColumnView$1,exports.MatrixFlipRowView=MatrixFlipRowView$1,exports.MatrixRowSelectionView=MatrixRowSelectionView$1,exports.MatrixRowView=MatrixRowView$1,exports.MatrixSelectionView=MatrixSelectionView$1,exports.MatrixSubView=MatrixSubView$1,exports.MatrixTransposeView=MatrixTransposeView$1,exports.NIPALS=nipals,exports.Nipals=nipals,exports.QR=QrDecomposition$1,exports.QrDecomposition=QrDecomposition$1,exports.SVD=SingularValueDecomposition$1,exports.SingularValueDecomposition=SingularValueDecomposition$1,exports.SymmetricMatrix=SymmetricMatrix$1,exports.WrapperMatrix1D=WrapperMatrix1D$1,exports.WrapperMatrix2D=WrapperMatrix2D$1,exports.correlation=correlation$1,exports.covariance=covariance$1,exports.default=Matrix$1,exports.determinant=determinant$1,exports.inverse=inverse$1,exports.linearDependencies=linearDependencies$1,exports.pseudoInverse=pseudoInverse$1,exports.solve=solve$1,exports.wrap=wrap$1}))(),1);const AbstractMatrix=import_matrix.AbstractMatrix,CHO=import_matrix.CHO,CholeskyDecomposition=import_matrix.CholeskyDecomposition,DistanceMatrix=import_matrix.DistanceMatrix,EVD=import_matrix.EVD,EigenvalueDecomposition=import_matrix.EigenvalueDecomposition,LU=import_matrix.LU,LuDecomposition=import_matrix.LuDecomposition,Matrix=import_matrix.Matrix,MatrixColumnSelectionView=import_matrix.MatrixColumnSelectionView,MatrixColumnView=import_matrix.MatrixColumnView,MatrixFlipColumnView=import_matrix.MatrixFlipColumnView,MatrixFlipRowView=import_matrix.MatrixFlipRowView,MatrixRowSelectionView=import_matrix.MatrixRowSelectionView,MatrixRowView=import_matrix.MatrixRowView,MatrixSelectionView=import_matrix.MatrixSelectionView,MatrixSubView=import_matrix.MatrixSubView,MatrixTransposeView=import_matrix.MatrixTransposeView,NIPALS=import_matrix.NIPALS,Nipals=import_matrix.Nipals,QR=import_matrix.QR,QrDecomposition=import_matrix.QrDecomposition,SVD=import_matrix.SVD,SingularValueDecomposition=import_matrix.SingularValueDecomposition,SymmetricMatrix=import_matrix.SymmetricMatrix,WrapperMatrix1D=import_matrix.WrapperMatrix1D,WrapperMatrix2D=import_matrix.WrapperMatrix2D,correlation=import_matrix.correlation,covariance=import_matrix.covariance;var matrix_default=import_matrix.default.Matrix?import_matrix.default.Matrix:import_matrix.Matrix;const determinant=import_matrix.determinant,inverse=import_matrix.inverse,linearDependencies=import_matrix.linearDependencies,pseudoInverse=import_matrix.pseudoInverse,solve=import_matrix.solve,wrap=import_matrix.wrap;var require_median_quickselect_min=__commonJSMin(((exports,module)=>{(function(){function a$3(d$2){for(var e$3=0,f$1=d$2.length-1,g$1=void 0,h$3=void 0,i$3=void 0,j$2=c$2(e$3,f$1);;){if(f$1<=e$3)return d$2[j$2];if(f$1==e$3+1)return d$2[e$3]>d$2[f$1]&&b$3(d$2,e$3,f$1),d$2[j$2];for(g$1=c$2(e$3,f$1),d$2[g$1]>d$2[f$1]&&b$3(d$2,g$1,f$1),d$2[e$3]>d$2[f$1]&&b$3(d$2,e$3,f$1),d$2[g$1]>d$2[e$3]&&b$3(d$2,g$1,e$3),b$3(d$2,g$1,e$3+1),h$3=e$3+1,i$3=f$1;;){do h$3++;while(d$2[e$3]>d$2[h$3]);do i$3--;while(d$2[i$3]>d$2[e$3]);if(i$3<h$3)break;b$3(d$2,h$3,i$3)}b$3(d$2,e$3,i$3),i$3<=j$2&&(e$3=h$3),i$3>=j$2&&(f$1=i$3-1)}}var b$3=function(d$2,e$3,f$1){var _ref;return _ref=[d$2[f$1],d$2[e$3]],d$2[e$3]=_ref[0],d$2[f$1]=_ref[1],_ref},c$2=function(d$2,e$3){return~~((d$2+e$3)/2)};module!==void 0&&module.exports?module.exports=a$3:window.median=a$3})()})),import_median_quickselect_min$2=__toESM(require_median_quickselect_min()),FLOAT_MUL$1=1/16777216;function difference(p1,p2){return{column:p1.column-p2.column,row:p1.row-p2.row}}function normalize(point){let length=Math.hypot(point.column,point.row);return{column:point.column/length,row:point.row/length}}function rotate$1(radians,points){let results=[],cos=Math.cos(radians),sin=Math.sin(radians);for(let point of points)results.push({column:cos*point.column-sin*point.row,row:sin*point.column+cos*point.row});return results}function getAngle(p1,p2){let diff=difference(p2,p1),vector=normalize(diff),angle=Math.acos(vector.column);return vector.row<0?-angle:angle}function toDegrees(radians){return radians*180/Math.PI}function getRadius(size){if(size%2!=1||size<0)throw RangeError(`size must be positive and odd`);return(size-1)/2}var t$2=Symbol.for(`@ts-pattern/matcher`),e$2=Symbol.for(`@ts-pattern/isVariadic`),n$2=`@ts-pattern/anonymous-select-key`,r$2=t$3=>!!(t$3&&typeof t$3==`object`),i$2=e$3=>e$3&&!!e$3[t$2],o$2=(n$3,s$2,c$2)=>{if(i$2(n$3)){let{matched:r$3,selections:i$3}=n$3[t$2]().match(s$2);return r$3&&i$3&&Object.keys(i$3).forEach(t$3=>c$2(t$3,i$3[t$3])),r$3}if(r$2(n$3)){if(!r$2(s$2))return!1;if(Array.isArray(n$3)){if(!Array.isArray(s$2))return!1;let t$3=[],r$3=[],u$2=[];for(let o$3 of n$3.keys()){let s$3=n$3[o$3];i$2(s$3)&&s$3[e$2]?u$2.push(s$3):u$2.length?r$3.push(s$3):t$3.push(s$3)}if(u$2.length){if(u$2.length>1)throw Error("Pattern error: Using `...P.array(...)` several times in a single pattern is not allowed.");if(s$2.length<t$3.length+r$3.length)return!1;let e$3=s$2.slice(0,t$3.length),n$4=r$3.length===0?[]:s$2.slice(-r$3.length),i$3=s$2.slice(t$3.length,r$3.length===0?1/0:-r$3.length);return t$3.every((t$4,n$5)=>o$2(t$4,e$3[n$5],c$2))&&r$3.every((t$4,e$4)=>o$2(t$4,n$4[e$4],c$2))&&(u$2.length===0||o$2(u$2[0],i$3,c$2))}return n$3.length===s$2.length&&n$3.every((t$4,e$3)=>o$2(t$4,s$2[e$3],c$2))}return Reflect.ownKeys(n$3).every(e$3=>{let r$3=n$3[e$3];return(e$3 in s$2||i$2(u$2=r$3)&&u$2[t$2]().matcherType===`optional`)&&o$2(r$3,s$2[e$3],c$2);var u$2})}return Object.is(s$2,n$3)},s$1=e$3=>{var n$3,o$3,u$2;return r$2(e$3)?i$2(e$3)?(u$2=e$3[t$2]()).getSelectionKeys?.call(u$2)??[]:c$1(Array.isArray(e$3)?e$3:Object.values(e$3),s$1):[]},c$1=(t$3,e$3)=>t$3.reduce((t$4,n$3)=>t$4.concat(e$3(n$3)),[]);function a$2(t$3){return Object.assign(t$3,{optional:()=>h$2(t$3),and:e$3=>d$1(t$3,e$3),or:e$3=>y$1(t$3,e$3),select:e$3=>e$3===void 0?v$1(t$3):v$1(e$3,t$3)})}function h$2(e$3){return a$2({[t$2]:()=>({match:t$3=>{let n$3={},r$3=(t$4,e$4)=>{n$3[t$4]=e$4};return t$3===void 0?(s$1(e$3).forEach(t$4=>r$3(t$4,void 0)),{matched:!0,selections:n$3}):{matched:o$2(e$3,t$3,r$3),selections:n$3}},getSelectionKeys:()=>s$1(e$3),matcherType:`optional`})})}function d$1(...e$3){return a$2({[t$2]:()=>({match:t$3=>{let n$3={},r$3=(t$4,e$4)=>{n$3[t$4]=e$4};return{matched:e$3.every(e$4=>o$2(e$4,t$3,r$3)),selections:n$3}},getSelectionKeys:()=>c$1(e$3,s$1),matcherType:`and`})})}function y$1(...e$3){return a$2({[t$2]:()=>({match:t$3=>{let n$3={},r$3=(t$4,e$4)=>{n$3[t$4]=e$4};return c$1(e$3,s$1).forEach(t$4=>r$3(t$4,void 0)),{matched:e$3.some(e$4=>o$2(e$4,t$3,r$3)),selections:n$3}},getSelectionKeys:()=>c$1(e$3,s$1),matcherType:`or`})})}function p$2(e$3){return{[t$2]:()=>({match:t$3=>({matched:!!e$3(t$3)})})}}function v$1(...e$3){let r$3=typeof e$3[0]==`string`?e$3[0]:void 0,i$3=e$3.length===2?e$3[1]:typeof e$3[0]==`string`?void 0:e$3[0];return a$2({[t$2]:()=>({match:t$3=>{let e$4={[r$3??n$2]:t$3};return{matched:i$3===void 0||o$2(i$3,t$3,(t$4,n$3)=>{e$4[t$4]=n$3}),selections:e$4}},getSelectionKeys:()=>[r$3??n$2].concat(i$3===void 0?[]:s$1(i$3))})})}function b$2(t$3){return!0}function w$2(t$3){return typeof t$3==`number`}function S$1(t$3){return typeof t$3==`string`}function j$1(t$3){return typeof t$3==`bigint`}var K=a$2(p$2(b$2)),O=a$2(p$2(b$2)),E$1=K,x$1=t$3=>Object.assign(a$2(t$3),{startsWith:e$3=>{return x$1(d$1(t$3,(n$3=e$3,p$2(t$4=>S$1(t$4)&&t$4.startsWith(n$3)))));var n$3},endsWith:e$3=>{return x$1(d$1(t$3,(n$3=e$3,p$2(t$4=>S$1(t$4)&&t$4.endsWith(n$3)))));var n$3},minLength:e$3=>x$1(d$1(t$3,(t$4=>p$2(e$4=>S$1(e$4)&&e$4.length>=t$4))(e$3))),length:e$3=>x$1(d$1(t$3,(t$4=>p$2(e$4=>S$1(e$4)&&e$4.length===t$4))(e$3))),maxLength:e$3=>x$1(d$1(t$3,(t$4=>p$2(e$4=>S$1(e$4)&&e$4.length<=t$4))(e$3))),includes:e$3=>{return x$1(d$1(t$3,(n$3=e$3,p$2(t$4=>S$1(t$4)&&t$4.includes(n$3)))));var n$3},regex:e$3=>{return x$1(d$1(t$3,(n$3=e$3,p$2(t$4=>S$1(t$4)&&!!t$4.match(n$3)))));var n$3}}),A=x$1(p$2(S$1)),N$1=t$3=>Object.assign(a$2(t$3),{between:(e$3,n$3)=>N$1(d$1(t$3,((t$4,e$4)=>p$2(n$4=>w$2(n$4)&&t$4<=n$4&&e$4>=n$4))(e$3,n$3))),lt:e$3=>N$1(d$1(t$3,(t$4=>p$2(e$4=>w$2(e$4)&&e$4<t$4))(e$3))),gt:e$3=>N$1(d$1(t$3,(t$4=>p$2(e$4=>w$2(e$4)&&e$4>t$4))(e$3))),lte:e$3=>N$1(d$1(t$3,(t$4=>p$2(e$4=>w$2(e$4)&&e$4<=t$4))(e$3))),gte:e$3=>N$1(d$1(t$3,(t$4=>p$2(e$4=>w$2(e$4)&&e$4>=t$4))(e$3))),int:()=>N$1(d$1(t$3,p$2(t$4=>w$2(t$4)&&Number.isInteger(t$4)))),finite:()=>N$1(d$1(t$3,p$2(t$4=>w$2(t$4)&&Number.isFinite(t$4)))),positive:()=>N$1(d$1(t$3,p$2(t$4=>w$2(t$4)&&t$4>0))),negative:()=>N$1(d$1(t$3,p$2(t$4=>w$2(t$4)&&t$4<0)))}),P=N$1(p$2(w$2)),k$1=t$3=>Object.assign(a$2(t$3),{between:(e$3,n$3)=>k$1(d$1(t$3,((t$4,e$4)=>p$2(n$4=>j$1(n$4)&&t$4<=n$4&&e$4>=n$4))(e$3,n$3))),lt:e$3=>k$1(d$1(t$3,(t$4=>p$2(e$4=>j$1(e$4)&&e$4<t$4))(e$3))),gt:e$3=>k$1(d$1(t$3,(t$4=>p$2(e$4=>j$1(e$4)&&e$4>t$4))(e$3))),lte:e$3=>k$1(d$1(t$3,(t$4=>p$2(e$4=>j$1(e$4)&&e$4<=t$4))(e$3))),gte:e$3=>k$1(d$1(t$3,(t$4=>p$2(e$4=>j$1(e$4)&&e$4>=t$4))(e$3))),positive:()=>k$1(d$1(t$3,p$2(t$4=>j$1(t$4)&&t$4>0))),negative:()=>k$1(d$1(t$3,p$2(t$4=>j$1(t$4)&&t$4<0)))}),T=k$1(p$2(j$1)),B=a$2(p$2(function(t$3){return typeof t$3==`boolean`})),_=a$2(p$2(function(t$3){return typeof t$3==`symbol`})),W=a$2(p$2(function(t$3){return t$3==null})),$$1=a$2(p$2(function(t$3){return t$3!=null})),I$1=class extends Error{constructor(t$3){let e$3;try{e$3=JSON.stringify(t$3)}catch{e$3=t$3}super(`Pattern matching error: no pattern matches value ${e$3}`),this.input=void 0,this.input=t$3}},L={matched:!1,value:void 0};function M(t$3){return new R(t$3,L)}var R=class R{constructor(t$3,e$3){this.input=void 0,this.state=void 0,this.input=t$3,this.state=e$3}with(...t$3){if(this.state.matched)return this;let e$3=t$3[t$3.length-1],r$3=[t$3[0]],i$3;t$3.length===3&&typeof t$3[1]==`function`?i$3=t$3[1]:t$3.length>2&&r$3.push(...t$3.slice(1,t$3.length-1));let s$2=!1,c$2={},u$2=(t$4,e$4)=>{s$2=!0,c$2[t$4]=e$4},a$3=!r$3.some(t$4=>o$2(t$4,this.input,u$2))||i$3&&!i$3(this.input)?L:{matched:!0,value:e$3(s$2?n$2 in c$2?c$2[n$2]:c$2:this.input,this.input)};return new R(this.input,a$3)}when(t$3,e$3){if(this.state.matched)return this;let n$3=!!t$3(this.input);return new R(this.input,n$3?{matched:!0,value:e$3(this.input,this.input)}:L)}otherwise(t$3){return this.state.matched?this.state.value:t$3(this.input)}exhaustive(t$3=F){return this.state.matched?this.state.value:t$3(this.input)}run(){return this.exhaustive()}returnType(){return this}narrow(){return this}};function F(t$3){throw new I$1(t$3)}var require_index_umd=__commonJSMin(((exports,module)=>{(function(N$2,J){typeof exports==`object`&&typeof module<`u`?J(exports):typeof define==`function`&&define.amd?define([`exports`],J):(N$2=typeof globalThis<`u`?globalThis:N$2||self,J(N$2.bresenham={}))})(exports,(function(N$2){function J(f$1,a$3,o$3,t$3,e$3){let h$3=Math.abs(o$3-f$1),r$3=f$1<o$3?1:-1,l$2=-Math.abs(t$3-a$3),M$3=a$3<t$3?1:-1,i$3=h$3+l$2,n$3;for(;;){if(e$3(f$1,a$3),n$3=2*i$3,n$3>=l$2){if(f$1===o$3)break;i$3+=l$2,f$1+=r$3}if(n$3<=h$3){if(a$3===t$3)break;i$3+=h$3,a$3+=M$3}}}function U(f$1,a$3,o$3,t$3,e$3){let h$3=f$1<o$3?1:-1,r$3=a$3<t$3?1:-1,l$2,M$3=Math.abs(o$3-f$1),i$3=Math.abs(t$3-a$3),n$3=M$3*M$3+i$3*i$3,c$2=n$3===0?1:1/Math.sqrt(n$3);for(M$3*=c$2,i$3*=c$2,n$3=M$3-i$3;;){if(e$3(f$1,a$3,Math.abs(n$3-(M$3+i$3))>>16),c$2=n$3,l$2=f$1,2*c$2>=-M$3){if(f$1===o$3)break;c$2+i$3<16711680&&e$3(f$1,a$3+r$3,c$2+i$3>>16),n$3-=i$3,f$1+=h$3}if(2*c$2<=i$3){if(a$3===t$3)break;M$3-c$2<16711680&&e$3(l$2+h$3,a$3,M$3-c$2>>16),n$3+=M$3,a$3+=r$3}}}function w$3(f$1,a$3,o$3,t$3,e$3,h$3){let r$3=Math.abs(o$3-f$1),l$2=f$1<o$3?1:-1,M$3=Math.abs(t$3-a$3),i$3=a$3<t$3?1:-1,n$3=r$3-M$3,c$2,q,d$2,b$3=r$3+M$3==0?1:Math.sqrt(r$3*r$3+M$3*M$3);for(e$3=(e$3+1)/2;;){if(h$3(f$1,a$3,Math.max(0,255*(Math.abs(n$3-r$3+M$3)/b$3-e$3+1))),c$2=n$3,q=f$1,2*c$2>=-r$3){for(c$2+=M$3,d$2=a$3;c$2<b$3*e$3&&(t$3!=d$2||r$3>M$3);c$2+=r$3)h$3(f$1,d$2+=i$3,Math.max(0,255*(Math.abs(c$2)/b$3-e$3+1)));if(f$1==o$3)break;c$2=n$3,n$3-=M$3,f$1+=l$2}if(2*c$2<=M$3){for(c$2=r$3-c$2;c$2<b$3*e$3&&(o$3!=q||r$3<M$3);c$2+=M$3)h$3(q+=l$2,a$3,Math.max(0,255*(Math.abs(c$2)/b$3-e$3+1)));if(a$3==t$3)break;n$3+=r$3,a$3+=i$3}}}function I$2(f$1,a$3=`assert error`){if(!f$1)throw Error(a$3)}function P$1(f$1,a$3,o$3,t$3,e$3,h$3,r$3,l$2){var M$3=f$1-2*o$3+e$3,i$3=a$3-2*t$3+h$3,n$3=f$1-o$3,c$2=a$3-t$3,q,d$2,b$3;I$2(r$3>=0,`width is negative`),n$3*(e$3-o$3)>0&&(c$2*(h$3-t$3)>0&&Math.abs(n$3*i$3)>Math.abs(c$2*M$3)&&(f$1=e$3,e$3=n$3+o$3,a$3=h$3,h$3=c$2+t$3),f$1==e$3||r$3==1?d$2=(f$1-o$3)/M$3:(b$3=Math.sqrt(4*r$3*r$3*(f$1-o$3)*(e$3-o$3)+(e$3-f$1)*(e$3-f$1)),o$3<f$1&&(b$3=-b$3),d$2=(2*r$3*(f$1-o$3)-f$1+e$3+b$3)/(2*(1-r$3)*(e$3-f$1))),b$3=1/(2*d$2*(1-d$2)*(r$3-1)+1),n$3=(d$2*d$2*(f$1-2*r$3*o$3+e$3)+2*d$2*(r$3*o$3-f$1)+f$1)*b$3,c$2=(d$2*d$2*(a$3-2*r$3*t$3+h$3)+2*d$2*(r$3*t$3-a$3)+a$3)*b$3,q=d$2*(r$3-1)+1,q*=q*b$3,r$3=((1-d$2)*(r$3-1)+1)*Math.sqrt(b$3),M$3=Math.floor(n$3+.5),i$3=Math.floor(c$2+.5),c$2=(n$3-f$1)*(t$3-a$3)/(o$3-f$1)+a$3,H$1(f$1,a$3,M$3,Math.floor(c$2+.5),M$3,i$3,q,l$2),c$2=(n$3-e$3)*(t$3-h$3)/(o$3-e$3)+h$3,t$3=Math.floor(c$2+.5),f$1=o$3=M$3,a$3=i$3),(a$3-t$3)*(h$3-t$3)>0&&(a$3==h$3||r$3==1?d$2=(a$3-t$3)/(a$3-2*t$3+h$3):(b$3=Math.sqrt(4*r$3*r$3*(a$3-t$3)*(h$3-t$3)+(h$3-a$3)*(h$3-a$3)),t$3<a$3&&(b$3=-b$3),d$2=(2*r$3*(a$3-t$3)-a$3+h$3+b$3)/(2*(1-r$3)*(h$3-a$3))),b$3=1/(2*d$2*(1-d$2)*(r$3-1)+1),n$3=(d$2*d$2*(f$1-2*r$3*o$3+e$3)+2*d$2*(r$3*o$3-f$1)+f$1)*b$3,c$2=(d$2*d$2*(a$3-2*r$3*t$3+h$3)+2*d$2*(r$3*t$3-a$3)+a$3)*b$3,q=d$2*(r$3-1)+1,q*=q*b$3,r$3=((1-d$2)*(r$3-1)+1)*Math.sqrt(b$3),M$3=Math.floor(n$3+.5),i$3=Math.floor(c$2+.5),n$3=(o$3-f$1)*(c$2-a$3)/(t$3-a$3)+f$1,H$1(f$1,a$3,Math.floor(n$3+.5),i$3,M$3,i$3,q,l$2),n$3=(o$3-e$3)*(c$2-h$3)/(t$3-h$3)+e$3,o$3=Math.floor(n$3+.5),f$1=M$3,a$3=t$3=i$3),H$1(f$1,a$3,o$3,t$3,e$3,h$3,r$3*r$3,l$2)}function H$1(f$1,a$3,o$3,t$3,e$3,h$3,r$3,l$2){var M$3=e$3-o$3,i$3=h$3-t$3,n$3=f$1-e$3,c$2=a$3-h$3,q=f$1-o$3,d$2=a$3-t$3,b$3=q*i$3+d$2*M$3,s$2=q*i$3-d$2*M$3,u$2;if(I$2(q*M$3<=0&&d$2*i$3<=0,`sign of gradient must not change`),s$2!=0&&r$3>0){if(M$3*M$3+i$3*i$3>q*q+d$2*d$2&&(e$3=f$1,f$1-=n$3,h$3=a$3,a$3-=c$2,s$2=-s$2),q=2*(4*r$3*M$3*q+n$3*n$3),d$2=2*(4*r$3*i$3*d$2+c$2*c$2),M$3=f$1<e$3?1:-1,i$3=a$3<h$3?1:-1,b$3=-2*M$3*i$3*(2*r$3*b$3+n$3*c$2),s$2*M$3*i$3<0&&(q=-q,d$2=-d$2,b$3=-b$3,s$2=-s$2),n$3=4*r$3*(o$3-f$1)*i$3*s$2+q/2+b$3,c$2=4*r$3*(a$3-t$3)*M$3*s$2+d$2/2+b$3,r$3<.5&&(c$2>b$3||n$3<b$3)){s$2=(r$3+1)/2,r$3=Math.sqrt(r$3),b$3=1/(r$3+1),M$3=Math.floor((f$1+2*r$3*o$3+e$3)*b$3/2+.5),i$3=Math.floor((a$3+2*r$3*t$3+h$3)*b$3/2+.5),n$3=Math.floor((r$3*o$3+f$1)*b$3+.5),c$2=Math.floor((t$3*r$3+a$3)*b$3+.5),H$1(f$1,a$3,n$3,c$2,M$3,i$3,s$2,l$2),n$3=Math.floor((r$3*o$3+e$3)*b$3+.5),c$2=Math.floor((t$3*r$3+h$3)*b$3+.5),H$1(M$3,i$3,n$3,c$2,e$3,h$3,s$2,l$2);return}u$2=n$3+c$2-b$3;do{if(l$2(f$1,a$3),f$1==e$3&&a$3==h$3)return;o$3=2*u$2>c$2?1:0,t$3=2*(u$2+d$2)<-c$2?1:0,(2*u$2<n$3||t$3)&&(a$3+=i$3,c$2+=b$3,u$2+=n$3+=q),(2*u$2>n$3||o$3)&&(f$1+=M$3,n$3+=b$3,u$2+=c$2+=d$2)}while(c$2<=b$3&&n$3>=b$3)}J(f$1,a$3,e$3,h$3,l$2)}function V(f$1,a$3,o$3,t$3,e$3,h$3,r$3,l$2){var M$3=e$3-o$3,i$3=h$3-t$3,n$3=f$1-e$3,c$2=a$3-h$3,q=f$1-o$3,d$2=a$3-t$3,b$3=q*i$3+d$2*M$3,s$2=q*i$3-d$2*M$3,u$2,z,j$2;if(I$2(q*M$3<=0&&d$2*i$3<=0),s$2!=0&&r$3>0){if(M$3*M$3+i$3*i$3>q*q+d$2*d$2&&(e$3=f$1,f$1-=n$3,h$3=a$3,a$3-=c$2,s$2=-s$2),q=2*(4*r$3*M$3*q+n$3*n$3),d$2=2*(4*r$3*i$3*d$2+c$2*c$2),M$3=f$1<e$3?1:-1,i$3=a$3<h$3?1:-1,b$3=-2*M$3*i$3*(2*r$3*b$3+n$3*c$2),s$2*M$3*i$3<0&&(q=-q,d$2=-d$2,s$2=-s$2,b$3=-b$3),n$3=4*r$3*(o$3-f$1)*i$3*s$2+q/2+b$3,c$2=4*r$3*(a$3-t$3)*M$3*s$2+d$2/2+b$3,r$3<.5&&c$2>n$3)return s$2=(r$3+1)/2,r$3=Math.sqrt(r$3),b$3=1/(r$3+1),M$3=Math.floor((f$1+2*r$3*o$3+e$3)*b$3/2+.5),i$3=Math.floor((a$3+2*r$3*t$3+h$3)*b$3/2+.5),n$3=Math.floor((r$3*o$3+f$1)*b$3+.5),c$2=Math.floor((t$3*r$3+a$3)*b$3+.5),V(f$1,a$3,n$3,c$2,M$3,i$3,s$2,l$2),n$3=Math.floor((r$3*o$3+e$3)*b$3+.5),c$2=Math.floor((t$3*r$3+h$3)*b$3+.5),V(M$3,i$3,n$3,c$2,e$3,h$3,s$2,l$2);u$2=n$3+c$2-b$3;do{if(s$2=Math.min(n$3-b$3,b$3-c$2),z=Math.max(n$3-b$3,b$3-c$2),z+=2*z*s$2*s$2/(4*z*z+s$2*s$2),o$3=255*Math.abs(u$2-n$3-c$2+b$3)/z,o$3<256&&l$2(f$1,a$3,o$3),j$2=2*u$2+c$2<0){if(a$3==h$3)return;n$3-u$2<z&&l$2(f$1+M$3,a$3,255*Math.abs(n$3-u$2)/z)}if(2*u$2+n$3>0){if(f$1==e$3)return;u$2-c$2<z&&l$2(f$1,a$3+i$3,255*Math.abs(u$2-c$2)/z),f$1+=M$3,n$3+=b$3,u$2+=c$2+=d$2}j$2&&(a$3+=i$3,c$2+=b$3,u$2+=n$3+=q)}while(c$2<n$3)}U(f$1,a$3,e$3,h$3,l$2)}function y$2(f$1,a$3,o$3,t$3,e$3){let h$3=-o$3,r$3=0,l$2=t$3*t$3,M$3=h$3*(2*l$2+h$3)+l$2;do e$3(f$1-h$3,a$3+r$3),e$3(f$1+h$3,a$3+r$3),e$3(f$1+h$3,a$3-r$3),e$3(f$1-h$3,a$3-r$3),l$2=2*M$3,l$2>=(h$3*2+1)*t$3*t$3&&(M$3+=(++h$3*2+1)*t$3*t$3),l$2<=(r$3*2+1)*o$3*o$3&&(M$3+=(++r$3*2+1)*o$3*o$3);while(h$3<=0);for(;r$3++<t$3;)e$3(f$1,a$3+r$3),e$3(f$1,a$3-r$3)}function x$2(f$1,a$3,o$3,t$3,e$3,h$3){let r$3=o$3*o$3,l$2=t$3*t$3,M$3=Math.sin(e$3),i$3=(r$3-l$2)*M$3;r$3=Math.sqrt(r$3-i$3*M$3),l$2=Math.sqrt(l$2+i$3*M$3),o$3=r$3+.5,t$3=l$2+.5,i$3=i$3*o$3*t$3/(r$3*l$2),Y(f$1-o$3,a$3-t$3,f$1+o$3,a$3+t$3,4*i$3*Math.cos(e$3),h$3)}function Y(f$1,a$3,o$3,t$3,e$3,h$3){let r$3=o$3-f$1,l$2=t$3-a$3,M$3=r$3*l$2;if(e$3===0)return Z(f$1,a$3,o$3,t$3,h$3);M$3!==0&&(M$3=(M$3-e$3)/(M$3+M$3)),I$2(M$3<=1&&M$3>=0,`limit angle to |zd|<=xd*yd`),r$3=Math.floor(r$3*M$3+.5),l$2=Math.floor(l$2*M$3+.5),H$1(f$1,a$3+l$2,f$1,a$3,f$1+r$3,a$3,1-M$3,h$3),H$1(f$1,a$3+l$2,f$1,t$3,o$3-r$3,t$3,M$3,h$3),H$1(o$3,t$3-l$2,o$3,t$3,o$3-r$3,t$3,1-M$3,h$3),H$1(o$3,t$3-l$2,o$3,a$3,f$1+r$3,a$3,M$3,h$3)}function Z(f$1,a$3,o$3,t$3,e$3){let h$3=Math.abs(o$3-f$1),r$3=Math.abs(t$3-a$3),l$2=r$3&1,M$3=4*(1-h$3)*r$3*r$3,i$3=4*(l$2+1)*h$3*h$3,n$3=M$3+i$3+l$2*h$3*h$3,c$2;f$1>o$3&&(f$1=o$3,o$3+=h$3),a$3>t$3&&(a$3=t$3),a$3+=(r$3+1)/2,t$3=a$3-l$2,h$3=8*h$3*h$3,l$2=8*r$3*r$3;do e$3(o$3,a$3),e$3(f$1,a$3),e$3(f$1,t$3),e$3(o$3,t$3),c$2=2*n$3,c$2<=i$3&&(a$3++,t$3--,n$3+=i$3+=h$3),(c$2>=M$3||2*n$3>i$3)&&(f$1++,o$3--,n$3+=M$3+=l$2);while(f$1<=o$3);for(;a$3-t$3<=r$3;)e$3(f$1-1,a$3),e$3(o$3+1,a$3++),e$3(f$1-1,t$3),e$3(o$3+1,t$3--)}function aa(f$1,a$3,o$3,t$3){var e$3=-o$3,h$3=0,r$3=2-2*o$3;do t$3(f$1-e$3,a$3+h$3),t$3(f$1-h$3,a$3-e$3),t$3(f$1+e$3,a$3-h$3),t$3(f$1+h$3,a$3+e$3),o$3=r$3,o$3<=h$3&&(r$3+=++h$3*2+1),(o$3>e$3||r$3>h$3)&&(r$3+=++e$3*2+1);while(e$3<0)}function fa(f$1,a$3,o$3,t$3){var e$3=-o$3,h$3=0,r$3,l$2,M$3,i$3=2-2*o$3;o$3=1-i$3;do r$3=255*Math.abs(i$3-2*(e$3+h$3)-2)/o$3,t$3(f$1-e$3,a$3+h$3,r$3),t$3(f$1-h$3,a$3-e$3,r$3),t$3(f$1+e$3,a$3-h$3,r$3),t$3(f$1+h$3,a$3+e$3,r$3),M$3=i$3,l$2=e$3,i$3+h$3>0&&(r$3=255*(i$3-2*e$3-1)/o$3,r$3<256&&(t$3(f$1-e$3,a$3+h$3+1,r$3),t$3(f$1-h$3-1,a$3-e$3,r$3),t$3(f$1+e$3,a$3-h$3-1,r$3),t$3(f$1+h$3+1,a$3+e$3,r$3)),i$3+=++e$3*2+1),M$3+l$2<=0&&(r$3=255*(2*h$3+3-M$3)/o$3,r$3<256&&(t$3(f$1-l$2-1,a$3+h$3,r$3),t$3(f$1-h$3,a$3-l$2-1,r$3),t$3(f$1+l$2+1,a$3-h$3,r$3),t$3(f$1+h$3,a$3+l$2+1,r$3)),i$3+=++h$3*2+1);while(e$3<0)}function ta(f$1,a$3,o$3,t$3,e$3,h$3,r$3){var l$2=f$1-o$3,M$3=a$3-t$3,i$3=f$1-2*o$3+e$3,n$3;l$2*(e$3-o$3)>0&&(M$3*(h$3-t$3)>0&&Math.abs((a$3-2*t$3+h$3)/i$3*l$2)>Math.abs(M$3)&&(f$1=e$3,e$3=l$2+o$3,a$3=h$3,h$3=M$3+t$3),i$3=(f$1-o$3)/i$3,n$3=(1-i$3)*((1-i$3)*a$3+2*i$3*t$3)+i$3*i$3*h$3,i$3=(f$1*e$3-o$3*o$3)*i$3/(f$1-o$3),l$2=Math.floor(i$3+.5),M$3=Math.floor(n$3+.5),n$3=(t$3-a$3)*(i$3-f$1)/(o$3-f$1)+a$3,L$1(f$1,a$3,l$2,Math.floor(n$3+.5),l$2,M$3,r$3),n$3=(t$3-h$3)*(i$3-e$3)/(o$3-e$3)+h$3,f$1=o$3=l$2,a$3=M$3,t$3=Math.floor(n$3+.5)),(a$3-t$3)*(h$3-t$3)>0&&(i$3=a$3-2*t$3+h$3,i$3=(a$3-t$3)/i$3,n$3=(1-i$3)*((1-i$3)*f$1+2*i$3*o$3)+i$3*i$3*e$3,i$3=(a$3*h$3-t$3*t$3)*i$3/(a$3-t$3),l$2=Math.floor(n$3+.5),M$3=Math.floor(i$3+.5),n$3=(o$3-f$1)*(i$3-a$3)/(t$3-a$3)+f$1,L$1(f$1,a$3,Math.floor(n$3+.5),M$3,l$2,M$3,r$3),n$3=(o$3-e$3)*(i$3-h$3)/(t$3-h$3)+e$3,f$1=l$2,o$3=Math.floor(n$3+.5),a$3=t$3=M$3),L$1(f$1,a$3,o$3,t$3,e$3,h$3,r$3)}function L$1(f$1,a$3,o$3,t$3,e$3,h$3,r$3){var l$2=e$3-o$3,M$3=h$3-t$3,i$3=f$1-o$3,n$3=a$3-t$3,c$2,q,d$2,b$3,s$2=i$3*M$3-n$3*l$2;if(I$2(i$3*l$2<=0&&n$3*M$3<=0,`sign of gradient must not change`),l$2*l$2+M$3*M$3>i$3*i$3+n$3*n$3&&(e$3=f$1,f$1=l$2+o$3,h$3=a$3,a$3=M$3+t$3,s$2=-s$2),s$2!=0){i$3+=l$2,i$3*=l$2=f$1<e$3?1:-1,n$3+=M$3,n$3*=M$3=a$3<h$3?1:-1,c$2=2*i$3*n$3,i$3*=i$3,n$3*=n$3,s$2*l$2*M$3<0&&(i$3=-i$3,n$3=-n$3,c$2=-c$2,s$2=-s$2),q=4*M$3*s$2*(o$3-f$1)+i$3-c$2,d$2=4*l$2*s$2*(a$3-t$3)+n$3-c$2,i$3+=i$3,n$3+=n$3,b$3=q+d$2+c$2;do{if(r$3(f$1,a$3),f$1==e$3&&a$3==h$3)return;t$3=+(2*b$3<q),2*b$3>d$2&&(f$1+=l$2,q-=c$2,b$3+=d$2+=n$3),t$3&&(a$3+=M$3,d$2-=c$2,b$3+=q+=i$3)}while(d$2<0&&q>0)}J(f$1,a$3,e$3,h$3,r$3)}function ia(f$1,a$3,o$3,t$3,e$3,h$3,r$3){var l$2=f$1-o$3,M$3=a$3-t$3,i$3=f$1-2*o$3+e$3,n$3;l$2*(e$3-o$3)>0&&(M$3*(h$3-t$3)>0&&Math.abs((a$3-2*t$3+h$3)/i$3*l$2)>Math.abs(M$3)&&(f$1=e$3,e$3=l$2+o$3,a$3=h$3,h$3=M$3+t$3),i$3=(f$1-o$3)/i$3,n$3=(1-i$3)*((1-i$3)*a$3+2*i$3*t$3)+i$3*i$3*h$3,i$3=(f$1*e$3-o$3*o$3)*i$3/(f$1-o$3),l$2=Math.floor(i$3+.5),M$3=Math.floor(n$3+.5),n$3=(t$3-a$3)*(i$3-f$1)/(o$3-f$1)+a$3,Q(f$1,a$3,l$2,Math.floor(n$3+.5),l$2,M$3,r$3),n$3=(t$3-h$3)*(i$3-e$3)/(o$3-e$3)+h$3,f$1=o$3=l$2,a$3=M$3,t$3=Math.floor(n$3+.5)),(a$3-t$3)*(h$3-t$3)>0&&(i$3=a$3-2*t$3+h$3,i$3=(a$3-t$3)/i$3,n$3=(1-i$3)*((1-i$3)*f$1+2*i$3*o$3)+i$3*i$3*e$3,i$3=(a$3*h$3-t$3*t$3)*i$3/(a$3-t$3),l$2=Math.floor(n$3+.5),M$3=Math.floor(i$3+.5),n$3=(o$3-f$1)*(i$3-a$3)/(t$3-a$3)+f$1,Q(f$1,a$3,Math.floor(n$3+.5),M$3,l$2,M$3,r$3),n$3=(o$3-e$3)*(i$3-h$3)/(t$3-h$3)+e$3,f$1=l$2,o$3=Math.floor(n$3+.5),a$3=t$3=M$3),Q(f$1,a$3,o$3,t$3,e$3,h$3,r$3)}function Q(f$1,a$3,o$3,t$3,e$3,h$3,r$3){var l$2=e$3-o$3,M$3=h$3-t$3,i$3=f$1-o$3,n$3=a$3-t$3,c$2,q,d$2,b$3,s$2,u$2=i$3*M$3-n$3*l$2;if(l$2*l$2+M$3*M$3>i$3*i$3+n$3*n$3&&(e$3=f$1,f$1=l$2+o$3,h$3=a$3,a$3=M$3+t$3,u$2=-u$2),u$2!=0){i$3+=l$2,i$3*=l$2=f$1<e$3?1:-1,n$3+=M$3,n$3*=M$3=a$3<h$3?1:-1,c$2=2*i$3*n$3,i$3*=i$3,n$3*=n$3,u$2*l$2*M$3<0&&(i$3=-i$3,n$3=-n$3,c$2=-c$2,u$2=-u$2),q=4*M$3*(o$3-f$1)*u$2+i$3-c$2,d$2=4*l$2*(a$3-t$3)*u$2+n$3-c$2,i$3+=i$3,n$3+=n$3,b$3=q+d$2+c$2;do{if(u$2=Math.min(q+c$2,-c$2-d$2),s$2=Math.max(q+c$2,-c$2-d$2),s$2+=2*s$2*u$2*u$2/(4*s$2*s$2+u$2*u$2),r$3(f$1,a$3,255*Math.abs(b$3-q-d$2-c$2)/s$2),f$1==e$3||a$3==h$3)break;o$3=f$1,u$2=q-b$3,t$3=+(2*b$3+d$2<0),2*b$3+q>0&&(b$3-d$2<s$2&&r$3(f$1,a$3+M$3,255*Math.abs(b$3-d$2)/s$2),f$1+=l$2,q-=c$2,b$3+=d$2+=n$3),t$3&&(u$2<s$2&&r$3(o$3+l$2,a$3,255*Math.abs(u$2)/s$2),a$3+=M$3,d$2-=c$2,b$3+=q+=i$3)}while(d$2<q)}U(f$1,a$3,e$3,h$3,r$3)}function _$1(f$1,a$3,o$3,t$3,e$3,h$3,r$3,l$2,M$3){var i$3,n$3,c$2,q=1;let d$2=f$1<r$3?1:-1,b$3=a$3<l$2?1:-1,s$2=-Math.abs(f$1+o$3-e$3-r$3),u$2=s$2-4*d$2*(o$3-e$3),z=d$2*(f$1-o$3-e$3+r$3),j$2=-Math.abs(a$3+t$3-h$3-l$2),B$1=j$2-4*b$3*(t$3-h$3),R$1=b$3*(a$3-t$3-h$3+l$2),p$3,S$2,W$1,T$1,G,E$2,O$1,v$2,g$1,k$2,F$1,D=.01;if(I$2((o$3-f$1)*(e$3-r$3)<D&&((r$3-f$1)*(o$3-e$3)<D||z*z<u$2*s$2+D),`slope change`),I$2((t$3-a$3)*(h$3-l$2)<D&&((l$2-a$3)*(t$3-h$3)<D||R$1*R$1<B$1*j$2+D),`slope change`),u$2==0&&B$1==0)return d$2=Math.floor((3*o$3-f$1+1)/2),b$3=Math.floor((3*t$3-a$3+1)/2),L$1(f$1,a$3,d$2,b$3,r$3,l$2,M$3);o$3=(o$3-f$1)*(o$3-f$1)+(t$3-a$3)*(t$3-a$3)+1,e$3=(e$3-r$3)*(e$3-r$3)+(h$3-l$2)*(h$3-l$2)+1;do{p$3=u$2*R$1-z*B$1,S$2=u$2*j$2-s$2*B$1,W$1=z*j$2-s$2*R$1,k$2=p$3*(p$3+S$2-3*W$1)+S$2*S$2,i$3=k$2>0?1:Math.sqrt(1+1024/o$3),p$3*=i$3,S$2*=i$3,W$1*=i$3,k$2*=i$3*i$3,E$2=9*(p$3+S$2+W$1)/8,T$1=8*(u$2-B$1),v$2=27*(8*p$3*(R$1*R$1-B$1*j$2)+k$2*(B$1+2*R$1+j$2))/64-B$1*B$1*(E$2-B$1),g$1=27*(8*p$3*(z*z-u$2*s$2)-k$2*(u$2+2*z+s$2))/64-u$2*u$2*(E$2+u$2),G=3*(3*p$3*(3*R$1*R$1-B$1*B$1-2*B$1*j$2)-B$1*(3*S$2*(B$1+R$1)+B$1*T$1))/4,O$1=3*(3*p$3*(3*z*z-u$2*u$2-2*u$2*s$2)-u$2*(3*S$2*(u$2+z)+u$2*T$1))/4,E$2=u$2*B$1*(6*p$3+6*S$2-3*W$1+T$1),S$2=B$1*B$1,T$1=u$2*u$2,E$2=3*(E$2+9*i$3*(T$1*R$1*j$2-z*s$2*S$2)-18*z*R$1*p$3)/8,k$2<0&&(v$2=-v$2,g$1=-g$1,G=-G,O$1=-O$1,E$2=-E$2,S$2=-S$2,T$1=-T$1),p$3=6*B$1*S$2,S$2=-6*u$2*S$2,W$1=6*B$1*T$1,T$1=-6*u$2*T$1,v$2+=E$2,k$2=v$2+g$1,g$1+=E$2;a:for(F$1=E$2,n$3=c$2=i$3;f$1!=r$3&&a$3!=l$2;){M$3(f$1,a$3);do{if(v$2>F$1||g$1<F$1)break a;t$3=2*k$2-g$1,2*k$2>=v$2&&(n$3--,k$2+=v$2+=G,g$1+=E$2+=S$2,O$1+=W$1,G+=p$3),t$3<=0&&(c$2--,k$2+=g$1+=O$1,v$2+=E$2+=W$1,G+=S$2,O$1+=T$1)}while(n$3>0&&c$2>0);2*n$3<=i$3&&(f$1+=d$2,n$3+=i$3),2*c$2<=i$3&&(a$3+=b$3,c$2+=i$3),F$1==E$2&&v$2<0&&g$1>0&&(F$1=D)}G=f$1,f$1=r$3,r$3=G,d$2=-d$2,z=-z,O$1=a$3,a$3=l$2,l$2=O$1,b$3=-b$3,R$1=-R$1,o$3=e$3}while(q--);J(f$1,a$3,r$3,l$2,M$3)}function $$2(f$1,a$3,o$3,t$3,e$3,h$3,r$3,l$2,M$3){let i$3,n$3,c$2,q=1,d$2=f$1<r$3?1:-1,b$3=a$3<l$2?1:-1,s$2=-Math.abs(f$1+o$3-e$3-r$3),u$2=s$2-4*d$2*(o$3-e$3),z=d$2*(f$1-o$3-e$3+r$3),j$2=-Math.abs(a$3+t$3-h$3-l$2),B$1=j$2-4*b$3*(t$3-h$3),R$1=b$3*(a$3-t$3-h$3+l$2),p$3,S$2,W$1,T$1,G,E$2,O$1,v$2,g$1,k$2,F$1,D,C,A$1,K$1=.01;if(I$2((o$3-f$1)*(e$3-r$3)<K$1&&((r$3-f$1)*(o$3-e$3)<K$1||z*z<u$2*s$2+K$1)),I$2((t$3-a$3)*(h$3-l$2)<K$1&&((l$2-a$3)*(t$3-h$3)<K$1||R$1*R$1<B$1*j$2+K$1)),u$2===0&&B$1===0)return d$2=Math.floor((3*o$3-f$1+1)/2),b$3=Math.floor((3*t$3-a$3+1)/2),Q(f$1,a$3,d$2,b$3,r$3,l$2,M$3);o$3=(o$3-f$1)*(o$3-f$1)+(t$3-a$3)*(t$3-a$3)+1,e$3=(e$3-r$3)*(e$3-r$3)+(h$3-l$2)*(h$3-l$2)+1;do{p$3=u$2*R$1-z*B$1,S$2=u$2*j$2-s$2*B$1,W$1=z*j$2-s$2*R$1,A$1=4*p$3*W$1-S$2*S$2,k$2=p$3*(p$3+S$2-3*W$1)+S$2*S$2,i$3=k$2>0?1:Math.sqrt(1+1024/o$3),p$3*=i$3,S$2*=i$3,W$1*=i$3,k$2*=i$3*i$3,E$2=9*(p$3+S$2+W$1)/8,T$1=8*(u$2-B$1),v$2=27*(8*p$3*(R$1*R$1-B$1*j$2)+k$2*(B$1+2*R$1+j$2))/64-B$1*B$1*(E$2-B$1),g$1=27*(8*p$3*(z*z-u$2*s$2)-k$2*(u$2+2*z+s$2))/64-u$2*u$2*(E$2+u$2),G=3*(3*p$3*(3*R$1*R$1-B$1*B$1-2*B$1*j$2)-B$1*(3*S$2*(B$1+R$1)+B$1*T$1))/4,O$1=3*(3*p$3*(3*z*z-u$2*u$2-2*u$2*s$2)-u$2*(3*S$2*(u$2+z)+u$2*T$1))/4,E$2=u$2*B$1*(6*p$3+6*S$2-3*W$1+T$1),S$2=B$1*B$1,T$1=u$2*u$2,E$2=3*(E$2+9*i$3*(T$1*R$1*j$2-z*s$2*S$2)-18*z*R$1*p$3)/8,k$2<0&&(v$2=-v$2,g$1=-g$1,G=-G,O$1=-O$1,E$2=-E$2,S$2=-S$2,T$1=-T$1),p$3=6*B$1*S$2,S$2=-6*u$2*S$2,W$1=6*B$1*T$1,T$1=-6*u$2*T$1,v$2+=E$2,k$2=v$2+g$1,g$1+=E$2;let X=!1;a:for(n$3=c$2=i$3;f$1!==r$3&&a$3!==l$2;){t$3=Math.min(Math.abs(E$2-v$2),Math.abs(g$1-E$2)),C=Math.max(Math.abs(E$2-v$2),Math.abs(g$1-E$2)),C=i$3*(C+2*C*t$3*t$3/(4*C*C+t$3*t$3)),t$3=255*Math.abs(k$2-(i$3-n$3+1)*v$2-(i$3-c$2+1)*g$1+i$3*E$2)/C,t$3<256&&M$3(f$1,a$3,t$3),F$1=Math.abs(k$2-(i$3-n$3+1)*v$2+(c$2-1)*g$1),D=Math.abs(k$2+(n$3-1)*v$2-(i$3-c$2+1)*g$1),h$3=a$3;do{if(A$1>=-K$1&&(v$2+G>E$2||g$1+O$1<E$2)){X=!0;break a}if(t$3=2*k$2+v$2,2*k$2+g$1>0)n$3--,k$2+=v$2+=G,g$1+=E$2+=S$2,O$1+=W$1,G+=p$3;else if(t$3>0){X=!0;break a}t$3<=0&&(c$2--,k$2+=g$1+=O$1,v$2+=E$2+=W$1,G+=S$2,O$1+=T$1)}while(n$3>0&&c$2>0);2*c$2<=i$3&&(D<C&&M$3(f$1+d$2,a$3,255*D/C),a$3+=b$3,c$2+=i$3),2*n$3<=i$3&&(F$1<C&&M$3(f$1,h$3+b$3,255*F$1/C),f$1+=d$2,n$3+=i$3)}X&&(2*k$2<g$1&&2*c$2<=i$3+2&&(D<C&&M$3(f$1+d$2,a$3,255*D/C),a$3+=b$3),2*k$2>v$2&&2*n$3<=i$3+2&&(F$1<C&&M$3(f$1,h$3+b$3,255*F$1/C),f$1+=d$2),G=f$1,f$1=r$3,r$3=G,d$2=-d$2,z=-z,O$1=a$3,a$3=l$2,l$2=O$1,b$3=-b$3,R$1=-R$1,o$3=e$3);break}while(q--);U(Math.floor(f$1),Math.floor(a$3),Math.floor(r$3),Math.floor(l$2),M$3)}function m$1(f$1,a$3,o$3,t$3,e$3,h$3,r$3,l$2,M$3,i$3){let n$3=0,c$2=0,q=f$1+o$3-e$3-r$3,d$2=q-4*(o$3-e$3),b$3=f$1-o$3-e$3+r$3,s$2=b$3+4*(o$3+e$3),u$2=a$3+t$3-h$3-l$2,z=u$2-4*(t$3-h$3),j$2=a$3-t$3-h$3+l$2,B$1=j$2+4*(t$3+h$3);var R$1=f$1,p$3,S$2,W$1,T$1=a$3,G,E$2,O$1;let v$2=b$3*b$3-d$2*q,g$1,k$2=[0,0,0,0,0];for(d$2==0?Math.abs(q)<2*Math.abs(b$3)&&(k$2[n$3++]=q/(2*b$3)):v$2>0&&(g$1=Math.sqrt(v$2),v$2=(b$3-g$1)/d$2,Math.abs(v$2)<1&&(k$2[n$3++]=v$2),v$2=(b$3+g$1)/d$2,Math.abs(v$2)<1&&(k$2[n$3++]=v$2)),v$2=j$2*j$2-z*u$2,z==0?Math.abs(u$2)<2*Math.abs(j$2)&&(k$2[n$3++]=u$2/(2*j$2)):v$2>0&&(g$1=Math.sqrt(v$2),v$2=(j$2-g$1)/z,Math.abs(v$2)<1&&(k$2[n$3++]=v$2),v$2=(j$2+g$1)/z,Math.abs(v$2)<1&&(k$2[n$3++]=v$2)),c$2=1;c$2<n$3;c$2++)(v$2=k$2[c$2-1])>k$2[c$2]&&(k$2[c$2-1]=k$2[c$2],k$2[c$2]=v$2,c$2=0);for(v$2=-1,k$2[n$3]=1,c$2=0;c$2<=n$3;c$2++)g$1=k$2[c$2],p$3=(v$2*(v$2*b$3-2*q)-g$1*(v$2*(v$2*d$2-2*b$3)+q)+s$2)/8-R$1,G=(v$2*(v$2*j$2-2*u$2)-g$1*(v$2*(v$2*z-2*j$2)+u$2)+B$1)/8-T$1,S$2=(g$1*(g$1*b$3-2*q)-v$2*(g$1*(g$1*d$2-2*b$3)+q)+s$2)/8-R$1,E$2=(g$1*(g$1*j$2-2*u$2)-v$2*(g$1*(g$1*z-2*j$2)+u$2)+B$1)/8-T$1,R$1-=W$1=(g$1*(g$1*(3*b$3-g$1*d$2)-3*q)+s$2)/8,T$1-=O$1=(g$1*(g$1*(3*j$2-g$1*z)-3*u$2)+B$1)/8,r$3=Math.floor(W$1+.5),l$2=Math.floor(O$1+.5),R$1!=0&&(p$3*=R$1=(f$1-r$3)/R$1,S$2*=R$1),T$1!=0&&(G*=T$1=(a$3-l$2)/T$1,E$2*=T$1),(f$1!=r$3||a$3!=l$2)&&M$3(f$1,a$3,f$1+p$3,a$3+G,f$1+S$2,a$3+E$2,r$3,l$2,i$3),f$1=r$3,a$3=l$2,R$1=W$1,T$1=O$1,v$2=g$1}function ra(f$1,a$3,o$3,t$3,e$3,h$3,r$3,l$2,M$3){m$1(f$1,a$3,o$3,t$3,e$3,h$3,r$3,l$2,_$1,M$3)}function oa(f$1,a$3,o$3,t$3,e$3,h$3,r$3,l$2,M$3){m$1(f$1,a$3,o$3,t$3,e$3,h$3,r$3,l$2,$$2,M$3)}N$2.circle=aa,N$2.circleAA=fa,N$2.cubicBezier=ra,N$2.cubicBezierAA=oa,N$2.cubicBezierSegment=_$1,N$2.cubicBezierSegmentAA=$$2,N$2.ellipse=y$2,N$2.ellipseRect=Z,N$2.line=J,N$2.lineAA=U,N$2.lineWidth=w$3,N$2.quadBezier=ta,N$2.quadBezierAA=ia,N$2.quadBezierSegment=L$1,N$2.quadBezierSegmentAA=Q,N$2.quadRationalBezier=P$1,N$2.quadRationalBezierSegment=H$1,N$2.quadRationalBezierSegmentAA=V,N$2.rotatedEllipse=x$2,N$2.rotatedEllipseRect=Y,Object.defineProperty(N$2,Symbol.toStringTag,{value:`Module`})}))}));function deleteDuplicates(points){let finalPoints=[];for(let i$3=0;i$3<points.length;i$3++)if(points[i$3].column===points[(i$3+1)%points.length].column&&points[i$3].row===points[(i$3+1)%points.length].row)continue;else finalPoints.push(points[i$3]);return finalPoints}var import_index_umd$3=__toESM(require_index_umd());function getIndex(column,row,image,channel=0){return(row*image.width+column)*image.channels+channel}var formatter=new Intl.ListFormat(`en`,{type:`disjunction`});function checkProcessable(image,options={}){let{bitDepth,alpha,colorModel,components,channels}=options;if(bitDepth&&(Array.isArray(bitDepth)||(bitDepth=[bitDepth]),!bitDepth.includes(image.bitDepth)))throw RangeError(`image bitDepth must be ${format(bitDepth)} to apply this algorithm`);if(alpha&&(Array.isArray(alpha)||(alpha=[alpha]),!alpha.includes(image.alpha)))throw RangeError(`image alpha must be ${format(alpha)} to apply this algorithm`);if(colorModel&&(Array.isArray(colorModel)||(colorModel=[colorModel]),!colorModel.includes(image.colorModel)))throw RangeError(`image colorModel must be ${format(colorModel)} to apply this algorithm`);if(components&&(Array.isArray(components)||(components=[components]),!components.includes(image.components))){let errorMessage=`image components must be ${format(components)} to apply this algorithm`;throw components.length===1&&components[0]===1?RangeError(`${errorMessage}. The image can be converted using "image.grey()"`):RangeError(errorMessage)}if(channels&&(Array.isArray(channels)||(channels=[channels]),!channels.includes(image.channels)))throw RangeError(`image channels must be ${format(channels)} to apply this algorithm`)}function format(array){return formatter.format(array.map(String))}const SOBEL_X=[[-1,0,1],[-2,0,2],[-1,0,1]],SOBEL_Y=[[-1,-2,-1],[0,0,0],[1,2,1]],SCHARR_X=[[3,0,-3],[10,0,-10],[3,0,-3]],SCHARR_Y=[[3,10,3],[0,0,0],[-3,-10,-3]],PREWITT_X=[[1,0,-1],[1,0,-1],[1,0,-1]],PREWITT_Y=[[1,1,1],[0,0,0],[-1,-1,-1]];init_lib_esm();function xMedian(input,options={}){if(!isAnyArray(input))throw TypeError(`input must be an array`);if(input.length===0)throw TypeError(`input must not be empty`);let{exact=!1}=options||{},array=input.slice(),middleIndex=calcMiddle(0,array.length-1),median$1=quickSelect(array,middleIndex);if(array.length%2==1||!exact)return median$1;let medianNext=quickSelect(array,middleIndex+1);return(median$1+medianNext)/2}function quickSelect(array,middleIndex){let low=0,high=array.length-1,middle=0,currentLow=0,currentHigh=0;for(;;){if(high<=low)return array[middleIndex];if(high===low+1)return array[low]>array[high]&&swap(array,low,high),array[middleIndex];for(middle=calcMiddle(low,high),array[middle]>array[high]&&swap(array,middle,high),array[low]>array[high]&&swap(array,low,high),array[middle]>array[low]&&swap(array,middle,low),swap(array,middle,low+1),currentLow=low+1,currentHigh=high;;){do currentLow++;while(array[low]>array[currentLow]);do currentHigh--;while(array[currentHigh]>array[low]);if(currentHigh<currentLow)break;swap(array,currentLow,currentHigh)}swap(array,low,currentHigh),currentHigh<=middleIndex&&(low=currentLow),currentHigh>=middleIndex&&(high=currentHigh-1)}}function swap(array,i$3,j$2){let temp=array[j$2];array[j$2]=array[i$3],array[i$3]=temp}function calcMiddle(i$3,j$2){return Math.floor((i$3+j$2)/2)}var require_fft=__commonJSMin(((exports,module)=>{function FFT$3(size){if(this.size=size|0,this.size<=1||this.size&this.size-1)throw Error(`FFT size must be a power of two and bigger than 1`);this._csize=size<<1;for(var table=Array(this.size*2),i$3=0;i$3<table.length;i$3+=2){let angle=Math.PI*i$3/this.size;table[i$3]=Math.cos(angle),table[i$3+1]=-Math.sin(angle)}this.table=table;for(var power=0,t$3=1;this.size>t$3;t$3<<=1)power++;this._width=power%2==0?power-1:power,this._bitrev=Array(1<<this._width);for(var j$2=0;j$2<this._bitrev.length;j$2++){this._bitrev[j$2]=0;for(var shift=0;shift<this._width;shift+=2){var revShift=this._width-shift-2;this._bitrev[j$2]|=(j$2>>>shift&3)<<revShift}}this._out=null,this._data=null,this._inv=0}module.exports=FFT$3,FFT$3.prototype.fromComplexArray=function(complex,storage){for(var res=storage||Array(complex.length>>>1),i$3=0;i$3<complex.length;i$3+=2)res[i$3>>>1]=complex[i$3];return res},FFT$3.prototype.createComplexArray=function(){let res=Array(this._csize);for(var i$3=0;i$3<res.length;i$3++)res[i$3]=0;return res},FFT$3.prototype.toComplexArray=function(input,storage){for(var res=storage||this.createComplexArray(),i$3=0;i$3<res.length;i$3+=2)res[i$3]=input[i$3>>>1],res[i$3+1]=0;return res},FFT$3.prototype.completeSpectrum=function(spectrum){for(var size=this._csize,half=size>>>1,i$3=2;i$3<half;i$3+=2)spectrum[size-i$3]=spectrum[i$3],spectrum[size-i$3+1]=-spectrum[i$3+1]},FFT$3.prototype.transform=function(out,data){if(out===data)throw Error(`Input and output buffers must be different`);this._out=out,this._data=data,this._inv=0,this._transform4(),this._out=null,this._data=null},FFT$3.prototype.realTransform=function(out,data){if(out===data)throw Error(`Input and output buffers must be different`);this._out=out,this._data=data,this._inv=0,this._realTransform4(),this._out=null,this._data=null},FFT$3.prototype.inverseTransform=function(out,data){if(out===data)throw Error(`Input and output buffers must be different`);this._out=out,this._data=data,this._inv=1,this._transform4();for(var i$3=0;i$3<out.length;i$3++)out[i$3]/=this.size;this._out=null,this._data=null},FFT$3.prototype._transform4=function(){var out=this._out,size=this._csize,step=1<<this._width,len=size/step<<1,outOff,t$3,bitrev=this._bitrev;if(len===4)for(outOff=0,t$3=0;outOff<size;outOff+=len,t$3++){let off=bitrev[t$3];this._singleTransform2(outOff,off,step)}else for(outOff=0,t$3=0;outOff<size;outOff+=len,t$3++){let off=bitrev[t$3];this._singleTransform4(outOff,off,step)}var inv=this._inv?-1:1,table=this.table;for(step>>=2;step>=2;step>>=2){len=size/step<<1;var quarterLen=len>>>2;for(outOff=0;outOff<size;outOff+=len)for(var limit=outOff+quarterLen,i$3=outOff,k$2=0;i$3<limit;i$3+=2,k$2+=step){let A$1=i$3,B$1=A$1+quarterLen,C=B$1+quarterLen,D=C+quarterLen,Ar=out[A$1],Ai=out[A$1+1],Br=out[B$1],Bi=out[B$1+1],Cr=out[C],Ci=out[C+1],Dr=out[D],Di=out[D+1],MAr=Ar,MAi=Ai,tableBr=table[k$2],tableBi=inv*table[k$2+1],MBr=Br*tableBr-Bi*tableBi,MBi=Br*tableBi+Bi*tableBr,tableCr=table[2*k$2],tableCi=inv*table[2*k$2+1],MCr=Cr*tableCr-Ci*tableCi,MCi=Cr*tableCi+Ci*tableCr,tableDr=table[3*k$2],tableDi=inv*table[3*k$2+1],MDr=Dr*tableDr-Di*tableDi,MDi=Dr*tableDi+Di*tableDr,T0r=MAr+MCr,T0i=MAi+MCi,T1r=MAr-MCr,T1i=MAi-MCi,T2r=MBr+MDr,T2i=MBi+MDi,T3r=inv*(MBr-MDr),T3i=inv*(MBi-MDi),FAr=T0r+T2r,FAi=T0i+T2i,FCr=T0r-T2r,FCi=T0i-T2i,FBr=T1r+T3i,FBi=T1i-T3r,FDr=T1r-T3i,FDi=T1i+T3r;out[A$1]=FAr,out[A$1+1]=FAi,out[B$1]=FBr,out[B$1+1]=FBi,out[C]=FCr,out[C+1]=FCi,out[D]=FDr,out[D+1]=FDi}}},FFT$3.prototype._singleTransform2=function(outOff,off,step){let out=this._out,data=this._data,evenR=data[off],evenI=data[off+1],oddR=data[off+step],oddI=data[off+step+1],leftR=evenR+oddR,leftI=evenI+oddI,rightR=evenR-oddR,rightI=evenI-oddI;out[outOff]=leftR,out[outOff+1]=leftI,out[outOff+2]=rightR,out[outOff+3]=rightI},FFT$3.prototype._singleTransform4=function(outOff,off,step){let out=this._out,data=this._data,inv=this._inv?-1:1,step2=step*2,step3=step*3,Ar=data[off],Ai=data[off+1],Br=data[off+step],Bi=data[off+step+1],Cr=data[off+step2],Ci=data[off+step2+1],Dr=data[off+step3],Di=data[off+step3+1],T0r=Ar+Cr,T0i=Ai+Ci,T1r=Ar-Cr,T1i=Ai-Ci,T2r=Br+Dr,T2i=Bi+Di,T3r=inv*(Br-Dr),T3i=inv*(Bi-Di),FAr=T0r+T2r,FAi=T0i+T2i,FBr=T1r+T3i,FBi=T1i-T3r,FCr=T0r-T2r,FCi=T0i-T2i,FDr=T1r-T3i,FDi=T1i+T3r;out[outOff]=FAr,out[outOff+1]=FAi,out[outOff+2]=FBr,out[outOff+3]=FBi,out[outOff+4]=FCr,out[outOff+5]=FCi,out[outOff+6]=FDr,out[outOff+7]=FDi},FFT$3.prototype._realTransform4=function(){var out=this._out,size=this._csize,step=1<<this._width,len=size/step<<1,outOff,t$3,bitrev=this._bitrev;if(len===4)for(outOff=0,t$3=0;outOff<size;outOff+=len,t$3++){let off=bitrev[t$3];this._singleRealTransform2(outOff,off>>>1,step>>>1)}else for(outOff=0,t$3=0;outOff<size;outOff+=len,t$3++){let off=bitrev[t$3];this._singleRealTransform4(outOff,off>>>1,step>>>1)}var inv=this._inv?-1:1,table=this.table;for(step>>=2;step>=2;step>>=2){len=size/step<<1;var halfLen=len>>>1,quarterLen=halfLen>>>1,hquarterLen=quarterLen>>>1;for(outOff=0;outOff<size;outOff+=len)for(var i$3=0,k$2=0;i$3<=hquarterLen;i$3+=2,k$2+=step){var A$1=outOff+i$3,B$1=A$1+quarterLen,C=B$1+quarterLen,D=C+quarterLen,Ar=out[A$1],Ai=out[A$1+1],Br=out[B$1],Bi=out[B$1+1],Cr=out[C],Ci=out[C+1],Dr=out[D],Di=out[D+1],MAr=Ar,MAi=Ai,tableBr=table[k$2],tableBi=inv*table[k$2+1],MBr=Br*tableBr-Bi*tableBi,MBi=Br*tableBi+Bi*tableBr,tableCr=table[2*k$2],tableCi=inv*table[2*k$2+1],MCr=Cr*tableCr-Ci*tableCi,MCi=Cr*tableCi+Ci*tableCr,tableDr=table[3*k$2],tableDi=inv*table[3*k$2+1],MDr=Dr*tableDr-Di*tableDi,MDi=Dr*tableDi+Di*tableDr,T0r=MAr+MCr,T0i=MAi+MCi,T1r=MAr-MCr,T1i=MAi-MCi,T2r=MBr+MDr,T2i=MBi+MDi,T3r=inv*(MBr-MDr),T3i=inv*(MBi-MDi),FAr=T0r+T2r,FAi=T0i+T2i,FBr=T1r+T3i,FBi=T1i-T3r;if(out[A$1]=FAr,out[A$1+1]=FAi,out[B$1]=FBr,out[B$1+1]=FBi,i$3===0){var FCr=T0r-T2r,FCi=T0i-T2i;out[C]=FCr,out[C+1]=FCi;continue}if(i$3!==hquarterLen){var ST0r=T1r,ST0i=-T1i,ST1r=T0r,ST1i=-T0i,ST2r=-inv*T3i,ST2i=-inv*T3r,ST3r=-inv*T2i,ST3i=-inv*T2r,SFAr=ST0r+ST2r,SFAi=ST0i+ST2i,SFBr=ST1r+ST3i,SFBi=ST1i-ST3r,SA=outOff+quarterLen-i$3,SB=outOff+halfLen-i$3;out[SA]=SFAr,out[SA+1]=SFAi,out[SB]=SFBr,out[SB+1]=SFBi}}}},FFT$3.prototype._singleRealTransform2=function(outOff,off,step){let out=this._out,data=this._data,evenR=data[off],oddR=data[off+step],leftR=evenR+oddR,rightR=evenR-oddR;out[outOff]=leftR,out[outOff+1]=0,out[outOff+2]=rightR,out[outOff+3]=0},FFT$3.prototype._singleRealTransform4=function(outOff,off,step){let out=this._out,data=this._data,inv=this._inv?-1:1,step2=step*2,step3=step*3,Ar=data[off],Br=data[off+step],Cr=data[off+step2],Dr=data[off+step3],T0r=Ar+Cr,T1r=Ar-Cr,T2r=Br+Dr,T3r=inv*(Br-Dr),FAr=T0r+T2r,FBr=T1r,FBi=-T3r,FCr=T0r-T2r,FDr=T1r,FDi=T3r;out[outOff]=FAr,out[outOff+1]=0,out[outOff+2]=FBr,out[outOff+3]=FBi,out[outOff+4]=FCr,out[outOff+5]=0,out[outOff+6]=FDr,out[outOff+7]=FDi}})),FLOAT_MUL=1/16777216,import_fft$2=__toESM(require_fft()),import_fft$1=__toESM(require_fft());function assert(value,message){if(!value)throw Error(message||`unreachable`)}function assertUnreachable(x$2){throw Error(`unreachable: ${String(x$2)}`)}function getClamp(image){return image.maxValue===255?clamp255:(assert(image.maxValue===65535),clamp65535)}function clamp255(value){return Math.min(Math.max(value,0),255)}function clamp65535(value){return Math.min(Math.max(value,0),65535)}function validateChannels(channels,image){for(let channel of channels)validateChannel(channel,image)}function validateChannel(channel,image){if(!Number.isInteger(channel)||channel>=image.channels||channel<0)throw RangeError(`invalid channel: ${channel}. It must be a positive integer smaller than ${image.channels}`)}function validateValues(values,image){for(let value of values)validateValue(value,image)}function validateValue(value,image){if(value>image.maxValue||value<0)throw RangeError(`invalid value: ${value}. It must be a positive value smaller than ${image.maxValue+1}`)}function validateForComparison(image,other){if(image.width!==other.width||image.height!==other.height)throw RangeError(`both images must have the same size`);if(image.alpha!==other.alpha||image.bitDepth!==other.bitDepth)throw RangeError(`both images must have the same alpha and bitDepth`);if(image.channels!==other.channels)throw RangeError(`both images must have the same number of channels`)}function validateColor(color,image){validateChannel(color.length-1,image),validateValues(color,image)}function divide(image,value,options={}){let{channels=Array(image.channels).fill(0).map((value$1,index)=>index)}=options;if(validateChannels(channels,image),value===0)throw TypeError(`Cannot divide by 0`);let newImage=getOutputImage(image,options,{clone:!0});if(channels.length===0)return newImage;for(let channel of channels)for(let row=0;row<newImage.height;row++)for(let column=0;column<newImage.width;column++){let newIntensity=newImage.getValue(column,row,channel)/value;newImage.setClampedValue(column,row,channel,newIntensity)}return newImage}function getDefaultColor(image){return M(image.colorModel).with(`GREY`,()=>[0]).with(`GREYA`,()=>[0,image.maxValue]).with(`RGB`,()=>[0,0,0]).with(`RGBA`,()=>[0,0,0,image.maxValue]).with(`BINARY`,()=>[1]).exhaustive()}function setBlendedPixel(image,column,row,color){if(color??=getDefaultColor(image),!image.alpha)image.setPixel(column,row,color);else{assert(image instanceof Image);let sourceAlpha=color.at(-1);if(sourceAlpha===image.maxValue){image.setPixel(column,row,color);return}let targetAlpha=image.getValue(column,row,image.channels-1),newAlpha=sourceAlpha+targetAlpha*(1-sourceAlpha/image.maxValue);image.setValue(column,row,image.channels-1,newAlpha);for(let component=0;component<image.components;component++){let sourceComponent=color[component],targetComponent=image.getValue(column,row,component),newComponent=(sourceComponent*sourceAlpha+targetComponent*targetAlpha*(1-sourceAlpha/image.maxValue))/newAlpha;image.setValue(column,row,component,newComponent)}}}function setBlendedVisiblePixel(image,column,row,color){column>=0&&column<image.width&&row>=0&&row<image.height&&setBlendedPixel(image,column,row,color)}function roundPoint(point){return{row:Math.round(point.row),column:Math.round(point.column)}}var import_index_umd$2=__toESM(require_index_umd());function drawCircleOnImage(image,center,radius,options={}){let newImage=getOutputImage(image,options,{clone:!0}),{strokeColor=getDefaultColor(newImage),fillColor}=options;if(validateColor(strokeColor,newImage),checkProcessable(newImage,{bitDepth:[8,16]}),radius<0)throw RangeError(`circle radius must be positive`);if(center=roundPoint(center),radius=Math.round(radius),radius===0)return setBlendedVisiblePixel(newImage,center.column,center.row,strokeColor),newImage;if(!fillColor)(0,import_index_umd$2.circle)(center.column,center.row,radius,(column,row)=>{setBlendedVisiblePixel(newImage,column,row,strokeColor)});else{radius===1&&setBlendedVisiblePixel(newImage,center.column,center.row,fillColor);let prevRow=center.row+radius,index=0;(0,import_index_umd$2.circle)(center.column,center.row,radius,(column,row)=>{setBlendedVisiblePixel(newImage,column,row,strokeColor),index===0&&newImage.drawLine({row,column:column-1},{row,column:center.column-(column-center.column-1)},{strokeColor:fillColor,out:newImage}),index%4==1&&prevRow!==row&&(newImage.drawLine({row,column:column+1},{row,column:center.column-(column-center.column+1)},{strokeColor:fillColor,out:newImage}),prevRow=row,newImage.drawLine({row:center.row-(row-center.row),column:column+1},{row:center.row-(row-center.row),column:center.column-(column-center.column+1)},{strokeColor:fillColor,out:newImage})),index++})}return newImage}var import_index_umd$1=__toESM(require_index_umd());function drawLineOnImage(image,from,to,options={}){let newImage=getOutputImage(image,options,{clone:!0}),{strokeColor=getDefaultColor(newImage),origin={column:0,row:0}}=options;return validateColor(strokeColor,newImage),checkProcessable(newImage,{bitDepth:[8,16]}),(0,import_index_umd$1.line)(Math.round(origin.column+from.column),Math.round(origin.row+from.row),Math.round(origin.column+to.column),Math.round(origin.row+to.row),(column,row)=>{setBlendedVisiblePixel(newImage,column,row,strokeColor)}),newImage}var import_index_umd=__toESM(require_index_umd());function drawLineOnMask(mask,from,to,options={}){let{origin={column:0,row:0}}=options,newMask=maskToOutputMask(mask,options,{clone:!0});return(0,import_index_umd.line)(Math.round(origin.column+from.column),Math.round(origin.row+from.row),Math.round(origin.column+to.column),Math.round(origin.row+to.row),(column,row)=>{newMask.setVisiblePixel(column,row,[1])}),newMask}function drawPolylineOnImage(image,points,options={}){let{strokeColor:color=getDefaultColor(image),origin={column:0,row:0}}=options;checkProcessable(image,{bitDepth:[8,16]});let newImage=getOutputImage(image,options,{clone:!0});validateColor(color,newImage);for(let i$3=0;i$3<points.length-1;i$3++){let from=points[i$3],to=points[i$3+1];newImage.drawLine(from,to,{out:newImage,strokeColor:color,origin})}return newImage}function drawPolylineOnMask(mask,points,options={}){let newImage=maskToOutputMask(mask,options,{clone:!0});for(let i$3=0;i$3<points.length-1;i$3++){let from=points[i$3],to=points[i$3+1];newImage.drawLine(from,to,{out:newImage,origin:options.origin})}return newImage}var require_two_product=__commonJSMin(((exports,module)=>{module.exports=twoProduct$2;var SPLITTER=+(2**27+1);function twoProduct$2(a$3,b$3,result){var x$2=a$3*b$3,c$2=SPLITTER*a$3,abig=c$2-a$3,ahi=c$2-abig,alo=a$3-ahi,d$2=SPLITTER*b$3,bbig=d$2-b$3,bhi=d$2-bbig,blo=b$3-bhi,err3=x$2-ahi*bhi-alo*bhi-ahi*blo,y$2=alo*blo-err3;return result?(result[0]=y$2,result[1]=x$2,result):[y$2,x$2]}})),require_robust_sum=__commonJSMin(((exports,module)=>{module.exports=linearExpansionSum;function scalarScalar$1(a$3,b$3){var x$2=a$3+b$3,bv=x$2-a$3,av=x$2-bv,br=b$3-bv,y$2=a$3-av+br;return y$2?[y$2,x$2]:[x$2]}function linearExpansionSum(e$3,f$1){var ne=e$3.length|0,nf=f$1.length|0;if(ne===1&&nf===1)return scalarScalar$1(e$3[0],f$1[0]);var n$3=ne+nf,g$1=Array(n$3),count=0,eptr=0,fptr=0,abs=Math.abs,ei=e$3[eptr],ea=abs(ei),fi=f$1[fptr],fa=abs(fi),a$3,b$3;ea<fa?(b$3=ei,eptr+=1,eptr<ne&&(ei=e$3[eptr],ea=abs(ei))):(b$3=fi,fptr+=1,fptr<nf&&(fi=f$1[fptr],fa=abs(fi))),eptr<ne&&ea<fa||fptr>=nf?(a$3=ei,eptr+=1,eptr<ne&&(ei=e$3[eptr],ea=abs(ei))):(a$3=fi,fptr+=1,fptr<nf&&(fi=f$1[fptr],fa=abs(fi)));for(var x$2=a$3+b$3,bv=x$2-a$3,y$2=b$3-bv,q0=y$2,q1=x$2,_x,_bv,_av,_br,_ar;eptr<ne&&fptr<nf;)ea<fa?(a$3=ei,eptr+=1,eptr<ne&&(ei=e$3[eptr],ea=abs(ei))):(a$3=fi,fptr+=1,fptr<nf&&(fi=f$1[fptr],fa=abs(fi))),b$3=q0,x$2=a$3+b$3,bv=x$2-a$3,y$2=b$3-bv,y$2&&(g$1[count++]=y$2),_x=q1+x$2,_bv=_x-q1,_av=_x-_bv,_br=x$2-_bv,_ar=q1-_av,q0=_ar+_br,q1=_x;for(;eptr<ne;)a$3=ei,b$3=q0,x$2=a$3+b$3,bv=x$2-a$3,y$2=b$3-bv,y$2&&(g$1[count++]=y$2),_x=q1+x$2,_bv=_x-q1,_av=_x-_bv,_br=x$2-_bv,_ar=q1-_av,q0=_ar+_br,q1=_x,eptr+=1,eptr<ne&&(ei=e$3[eptr]);for(;fptr<nf;)a$3=fi,b$3=q0,x$2=a$3+b$3,bv=x$2-a$3,y$2=b$3-bv,y$2&&(g$1[count++]=y$2),_x=q1+x$2,_bv=_x-q1,_av=_x-_bv,_br=x$2-_bv,_ar=q1-_av,q0=_ar+_br,q1=_x,fptr+=1,fptr<nf&&(fi=f$1[fptr]);return q0&&(g$1[count++]=q0),q1&&(g$1[count++]=q1),count||(g$1[count++]=0),g$1.length=count,g$1}})),require_two_sum=__commonJSMin(((exports,module)=>{module.exports=fastTwoSum;function fastTwoSum(a$3,b$3,result){var x$2=a$3+b$3,bv=x$2-a$3,av=x$2-bv,br=b$3-bv,ar=a$3-av;return result?(result[0]=ar+br,result[1]=x$2,result):[ar+br,x$2]}})),require_robust_scale=__commonJSMin(((exports,module)=>{var twoProduct$1=require_two_product(),twoSum=require_two_sum();module.exports=scaleLinearExpansion;function scaleLinearExpansion(e$3,scale){var n$3=e$3.length;if(n$3===1){var ts=twoProduct$1(e$3[0],scale);return ts[0]?ts:[ts[1]]}var g$1=Array(2*n$3),q=[.1,.1],t$3=[.1,.1],count=0;twoProduct$1(e$3[0],scale,q),q[0]&&(g$1[count++]=q[0]);for(var i$3=1;i$3<n$3;++i$3){twoProduct$1(e$3[i$3],scale,t$3);var pq=q[1];twoSum(pq,t$3[0],q),q[0]&&(g$1[count++]=q[0]);var a$3=t$3[1],b$3=q[1],x$2=a$3+b$3,bv=x$2-a$3,y$2=b$3-bv;q[1]=x$2,y$2&&(g$1[count++]=y$2)}return q[1]&&(g$1[count++]=q[1]),count===0&&(g$1[count++]=0),g$1.length=count,g$1}})),require_robust_diff=__commonJSMin(((exports,module)=>{module.exports=robustSubtract$1;function scalarScalar(a$3,b$3){var x$2=a$3+b$3,bv=x$2-a$3,av=x$2-bv,br=b$3-bv,y$2=a$3-av+br;return y$2?[y$2,x$2]:[x$2]}function robustSubtract$1(e$3,f$1){var ne=e$3.length|0,nf=f$1.length|0;if(ne===1&&nf===1)return scalarScalar(e$3[0],-f$1[0]);var n$3=ne+nf,g$1=Array(n$3),count=0,eptr=0,fptr=0,abs=Math.abs,ei=e$3[eptr],ea=abs(ei),fi=-f$1[fptr],fa=abs(fi),a$3,b$3;ea<fa?(b$3=ei,eptr+=1,eptr<ne&&(ei=e$3[eptr],ea=abs(ei))):(b$3=fi,fptr+=1,fptr<nf&&(fi=-f$1[fptr],fa=abs(fi))),eptr<ne&&ea<fa||fptr>=nf?(a$3=ei,eptr+=1,eptr<ne&&(ei=e$3[eptr],ea=abs(ei))):(a$3=fi,fptr+=1,fptr<nf&&(fi=-f$1[fptr],fa=abs(fi)));for(var x$2=a$3+b$3,bv=x$2-a$3,y$2=b$3-bv,q0=y$2,q1=x$2,_x,_bv,_av,_br,_ar;eptr<ne&&fptr<nf;)ea<fa?(a$3=ei,eptr+=1,eptr<ne&&(ei=e$3[eptr],ea=abs(ei))):(a$3=fi,fptr+=1,fptr<nf&&(fi=-f$1[fptr],fa=abs(fi))),b$3=q0,x$2=a$3+b$3,bv=x$2-a$3,y$2=b$3-bv,y$2&&(g$1[count++]=y$2),_x=q1+x$2,_bv=_x-q1,_av=_x-_bv,_br=x$2-_bv,_ar=q1-_av,q0=_ar+_br,q1=_x;for(;eptr<ne;)a$3=ei,b$3=q0,x$2=a$3+b$3,bv=x$2-a$3,y$2=b$3-bv,y$2&&(g$1[count++]=y$2),_x=q1+x$2,_bv=_x-q1,_av=_x-_bv,_br=x$2-_bv,_ar=q1-_av,q0=_ar+_br,q1=_x,eptr+=1,eptr<ne&&(ei=e$3[eptr]);for(;fptr<nf;)a$3=fi,b$3=q0,x$2=a$3+b$3,bv=x$2-a$3,y$2=b$3-bv,y$2&&(g$1[count++]=y$2),_x=q1+x$2,_bv=_x-q1,_av=_x-_bv,_br=x$2-_bv,_ar=q1-_av,q0=_ar+_br,q1=_x,fptr+=1,fptr<nf&&(fi=-f$1[fptr]);return q0&&(g$1[count++]=q0),q1&&(g$1[count++]=q1),count||(g$1[count++]=0),g$1.length=count,g$1}})),require_orientation=__commonJSMin(((exports,module)=>{var twoProduct=require_two_product(),robustSum=require_robust_sum(),robustScale=require_robust_scale(),robustSubtract=require_robust_diff(),NUM_EXPAND=5,EPSILON=11102230246251565e-32,ERRBOUND3=(3+16*EPSILON)*EPSILON,ERRBOUND4=(7+56*EPSILON)*EPSILON;function orientation_3(sum,prod,scale,sub){return function(m0,m1,m2){var p$3=sum(sum(prod(m1[1],m2[0]),prod(-m2[1],m1[0])),sum(prod(m0[1],m1[0]),prod(-m1[1],m0[0]))),n$3=sum(prod(m0[1],m2[0]),prod(-m2[1],m0[0])),d$2=sub(p$3,n$3);return d$2[d$2.length-1]}}function orientation_4(sum,prod,scale,sub){return function(m0,m1,m2,m3){var p$3=sum(sum(scale(sum(prod(m2[1],m3[0]),prod(-m3[1],m2[0])),m1[2]),sum(scale(sum(prod(m1[1],m3[0]),prod(-m3[1],m1[0])),-m2[2]),scale(sum(prod(m1[1],m2[0]),prod(-m2[1],m1[0])),m3[2]))),sum(scale(sum(prod(m1[1],m3[0]),prod(-m3[1],m1[0])),m0[2]),sum(scale(sum(prod(m0[1],m3[0]),prod(-m3[1],m0[0])),-m1[2]),scale(sum(prod(m0[1],m1[0]),prod(-m1[1],m0[0])),m3[2])))),n$3=sum(sum(scale(sum(prod(m2[1],m3[0]),prod(-m3[1],m2[0])),m0[2]),sum(scale(sum(prod(m0[1],m3[0]),prod(-m3[1],m0[0])),-m2[2]),scale(sum(prod(m0[1],m2[0]),prod(-m2[1],m0[0])),m3[2]))),sum(scale(sum(prod(m1[1],m2[0]),prod(-m2[1],m1[0])),m0[2]),sum(scale(sum(prod(m0[1],m2[0]),prod(-m2[1],m0[0])),-m1[2]),scale(sum(prod(m0[1],m1[0]),prod(-m1[1],m0[0])),m2[2])))),d$2=sub(p$3,n$3);return d$2[d$2.length-1]}}function orientation_5(sum,prod,scale,sub){return function(m0,m1,m2,m3,m4){var p$3=sum(sum(sum(scale(sum(scale(sum(prod(m3[1],m4[0]),prod(-m4[1],m3[0])),m2[2]),sum(scale(sum(prod(m2[1],m4[0]),prod(-m4[1],m2[0])),-m3[2]),scale(sum(prod(m2[1],m3[0]),prod(-m3[1],m2[0])),m4[2]))),m1[3]),sum(scale(sum(scale(sum(prod(m3[1],m4[0]),prod(-m4[1],m3[0])),m1[2]),sum(scale(sum(prod(m1[1],m4[0]),prod(-m4[1],m1[0])),-m3[2]),scale(sum(prod(m1[1],m3[0]),prod(-m3[1],m1[0])),m4[2]))),-m2[3]),scale(sum(scale(sum(prod(m2[1],m4[0]),prod(-m4[1],m2[0])),m1[2]),sum(scale(sum(prod(m1[1],m4[0]),prod(-m4[1],m1[0])),-m2[2]),scale(sum(prod(m1[1],m2[0]),prod(-m2[1],m1[0])),m4[2]))),m3[3]))),sum(scale(sum(scale(sum(prod(m2[1],m3[0]),prod(-m3[1],m2[0])),m1[2]),sum(scale(sum(prod(m1[1],m3[0]),prod(-m3[1],m1[0])),-m2[2]),scale(sum(prod(m1[1],m2[0]),prod(-m2[1],m1[0])),m3[2]))),-m4[3]),sum(scale(sum(scale(sum(prod(m3[1],m4[0]),prod(-m4[1],m3[0])),m1[2]),sum(scale(sum(prod(m1[1],m4[0]),prod(-m4[1],m1[0])),-m3[2]),scale(sum(prod(m1[1],m3[0]),prod(-m3[1],m1[0])),m4[2]))),m0[3]),scale(sum(scale(sum(prod(m3[1],m4[0]),prod(-m4[1],m3[0])),m0[2]),sum(scale(sum(prod(m0[1],m4[0]),prod(-m4[1],m0[0])),-m3[2]),scale(sum(prod(m0[1],m3[0]),prod(-m3[1],m0[0])),m4[2]))),-m1[3])))),sum(sum(scale(sum(scale(sum(prod(m1[1],m4[0]),prod(-m4[1],m1[0])),m0[2]),sum(scale(sum(prod(m0[1],m4[0]),prod(-m4[1],m0[0])),-m1[2]),scale(sum(prod(m0[1],m1[0]),prod(-m1[1],m0[0])),m4[2]))),m3[3]),sum(scale(sum(scale(sum(prod(m1[1],m3[0]),prod(-m3[1],m1[0])),m0[2]),sum(scale(sum(prod(m0[1],m3[0]),prod(-m3[1],m0[0])),-m1[2]),scale(sum(prod(m0[1],m1[0]),prod(-m1[1],m0[0])),m3[2]))),-m4[3]),scale(sum(scale(sum(prod(m2[1],m3[0]),prod(-m3[1],m2[0])),m1[2]),sum(scale(sum(prod(m1[1],m3[0]),prod(-m3[1],m1[0])),-m2[2]),scale(sum(prod(m1[1],m2[0]),prod(-m2[1],m1[0])),m3[2]))),m0[3]))),sum(scale(sum(scale(sum(prod(m2[1],m3[0]),prod(-m3[1],m2[0])),m0[2]),sum(scale(sum(prod(m0[1],m3[0]),prod(-m3[1],m0[0])),-m2[2]),scale(sum(prod(m0[1],m2[0]),prod(-m2[1],m0[0])),m3[2]))),-m1[3]),sum(scale(sum(scale(sum(prod(m1[1],m3[0]),prod(-m3[1],m1[0])),m0[2]),sum(scale(sum(prod(m0[1],m3[0]),prod(-m3[1],m0[0])),-m1[2]),scale(sum(prod(m0[1],m1[0]),prod(-m1[1],m0[0])),m3[2]))),m2[3]),scale(sum(scale(sum(prod(m1[1],m2[0]),prod(-m2[1],m1[0])),m0[2]),sum(scale(sum(prod(m0[1],m2[0]),prod(-m2[1],m0[0])),-m1[2]),scale(sum(prod(m0[1],m1[0]),prod(-m1[1],m0[0])),m2[2]))),-m3[3]))))),n$3=sum(sum(sum(scale(sum(scale(sum(prod(m3[1],m4[0]),prod(-m4[1],m3[0])),m2[2]),sum(scale(sum(prod(m2[1],m4[0]),prod(-m4[1],m2[0])),-m3[2]),scale(sum(prod(m2[1],m3[0]),prod(-m3[1],m2[0])),m4[2]))),m0[3]),scale(sum(scale(sum(prod(m3[1],m4[0]),prod(-m4[1],m3[0])),m0[2]),sum(scale(sum(prod(m0[1],m4[0]),prod(-m4[1],m0[0])),-m3[2]),scale(sum(prod(m0[1],m3[0]),prod(-m3[1],m0[0])),m4[2]))),-m2[3])),sum(scale(sum(scale(sum(prod(m2[1],m4[0]),prod(-m4[1],m2[0])),m0[2]),sum(scale(sum(prod(m0[1],m4[0]),prod(-m4[1],m0[0])),-m2[2]),scale(sum(prod(m0[1],m2[0]),prod(-m2[1],m0[0])),m4[2]))),m3[3]),scale(sum(scale(sum(prod(m2[1],m3[0]),prod(-m3[1],m2[0])),m0[2]),sum(scale(sum(prod(m0[1],m3[0]),prod(-m3[1],m0[0])),-m2[2]),scale(sum(prod(m0[1],m2[0]),prod(-m2[1],m0[0])),m3[2]))),-m4[3]))),sum(sum(scale(sum(scale(sum(prod(m2[1],m4[0]),prod(-m4[1],m2[0])),m1[2]),sum(scale(sum(prod(m1[1],m4[0]),prod(-m4[1],m1[0])),-m2[2]),scale(sum(prod(m1[1],m2[0]),prod(-m2[1],m1[0])),m4[2]))),m0[3]),scale(sum(scale(sum(prod(m2[1],m4[0]),prod(-m4[1],m2[0])),m0[2]),sum(scale(sum(prod(m0[1],m4[0]),prod(-m4[1],m0[0])),-m2[2]),scale(sum(prod(m0[1],m2[0]),prod(-m2[1],m0[0])),m4[2]))),-m1[3])),sum(scale(sum(scale(sum(prod(m1[1],m4[0]),prod(-m4[1],m1[0])),m0[2]),sum(scale(sum(prod(m0[1],m4[0]),prod(-m4[1],m0[0])),-m1[2]),scale(sum(prod(m0[1],m1[0]),prod(-m1[1],m0[0])),m4[2]))),m2[3]),scale(sum(scale(sum(prod(m1[1],m2[0]),prod(-m2[1],m1[0])),m0[2]),sum(scale(sum(prod(m0[1],m2[0]),prod(-m2[1],m0[0])),-m1[2]),scale(sum(prod(m0[1],m1[0]),prod(-m1[1],m0[0])),m2[2]))),-m4[3])))),d$2=sub(p$3,n$3);return d$2[d$2.length-1]}}function orientation(n$3){return(n$3===3?orientation_3:n$3===4?orientation_4:orientation_5)(robustSum,twoProduct,robustScale,robustSubtract)}var orientation3Exact=orientation(3),orientation4Exact=orientation(4),CACHED=[function(){return 0},function(){return 0},function(a$3,b$3){return b$3[0]-a$3[0]},function(a$3,b$3,c$2){var l$2=(a$3[1]-c$2[1])*(b$3[0]-c$2[0]),r$3=(a$3[0]-c$2[0])*(b$3[1]-c$2[1]),det=l$2-r$3,s$2;if(l$2>0){if(r$3<=0)return det;s$2=l$2+r$3}else if(l$2<0){if(r$3>=0)return det;s$2=-(l$2+r$3)}else return det;var tol=ERRBOUND3*s$2;return det>=tol||det<=-tol?det:orientation3Exact(a$3,b$3,c$2)},function(a$3,b$3,c$2,d$2){var adx=a$3[0]-d$2[0],bdx=b$3[0]-d$2[0],cdx=c$2[0]-d$2[0],ady=a$3[1]-d$2[1],bdy=b$3[1]-d$2[1],cdy=c$2[1]-d$2[1],adz=a$3[2]-d$2[2],bdz=b$3[2]-d$2[2],cdz=c$2[2]-d$2[2],bdxcdy=bdx*cdy,cdxbdy=cdx*bdy,cdxady=cdx*ady,adxcdy=adx*cdy,adxbdy=adx*bdy,bdxady=bdx*ady,det=adz*(bdxcdy-cdxbdy)+bdz*(cdxady-adxcdy)+cdz*(adxbdy-bdxady),permanent=(Math.abs(bdxcdy)+Math.abs(cdxbdy))*Math.abs(adz)+(Math.abs(cdxady)+Math.abs(adxcdy))*Math.abs(bdz)+(Math.abs(adxbdy)+Math.abs(bdxady))*Math.abs(cdz),tol=ERRBOUND4*permanent;return det>tol||-det>tol?det:orientation4Exact(a$3,b$3,c$2,d$2)}];function slowOrient(args){var proc$1=CACHED[args.length];return proc$1||=CACHED[args.length]=orientation(args.length),proc$1.apply(void 0,args)}function proc(slow,o0,o1,o2,o3,o4,o5){return function(a0,a1,a2,a3,a4){switch(arguments.length){case 0:case 1:return 0;case 2:return o2(a0,a1);case 3:return o3(a0,a1,a2);case 4:return o4(a0,a1,a2,a3);case 5:return o5(a0,a1,a2,a3,a4)}for(var s$2=Array(arguments.length),i$3=0;i$3<arguments.length;++i$3)s$2[i$3]=arguments[i$3];return slow(s$2)}}function generateOrientationProc(){for(;CACHED.length<=NUM_EXPAND;)CACHED.push(orientation(CACHED.length));module.exports=proc.apply(void 0,[slowOrient].concat(CACHED));for(var i$3=0;i$3<=NUM_EXPAND;++i$3)module.exports[i$3]=CACHED[i$3]}generateOrientationProc()})),require_robust_pnp=__commonJSMin(((exports,module)=>{module.exports=robustPointInPolygon$2;var orient=require_orientation();function robustPointInPolygon$2(vs,point){for(var x$2=point[0],y$2=point[1],n$3=vs.length,inside=1,lim=n$3,i$3=0,j$2=n$3-1;i$3<lim;j$2=i$3++){var a$3=vs[i$3],b$3=vs[j$2],yi=a$3[1],yj=b$3[1];if(yj<yi){if(yj<y$2&&y$2<yi){var s$2=orient(a$3,b$3,point);if(s$2===0)return 0;inside^=0<s$2|0}else if(y$2===yi){var c$2=vs[(i$3+1)%n$3],yk=c$2[1];if(yi<yk){var s$2=orient(a$3,b$3,point);if(s$2===0)return 0;inside^=0<s$2|0}}}else if(yi<yj){if(yi<y$2&&y$2<yj){var s$2=orient(a$3,b$3,point);if(s$2===0)return 0;inside^=s$2<0|0}else if(y$2===yi){var c$2=vs[(i$3+1)%n$3],yk=c$2[1];if(yk<yi){var s$2=orient(a$3,b$3,point);if(s$2===0)return 0;inside^=s$2<0|0}}}else if(y$2===yi){var x0=Math.min(a$3[0],b$3[0]),x1=Math.max(a$3[0],b$3[0]);if(i$3===0){for(;j$2>0;){var k$2=(j$2+n$3-1)%n$3,p$3=vs[k$2];if(p$3[1]!==y$2)break;var px=p$3[0];x0=Math.min(x0,px),x1=Math.max(x1,px),j$2=k$2}if(j$2===0)return x0<=x$2&&x$2<=x1?0:1;lim=j$2+1}for(var y0=vs[(j$2+n$3-1)%n$3][1];i$3+1<lim;){var p$3=vs[i$3+1];if(p$3[1]!==y$2)break;var px=p$3[0];x0=Math.min(x0,px),x1=Math.max(x1,px),i$3+=1}if(x0<=x$2&&x$2<=x1)return 0;var y1=vs[(i$3+1)%n$3][1];x$2<x0&&y0<y$2!=y1<y$2&&(inside^=1)}}return 2*inside-1}}));function arrayPointsToObjects(points){let result=[];for(let point of points)result.push([point.column,point.row]);return result}var import_robust_pnp$1=__toESM(require_robust_pnp());function drawPolygonOnImage(image,points,options={}){let{fillColor,origin={column:0,row:0},...otherOptions}=options;checkProcessable(image,{bitDepth:[8,16]});let newImage=getOutputImage(image,options,{clone:!0});if(fillColor===void 0)return newImage.drawPolyline([...points,points[0]],{origin,...otherOptions});{validateColor(fillColor,newImage);let filteredPoints=deleteDuplicates(points),arrayPoints=arrayPointsToObjects(filteredPoints);for(let row=0;row<newImage.height;row++)for(let column=0;column<newImage.width;column++)(0,import_robust_pnp$1.default)(arrayPoints,[column,row])===-1&&setBlendedVisiblePixel(newImage,Math.round(origin.column)+column,Math.round(origin.row)+row,fillColor)}return newImage.drawPolyline([...points,points[0]],{origin,...otherOptions})}var import_robust_pnp=__toESM(require_robust_pnp());function drawPolygonOnMask(mask,points,options={}){let{filled=!1,origin={column:0,row:0},...otherOptions}=options,newMask=maskToOutputMask(mask,options,{clone:!0});if(!filled)return newMask.drawPolyline([...points,points[0]],{origin,...otherOptions});let filteredPoints=deleteDuplicates(points),arrayPoints=arrayPointsToObjects(filteredPoints);for(let row=0;row<newMask.height;row++)for(let column=0;column<newMask.width;column++)(0,import_robust_pnp.default)(arrayPoints,[column,row])===-1&&newMask.setBit(Math.round(origin.column)+column,Math.round(origin.row)+row,1);return newMask.drawPolyline([...points,points[0]],{origin,...otherOptions})}function drawRectangle(image,options={}){let{width:rectangleWidth=image.width,height:rectangleHeight=image.height,origin={column:0,row:0},strokeColor=getDefaultColor(image),fillColor}=options,width=Math.round(rectangleWidth),height=Math.round(rectangleHeight),column=Math.round(origin.column),row=Math.round(origin.row),newImage;image instanceof Image?(checkProcessable(image,{bitDepth:[8,16]}),validateColor(strokeColor,image),fillColor&&validateColor(fillColor,image),newImage=getOutputImage(image,options,{clone:!0})):newImage=maskToOutputMask(image,options,{clone:!0});for(let currentColumn=column;currentColumn<column+width;currentColumn++)setBlendedVisiblePixel(newImage,currentColumn,row,strokeColor),setBlendedVisiblePixel(newImage,currentColumn,row+height-1,strokeColor);for(let currentRow=row+1;currentRow<row+height-1;currentRow++)setBlendedVisiblePixel(newImage,column,currentRow,strokeColor),setBlendedVisiblePixel(newImage,column+width-1,currentRow,strokeColor);if(fillColor)for(let currentRow=row+1;currentRow<row+height-1;currentRow++)for(let currentColumn=column+1;currentColumn<column+width-1;currentColumn++)setBlendedVisiblePixel(newImage,currentColumn,currentRow,fillColor);return newImage}function drawPoints(image,points,options={}){let{color=getDefaultColor(image),origin={row:0,column:0}}=options,newImage;image instanceof Image?(newImage=getOutputImage(image,options,{clone:!0}),validateColor(color,newImage)):newImage=maskToOutputMask(image,options,{clone:!0}),checkProcessable(newImage,{bitDepth:[1,8,16]});for(let point of points)setBlendedVisiblePixel(newImage,Math.round(origin.column+point.column),Math.round(origin.row+point.row),color);return newImage}function drawMarker(image,point,options){let newImage=getOutputImage(image,options,{clone:!0}),{strokeColor=getDefaultColor(newImage),fillColor,shape=`cross`,size:markerSize=1}=options,size=Math.round(markerSize);if(validateColor(strokeColor,newImage),fillColor&&validateColor(fillColor,newImage),checkProcessable(newImage,{bitDepth:[8,16]}),shape===`circle`&&newImage.drawCircle(point,size,{strokeColor,fillColor,out:newImage}),shape===`triangle`){let points=[{row:point.row-size,column:point.column},{row:point.row,column:point.column+size},{row:point.row,column:point.column-size}];newImage.drawPolygon(points,{strokeColor,fillColor,out:newImage})}if(shape===`cross`&&(newImage.drawLine({row:point.row-size,column:point.column},{row:point.row+size,column:point.column},{strokeColor,out:newImage}),newImage.drawLine({row:point.row,column:point.column-size},{row:point.row,column:point.column+size},{strokeColor,out:newImage})),shape===`square`){let origin={row:point.row-(size-1)/2,column:point.column-(size-1)/2};newImage.drawRectangle({origin,width:size,height:size,strokeColor,fillColor,out:newImage})}return newImage}function drawMarkers(image,points,options={}){let newImage=getOutputImage(image,options,{clone:!0});for(let point of points)drawMarker(newImage,point,{...options,out:newImage});return newImage}function and(mask,otherMask,options){let newMask=maskToOutputMask(mask,options);if(mask.width!==otherMask.width||mask.height!==otherMask.height)throw RangeError(`both masks must have the same size`);for(let i$3=0;i$3<newMask.size;i$3++)mask.getBitByIndex(i$3)&&otherMask.getBitByIndex(i$3)?newMask.setBitByIndex(i$3,1):newMask.setBitByIndex(i$3,0);return newMask}function checkSize(size){if(!Number.isInteger(size)||size<1)throw TypeError(`size must be a positive integer. Got ${size}`)}function checkKernel$1(kernel){if(kernel.length===0||kernel.length%2!=1)throw RangeError(`kernel must have an odd positive length. Got ${kernel.length}`)}function checkBorderType(borderType){if(borderType!==`CONSTANT`&&borderType!==`CUT`)throw RangeError(`unexpected border type: ${borderType}`)}function checkInputLength(actual,expected){if(actual!==expected)throw RangeError(`input length (${actual}) does not match setup size (${expected})`)}function createArray(len){let array=[];for(var i$3=0;i$3<len;i$3++)array.push(0);return array}var DirectConvolution=class{constructor(size,kernel,borderType=`CONSTANT`){checkSize(size),checkKernel$1(kernel),checkBorderType(borderType),this.size=size,this.kernelOffset=(kernel.length-1)/2,this.outputSize=borderType===`CONSTANT`?size:size-2*this.kernelOffset,this.output=createArray(this.outputSize),this.kernel=kernel,this.kernelSize=kernel.length,this.borderType=borderType}convolve(input){return checkInputLength(input.length,this.size),this.output.fill(0),this.borderType===`CONSTANT`?this._convolutionBorder0(input):this._convolutionBorderCut(input),this.output}_convolutionBorder0(input){for(let i$3=0;i$3<this.size;i$3++)for(let j$2=0;j$2<this.kernelSize;j$2++)this.output[i$3]+=interpolateInput(input,i$3-this.kernelOffset+j$2)*this.kernel[j$2]}_convolutionBorderCut(input){for(let i$3=this.kernelOffset;i$3<this.size-this.kernelOffset;i$3++){let index=i$3-this.kernelOffset;for(let j$2=0;j$2<this.kernelSize;j$2++)this.output[index]+=input[index+j$2]*this.kernel[j$2]}}};function interpolateInput(input,idx){return idx<0||idx>=input.length?0:input[idx]}var require_next_power_of_two=__commonJSMin(((exports,module)=>{module.exports=nextPowerOfTwo;function nextPowerOfTwo(n$3){return n$3===0?1:(n$3--,n$3|=n$3>>1,n$3|=n$3>>2,n$3|=n$3>>4,n$3|=n$3>>8,n$3|=n$3>>16,n$3+1)}})),import_fft=__toESM(require_fft()),import_next_power_of_two=__toESM(require_next_power_of_two());const BorderType={CONSTANT:`CONSTANT`,CUT:`CUT`};function getBorderInterpolation(type,value){return M(type).with(`constant`,()=>getInterpolateConstant(value)).with(`replicate`,()=>interpolateReplicate).with(`reflect`,()=>interpolateReflect).with(`reflect101`,()=>interpolateReflect101).with(`wrap`,()=>interpolateWrap).exhaustive()}function checkRange(point,length){if(point<=0-length||point>=length+length-1)throw RangeError(`border must be smaller than the original image`)}function getInterpolateConstant(value){return function(column,row,channel,image){let newColumn=interpolateConstantPoint(column,image.width),newRow=interpolateConstantPoint(row,image.height);return newColumn===-1||newRow===-1?value:image.getValue(newColumn,newRow,channel)}}function interpolateConstantPoint(point,length){return point>=0&&point<length?point:-1}function interpolateReplicate(column,row,channel,image){return image.getValue(interpolateReplicatePoint(column,image.width),interpolateReplicatePoint(row,image.height),channel)}function interpolateReplicatePoint(point,length){return point>=0&&point<length?point:(checkRange(point,length),point<0?0:length-1)}function interpolateReflect(column,row,channel,image){return image.getValue(interpolateReflectPoint(column,image.width),interpolateReflectPoint(row,image.height),channel)}function interpolateReflectPoint(point,length){return point>=0&&point<length?point:(checkRange(point,length),point<0?-1-point:length+length-1-point)}function interpolateWrap(column,row,channel,image){return image.getValue(interpolateWrapPoint(column,image.width),interpolateWrapPoint(row,image.height),channel)}function interpolateWrapPoint(point,length){return point>=0&&point<length?point:(checkRange(point,length),point<0?length+point:point-length)}function interpolateReflect101(column,row,channel,image){return image.getValue(interpolateReflect101Point(column,image.width),interpolateReflect101Point(row,image.height),channel)}function interpolateReflect101Point(point,length){return point>=0&&point<length?point:(checkRange(point,length),point<0?0-point:length+length-2-point)}function extendBorders(image,options){let{horizontal,vertical,borderType=`reflect101`,borderValue=0}=options,interpolateBorder=getBorderInterpolation(borderType,borderValue),newImage=Image.createFrom(image,{width:image.width+2*horizontal,height:image.height+2*vertical});image.copyTo(newImage,{origin:{column:horizontal,row:vertical},out:newImage});for(let row=0;row<vertical;row++)for(let col=0;col<newImage.width;col++)for(let channel=0;channel<image.channels;channel++){let newValue=interpolateBorder(col-horizontal,row-vertical,channel,image);newImage.setValue(col,row,channel,newValue)}for(let row=newImage.height-vertical;row<newImage.height;row++)for(let col=0;col<newImage.width;col++)for(let channel=0;channel<image.channels;channel++){let newValue=interpolateBorder(col-horizontal,row-vertical,channel,image);newImage.setValue(col,row,channel,newValue)}for(let row=vertical;row<newImage.height-vertical;row++)for(let col=0;col<horizontal;col++)for(let channel=0;channel<image.channels;channel++){let newValue=interpolateBorder(col-horizontal,row-vertical,channel,image);newImage.setValue(col,row,channel,newValue)}for(let row=vertical;row<newImage.height-vertical;row++)for(let col=newImage.width-horizontal;col<newImage.width;col++)for(let channel=0;channel<image.channels;channel++){let newValue=interpolateBorder(col-horizontal,row-vertical,channel,image);newImage.setValue(col,row,channel,newValue)}return newImage}function round(value){let integer=Math.trunc(value),decimal=value-integer;return decimal<.5?integer:decimal>.5?integer+1:integer%2==0?integer:integer+1}function directConvolution(image,kernel,options={}){let{borderType=`reflect101`,borderValue=0}=options,convolutedData=rawDirectConvolution(image,kernel,{borderType,borderValue}),newImage=getOutputImage(image,options),clamp=getClamp(newImage);for(let i$3=0;i$3<image.size;i$3++)for(let channel=0;channel<image.channels;channel++){let dataIndex=i$3*image.channels+channel,newValue=round(clamp(convolutedData[dataIndex]));newImage.setValueByIndex(i$3,channel,newValue)}return newImage}function rawDirectConvolution(image,kernel,options={}){let{borderType=`reflect101`,borderValue=0}=options,interpolateBorder=getBorderInterpolation(borderType,borderValue),result=new Float64Array(image.size*image.channels);for(let channel=0;channel<image.channels;channel++)for(let row=0;row<image.height;row++)for(let column=0;column<image.width;column++){let index=getIndex(column,row,image,channel);result[index]=computeConvolutionValue(column,row,channel,image,kernel,interpolateBorder,{returnRawValue:!0})}return result}function separableConvolution(image,kernelX$1,kernelY$1,options={}){let{normalize:normalize$1,borderType=`reflect101`,borderValue=0}=options;normalize$1&&([kernelX$1,kernelY$1]=normalizeSeparatedKernel(kernelX$1,kernelY$1));let kernelOffsetX=(kernelX$1.length-1)/2,kernelOffsetY=(kernelY$1.length-1)/2,extendedImage=extendBorders(image,{horizontal:kernelOffsetX,vertical:kernelOffsetY,borderType,borderValue}),newImage=Image.createFrom(image),clamp=getClamp(newImage),rowConvolution=new DirectConvolution(extendedImage.width,kernelX$1,BorderType.CUT),columnConvolution=new DirectConvolution(extendedImage.height,kernelY$1,BorderType.CUT),rowData=new Float64Array(extendedImage.width),columnData=new Float64Array(extendedImage.height),convolvedData=new Float64Array(image.width*extendedImage.height);for(let channel=0;channel<extendedImage.channels;channel++){for(let row=0;row<extendedImage.height;row++){for(let column=0;column<extendedImage.width;column++)rowData[column]=extendedImage.getValue(column,row,channel);let convolvedRow=rowConvolution.convolve(rowData);for(let column=0;column<image.width;column++)convolvedData[row*image.width+column]=convolvedRow[column]}for(let column=0;column<image.width;column++){for(let row=0;row<extendedImage.height;row++)columnData[row]=convolvedData[row*image.width+column];let convolvedColumn=columnConvolution.convolve(columnData);for(let row=0;row<image.height;row++)newImage.setValue(column,row,channel,round(clamp(convolvedColumn[row])))}}return newImage}function computeConvolutionValue(column,row,channel,image,kernel,interpolateBorder,options={}){let{clamp}=options,{returnRawValue=!1}=options;returnRawValue&&(clamp=void 0);let val=0,kernelWidth=kernel[0].length,kernelHeight=kernel.length,kernelOffsetX=(kernelWidth-1)/2,kernelOffsetY=(kernelHeight-1)/2;for(let kY=0;kY<kernelHeight;kY++)for(let kX=0;kX<kernelWidth;kX++){let kernelValue=kernel[kY][kX];val+=kernelValue*interpolateBorder(column+kX-kernelOffsetX,row+kY-kernelOffsetY,channel,image)}return clamp?round(clamp(val)):val}function normalizeSeparatedKernel(kernelX$1,kernelY$1){let sumKernelX=kernelX$1.reduce((prev,current)=>prev+current,0),sumKernelY=kernelY$1.reduce((prev,current)=>prev+current,0),prod=sumKernelX*sumKernelY;if(prod<0)throw RangeError(`this separated kernel cannot be normalized`);let factor=1/Math.sqrt(Math.abs(prod));return[kernelX$1.map(v$2=>v$2*factor),kernelY$1.map(v$2=>v$2*factor)]}function blur(image,options){let{width,height}=options;if(width<1||width%2==0)throw RangeError(`Invalid property "width". Must be an odd number greater than 0. Received ${width}.`);if(height<1||height%2==0)throw RangeError(`Invalid property "height". Must be an odd number greater than 0. Received ${height}.`);let kernelX$1=Array(width).fill(1),kernelY$1=Array(height).fill(1);return separableConvolution(image,kernelX$1,kernelY$1,{normalize:!0,...options})}function derivativeFilter(image,options={}){let{filter=`sobel`}=options,kernels=M(filter).with(`sobel`,()=>({kernelX:SOBEL_X,kernelY:SOBEL_Y})).with(`scharr`,()=>({kernelX:SCHARR_X,kernelY:SCHARR_Y})).with(`prewitt`,()=>({kernelX:PREWITT_X,kernelY:PREWITT_Y})).exhaustive();return image.gradientFilter({...kernels,...options})}const ImageColorModel={GREY:`GREY`,GREYA:`GREYA`,RGB:`RGB`,RGBA:`RGBA`,BINARY:`BINARY`},colorModels={GREY:{components:1,alpha:!1,channels:1},GREYA:{components:1,alpha:!0,channels:2},RGB:{components:3,alpha:!1,channels:3},RGBA:{components:3,alpha:!0,channels:4},BINARY:{components:1,alpha:!1,channels:1}};function increaseContrast(image,options={}){let{uniform=!1}=options;checkProcessable(image,{bitDepth:[8,16]});let minMax=image.minMax(),min$2=minMax.min,max$2=minMax.max;if(uniform){let maxDiffIndex=-1,previousDiff=-1;for(let i$3=0;i$3<minMax.max.length;i$3++){let difference$1=minMax.max[i$3]-minMax.min[i$3];difference$1>previousDiff&&(maxDiffIndex=i$3,previousDiff=difference$1)}min$2=minMax.min[maxDiffIndex],max$2=minMax.max[maxDiffIndex]}let channels=Array(image.components).fill(0).map((value,index)=>index);return image.colorModel===ImageColorModel.GREYA?channels=[0]:image.colorModel===ImageColorModel.RGBA&&(channels=[0,1,2]),image.level({inputMin:min$2,inputMax:max$2,outputMin:0,outputMax:image.maxValue,channels,...options})}function gaussianBlur(image,options){if(`sigma`in options){let{sigma,size=getSize$1(sigma),borderType}=options,radius=getRadius(size),kernel=getKernel(radius,sigma);return separableConvolution(image,kernel,kernel,{borderType})}else if(`sigmaX`in options&&`sigmaY`in options){let{sigmaX,sigmaY,sizeX=getSize$1(sigmaX),sizeY=getSize$1(sigmaY),borderType}=options,radiusX=getRadius(sizeX),radiusY=getRadius(sizeY),kernelX$1=getKernel(radiusX,sigmaX),kernelY$1=getKernel(radiusY,sigmaY);return separableConvolution(image,kernelX$1,kernelY$1,{borderType})}else throw TypeError(`you must either define sigma or sigmaX and sigmaY in the options argument`)}function getKernel(radius,sigma){let n$3=radius*2+1,kernel=Array(n$3),sigmaX=sigma||((n$3-1)*.5-1)*.3+.8,scale2X=-.5/(sigmaX*sigmaX),sum=0;for(let i$3=0;i$3<n$3;i$3++){let x$2=i$3-radius,t$3=Math.exp(scale2X*x$2*x$2);kernel[i$3]=t$3,sum+=t$3}for(let i$3=0;i$3<n$3;i$3++)kernel[i$3]/=sum;return kernel}function getSize$1(sigma){return 2*Math.ceil(2*sigma)+1}function gradientFilter(image,options){let{borderType=`replicate`,borderValue=0}=options;if(checkProcessable(image,{bitDepth:[8,16],colorModel:`GREY`}),`kernelX`in options&&`kernelY`in options){let{kernelX:kernelX$1,kernelY:kernelY$1}=options,gradientX=image.rawDirectConvolution(kernelX$1,{borderType,borderValue}),gradientY=image.rawDirectConvolution(kernelY$1,{borderType,borderValue}),gradient=new Image(image.width,image.height,{colorModel:`GREY`});for(let i$3=0;i$3<image.size;i$3++)gradient.setValueByIndex(i$3,0,Math.hypot(gradientX[i$3],gradientY[i$3]));return gradient}else if(`kernelX`in options)return image.directConvolution(options.kernelX,{borderType,borderValue});else if(`kernelY`in options)return image.directConvolution(options.kernelY,{borderType,borderValue});else throw TypeError(`kernelX and KernelY are not defined`)}function hypotenuse(image,otherImage,options={}){let{channels=Array(image.components).fill(0).map((value,index)=>index)}=options;if(checkProcessable(image,{bitDepth:[8,16]}),image.width!==otherImage.width||image.height!==otherImage.height)throw RangeError(`both images must have the same size`);if(image.alpha!==otherImage.alpha||image.bitDepth!==otherImage.bitDepth)throw RangeError(`both images must have the same alpha and bitDepth`);if(image.channels!==otherImage.channels)throw RangeError(`both images must have the same number of channels`);validateChannels(channels,image);let newImage=getOutputImage(image,{},{clone:!0});for(let channel of channels)for(let i$3=0;i$3<image.size;i$3++){let value=Math.hypot(image.getValueByIndex(i$3,channel),otherImage.getValueByIndex(i$3,channel));newImage.setValueByIndex(i$3,channel,Math.min(value,newImage.maxValue))}return newImage}function convertColor(image,colorModel,options={}){let canConvert=new Map([[`GREY`,[`GREYA`,`RGB`,`RGBA`]],[`GREYA`,[`GREY`,`RGB`,`RGBA`]],[`RGB`,[`GREY`,`GREYA`,`RGBA`]],[`RGBA`,[`GREY`,`GREYA`,`RGB`]],[`BINARY`,[`GREY`,`RGB`,`RGBA`]]]);if(image.colorModel===colorModel&&colorModel!==`BINARY`)return getOutputImage(image,{out:options.out},{clone:!0});if(!canConvert.get(image.colorModel)?.includes(colorModel))throw RangeError(`conversion from ${image.colorModel} to ${colorModel} not implemented`);if(image instanceof Image){let output=getOutputImage(image,options,{newParameters:{colorModel}});return(image.colorModel===`GREY`||image.colorModel===`GREYA`)&&convertGreyToAny(image,output),(image.colorModel===`RGB`||image.colorModel===`RGBA`)&&(colorModel===`RGB`||colorModel===`RGBA`?convertRgbToRgb(image,output):convertRgbToGrey(image,output)),!image.alpha&&output.alpha&&output.fillAlpha(output.maxValue),image.alpha&&output.alpha&&copyAlpha(image,output),output}else if(colorModel===`GREY`){let output=maskToOutputImage(image,options);return convertBinaryToGrey(image,output),output}else{let img=new Image(image.width,image.height,{colorModel});return convertBinaryToRgb(image,img),img}}function copyAlpha(source,dest){if(source.size!==dest.size)throw RangeError(`source and destination have different sizes`);if(!source.alpha)throw RangeError(`source image does not have alpha`);if(!dest.alpha)throw RangeError(`destination does not have alpha`);for(let i$3=0;i$3<dest.size;i$3++)dest.setValueByIndex(i$3,dest.channels-1,source.getValueByIndex(i$3,source.channels-1))}function convertGreyToAny(image,newImage){for(let i$3=0;i$3<image.size;i$3++)for(let j$2=0;j$2<newImage.components;j$2++)newImage.setValueByIndex(i$3,j$2,image.getValueByIndex(i$3,0))}function convertRgbToRgb(image,newImage){for(let i$3=0;i$3<image.size;i$3++)for(let j$2=0;j$2<3;j$2++)newImage.setValueByIndex(i$3,j$2,image.getValueByIndex(i$3,j$2))}function convertRgbToGrey(image,newImage){for(let i$3=0;i$3<image.size;i$3++){let r$3=image.getValueByIndex(i$3,0),g$1=image.getValueByIndex(i$3,1),b$3=image.getValueByIndex(i$3,2);newImage.setValueByIndex(i$3,0,Math.round(.299*r$3+.587*g$1+.114*b$3))}}function convertBinaryToGrey(mask,newImage){for(let i$3=0;i$3<mask.size;i$3++)newImage.setValueByIndex(i$3,0,mask.getBitByIndex(i$3)?newImage.maxValue:0)}function convertBinaryToRgb(mask,newImage){let black$1=Array(newImage.components).fill(0),white=Array(newImage.components).fill(newImage.maxValue);newImage.alpha&&(black$1.push(newImage.maxValue),white.push(newImage.maxValue));for(let i$3=0;i$3<mask.size;i$3++)newImage.setPixelByIndex(i$3,mask.getBitByIndex(i$3)?white:black$1)}function convertBitDepth(image,newBitDepth,options={}){if(image.bitDepth===newBitDepth)return getOutputImage(image,options,{clone:!0});if(newBitDepth!==8&&newBitDepth!==16)throw RangeError(`This image bit depth is not supported: ${newBitDepth}`);let newImage=getOutputImage(image,options,{clone:!1,newParameters:{bitDepth:newBitDepth,colorModel:image.colorModel}});return newBitDepth===8?convertToUint8(image,newImage):convertToUint16(image,newImage)}function convertToUint16(image,targetImage){for(let i$3=0;i$3<image.size;i$3++)for(let j$2=0;j$2<targetImage.channels;j$2++)targetImage.setValueByIndex(i$3,j$2,image.getValueByIndex(i$3,j$2)<<8);return targetImage}function convertToUint8(image,targetImage){for(let i$3=0;i$3<image.size;i$3++)for(let j$2=0;j$2<targetImage.channels;j$2++)targetImage.setValueByIndex(i$3,j$2,image.getValueByIndex(i$3,j$2)>>8);return targetImage}function checkPointIsInteger(point,name=`Point`){if(!Number.isInteger(point.row)||!Number.isInteger(point.column))throw TypeError(`${name} row and column must be integers`)}function extract(image,mask,options={}){let{origin={row:0,column:0}}=options,{row,column}=origin;assert(row<image.height&&column<image.width&&row+mask.width>0&&column+mask.height>0,`extract: image and mask have no overlap`),checkPointIsInteger(origin,`Origin`);let resultWidth=Math.min(image.width,mask.width+column)-Math.max(0,column),resultHeight=Math.min(image.height,mask.height+row)-Math.max(0,row),newImage=new Image(resultWidth,resultHeight,{colorModel:image.colorModel,origin});newImage.alpha&&(newImage=newImage.fillAlpha(0));let imageStartRow=Math.max(0,row),imageStartColumn=Math.max(0,column),maskStartRow=row<0?-row:0,maskStartColumn=column<0?-column:0;for(let resultRow=0;resultRow<resultHeight;resultRow++)for(let resultColumn=0;resultColumn<resultWidth;resultColumn++)mask.getBit(maskStartColumn+resultColumn,maskStartRow+resultRow)&&newImage.setPixel(resultColumn,resultRow,image.getPixel(imageStartColumn+resultColumn,imageStartRow+resultRow));return newImage}function split(image){let result=[];for(let c$2=0;c$2<image.channels;c$2++){let channel=Image.createFrom(image,{colorModel:`GREY`});for(let i$3=0;i$3<channel.size;i$3++)channel.setValueByIndex(i$3,0,image.getValueByIndex(i$3,c$2));result.push(channel)}return result}function huang(histogram$1){let firstBin=0;for(let ih=0;ih<histogram$1.length;ih++)if(histogram$1[ih]!==0){firstBin=ih;break}let lastBin=histogram$1.length-1;for(let ih=histogram$1.length-1;ih>=firstBin;ih--)if(histogram$1[ih]!==0){lastBin=ih;break}let term=1/(lastBin-firstBin),mu0=Array(histogram$1.length),sumPix=0,numPix=0;for(let ih=firstBin;ih<histogram$1.length;ih++)sumPix+=ih*histogram$1[ih],numPix+=histogram$1[ih],mu0[ih]=sumPix/numPix;let mu1=Array(histogram$1.length);sumPix=0,numPix=0;for(let ih=lastBin;ih>0;ih--)sumPix+=ih*histogram$1[ih],numPix+=histogram$1[ih],mu1[ih-1]=sumPix/numPix;let threshold$1=-1,minEnt=Number.MAX_VALUE;for(let it=0;it<histogram$1.length;it++){let ent=0,muX;for(let ih=0;ih<=it;ih++)muX=1/(1+term*Math.abs(ih-mu0[it])),muX<1e-6||muX>.999999||(ent+=histogram$1[ih]*(-muX*Math.log(muX)-(1-muX)*Math.log(1-muX)));for(let ih=it+1;ih<histogram$1.length;ih++)muX=1/(1+term*Math.abs(ih-mu1[it])),muX<1e-6||muX>.999999||(ent+=histogram$1[ih]*(-muX*Math.log(muX)-(1-muX)*Math.log(1-muX)));ent<minEnt&&(minEnt=ent,threshold$1=it)}return threshold$1}function intermodes(histogram$1){let iHisto=histogram$1.slice(),iter=0;for(;!bimodalTest$1(iHisto);){let previous=0,current=0,next=iHisto[0];for(let i$3=0;i$3<histogram$1.length-1;i$3++)previous=current,current=next,next=iHisto[i$3+1],iHisto[i$3]=(previous+current+next)/3;iHisto[histogram$1.length-1]=(current+next)/3,iter++,assert(iter<1e3,`Intermodes threshold not found after 1000 iterations`)}let tt=0;for(let i$3=1;i$3<histogram$1.length-1;i$3++)iHisto[i$3-1]<iHisto[i$3]&&iHisto[i$3+1]<iHisto[i$3]&&(tt+=i$3);return Math.floor(tt/2)}function bimodalTest$1(iHisto){let b$3=!1,modes=0;for(let k$2=1;k$2<iHisto.length-1;k$2++)if(iHisto[k$2-1]<iHisto[k$2]&&iHisto[k$2+1]<iHisto[k$2]&&(modes++,modes>2))return!1;return modes===2&&(b$3=!0),b$3}function isodata(histogram$1){let l$2,toth,totl,h$3,g$1=0;for(let i$3=1;i$3<histogram$1.length;i$3++)if(histogram$1[i$3]>0){g$1=i$3+1;break}for(;;){l$2=0,totl=0;for(let i$3=0;i$3<g$1;i$3++)totl+=histogram$1[i$3],l$2+=histogram$1[i$3]*i$3;h$3=0,toth=0;for(let i$3=g$1+1;i$3<histogram$1.length;i$3++)toth+=histogram$1[i$3],h$3+=histogram$1[i$3]*i$3;if(totl>0&&toth>0&&(l$2/=totl,h$3/=toth,g$1===Math.round((l$2+h$3)/2)))break;g$1++,assert(g$1<=histogram$1.length-2,`Threshold not found`)}return g$1}function li(histogram$1,total){let threshold$1,sumBack,sumObj,numBack,numObj,oldThresh,newThresh,meanBack,meanObj,mean$2,tolerance=.5,temp;mean$2=0;for(let ih=0;ih<histogram$1.length;ih++)mean$2+=ih*histogram$1[ih];mean$2/=total,newThresh=mean$2;do{oldThresh=newThresh,threshold$1=oldThresh+.5|0,sumBack=0,numBack=0;for(let ih=0;ih<=threshold$1;ih++)sumBack+=ih*histogram$1[ih],numBack+=histogram$1[ih];meanBack=numBack===0?0:sumBack/numBack,sumObj=0,numObj=0;for(let ih=threshold$1+1;ih<histogram$1.length;ih++)sumObj+=ih*histogram$1[ih],numObj+=histogram$1[ih];meanObj=numObj===0?0:sumObj/numObj,temp=(meanBack-meanObj)/(Math.log(meanBack)-Math.log(meanObj)),newThresh=temp<-(2**-52)?temp-.5|0:temp+.5|0}while(Math.abs(newThresh-oldThresh)>.5);return threshold$1}function maxEntropy(histogram$1,total){let normHisto=Array(histogram$1.length);for(let ih=0;ih<histogram$1.length;ih++)normHisto[ih]=histogram$1[ih]/total;let P1=Array(histogram$1.length),P2=Array(histogram$1.length);P1[0]=normHisto[0],P2[0]=1-P1[0];for(let ih=1;ih<histogram$1.length;ih++)P1[ih]=P1[ih-1]+normHisto[ih],P2[ih]=1-P1[ih];let firstBin=0;for(let ih=0;ih<histogram$1.length;ih++)if(Math.abs(P1[ih])>=2**-52){firstBin=ih;break}let lastBin=histogram$1.length-1;for(let ih=histogram$1.length-1;ih>=firstBin;ih--)if(Math.abs(P2[ih])>=2**-52){lastBin=ih;break}let threshold$1=-1,totEnt,maxEnt=Number.MIN_VALUE,entBack,entObj;for(let it=firstBin;it<=lastBin;it++){entBack=0;for(let ih=0;ih<=it;ih++)histogram$1[ih]!==0&&(entBack-=normHisto[ih]/P1[it]*Math.log(normHisto[ih]/P1[it]));entObj=0;for(let ih=it+1;ih<histogram$1.length;ih++)histogram$1[ih]!==0&&(entObj-=normHisto[ih]/P2[it]*Math.log(normHisto[ih]/P2[it]));totEnt=entBack+entObj,maxEnt<totEnt&&(maxEnt=totEnt,threshold$1=it)}return threshold$1}function mean$1(histogram$1,total){let sum=0;for(let i$3=0;i$3<histogram$1.length;i$3++)sum+=i$3*histogram$1[i$3];return Math.floor(sum/total)}function minError(histogram$1,total){let threshold$1,Tprev=-2,mu,nu,p$3,q,sigma2,tau2,w0,w1,w2,sqterm,temp,mean$2=0;for(let ih=0;ih<histogram$1.length;ih++)mean$2+=ih*histogram$1[ih];for(mean$2/=total,threshold$1=mean$2;threshold$1!==Tprev;){let sumA1=sumA(histogram$1,threshold$1),sumA2=sumA(histogram$1,histogram$1.length-1),sumB1=sumB(histogram$1,threshold$1),sumB2=sumB(histogram$1,histogram$1.length-1),sumC1=sumC(histogram$1,threshold$1),sumC2=sumC(histogram$1,histogram$1.length-1);if(mu=sumB1/sumA1,nu=(sumB2-sumB1)/(sumA2-sumA1),p$3=sumA1/sumA2,q=(sumA2-sumA1)/sumA2,sigma2=sumC1/sumA1-mu*mu,tau2=(sumC2-sumC1)/(sumA2-sumA1)-nu*nu,w0=1/sigma2-1/tau2,w1=mu/sigma2-nu/tau2,w2=mu*mu/sigma2-nu*nu/tau2+Math.log10(sigma2*(q*q)/(tau2*(p$3*p$3))),sqterm=w1*w1-w0*w2,sqterm<0)return threshold$1;Tprev=threshold$1,temp=(w1+Math.sqrt(sqterm))/w0,threshold$1=Number.isNaN(temp)?Tprev:Math.floor(temp)}return threshold$1}function sumA(y$2,j$2){let x$2=0;for(let i$3=0;i$3<=j$2;i$3++)x$2+=y$2[i$3];return x$2}function sumB(y$2,j$2){let x$2=0;for(let i$3=0;i$3<=j$2;i$3++)x$2+=i$3*y$2[i$3];return x$2}function sumC(y$2,j$2){let x$2=0;for(let i$3=0;i$3<=j$2;i$3++)x$2+=i$3*i$3*y$2[i$3];return x$2}function minimum(histogram$1){if(histogram$1.length<2)return 0;let iterations=0,threshold$1=-1,max$2=-1,histogramCopy=Array(histogram$1.length);for(let i$3=0;i$3<histogram$1.length;i$3++)histogramCopy[i$3]=histogram$1[i$3],histogram$1[i$3]>0&&(max$2=i$3);for(;!bimodalTest(histogramCopy);)if(histogramCopy=smoothed(histogramCopy),iterations++,iterations>1e4)return threshold$1;for(let i$3=1;i$3<max$2;i$3++)if(histogramCopy[i$3-1]>histogramCopy[i$3]&&histogramCopy[i$3+1]>=histogramCopy[i$3]){threshold$1=i$3;break}return threshold$1}function smoothed(histogram$1){let auHistogram=Array(histogram$1.length);for(let i$3=1;i$3<histogram$1.length-1;i$3++)auHistogram[i$3]=(histogram$1[i$3-1]+histogram$1[i$3]+histogram$1[i$3+1])/3;return auHistogram[0]=(histogram$1[0]+histogram$1[1])/3,auHistogram[histogram$1.length-1]=(histogram$1.at(-2)+histogram$1.at(-1))/3,auHistogram}function bimodalTest(histogram$1){let len=histogram$1.length,isBimodal=!1,peaks=0;for(let k$2=1;k$2<len-1;k$2++)if(histogram$1[k$2-1]<histogram$1[k$2]&&histogram$1[k$2+1]<histogram$1[k$2]&&(peaks++,peaks>2))return!1;return peaks===2&&(isBimodal=!0),isBimodal}function moments(histogram$1,total){let m0=1,m1=0,m2=0,m3=0,sum=0,threshold$1=-1,histogramLength=histogram$1.length,normalizedHistogram=[];for(let i$3=0;i$3<histogramLength;i$3++)normalizedHistogram.push(histogram$1[i$3]/total);for(let i$3=0;i$3<histogramLength;i$3++)m1+=i$3*normalizedHistogram[i$3],m2+=i$3*i$3*normalizedHistogram[i$3],m3+=i$3*i$3*i$3*normalizedHistogram[i$3];let cd=1*m2-m1*m1,c0=(-m2*m2+m1*m3)/cd,c1=(1*-m3+m2*m1)/cd,z0=.5*(-c1-Math.sqrt(c1*c1-4*c0)),z1=.5*(-c1+Math.sqrt(c1*c1-4*c0)),p0=(z1-m1)/(z1-z0);for(let i$3=0;i$3<histogramLength;i$3++)if(sum+=normalizedHistogram[i$3],sum>p0){threshold$1=i$3;break}return threshold$1}function otsu(histogramCounts,total){let sumB$1=0,wB=0,maximum=0,level$1=0,sum1=0;for(let i$3=0;i$3<histogramCounts.length;i$3++)sum1+=i$3*histogramCounts[i$3];for(let ii=0;ii<histogramCounts.length;ii++){wB+=histogramCounts[ii];let wF=total-wB;if(wB===0||wF===0)continue;sumB$1+=ii*histogramCounts[ii];let mF=(sum1-sumB$1)/wF,between=wB*wF*(sumB$1/wB-mF)*(sumB$1/wB-mF);between>=maximum&&(level$1=ii,maximum=between)}return level$1}function percentile(histogram$1){let threshold$1=-1,percentile$1=.5,avec=Array(histogram$1.length),total=partialSum(histogram$1,histogram$1.length-1),temp=1;for(let i$3=0;i$3<histogram$1.length;i$3++)avec[i$3]=Math.abs(partialSum(histogram$1,i$3)/total-.5),avec[i$3]<temp&&(temp=avec[i$3],threshold$1=i$3);return threshold$1}function partialSum(histogram$1,endIndex){let x$2=0;for(let i$3=0;i$3<=endIndex;i$3++)x$2+=histogram$1[i$3];return x$2}function renyiEntropy(histogram$1,total){let firstBin,lastBin,normHisto=Array(histogram$1.length),P1=Array(histogram$1.length),P2=Array(histogram$1.length),threshold1=0,threshold2=0,threshold3=0,maxEnt1=0,maxEnt2=0,maxEnt3=0,term2=1/.5,term3=1/-1;for(let ih=0;ih<histogram$1.length;ih++)normHisto[ih]=histogram$1[ih]/total;P1[0]=normHisto[0],P2[0]=1-P1[0];for(let ih=1;ih<histogram$1.length;ih++)P1[ih]=P1[ih-1]+normHisto[ih],P2[ih]=1-P1[ih];firstBin=0;for(let ih=0;ih<histogram$1.length;ih++)if(Math.abs(P1[ih])>=2**-52){firstBin=ih;break}lastBin=histogram$1.length-1;for(let ih=histogram$1.length-1;ih>=firstBin;ih--)if(Math.abs(P2[ih])>=2**-52){lastBin=ih;break}for(let it=firstBin;it<=lastBin;it++){let entBack1=0,entBack2=0,entBack3=0;for(let ih=0;ih<=it;ih++)histogram$1[ih]!==0&&(entBack1-=normHisto[ih]/P1[it]*Math.log(normHisto[ih]/P1[it])),entBack2+=Math.sqrt(normHisto[ih]/P1[it]),entBack3+=normHisto[ih]*normHisto[ih]/(P1[it]*P1[it]);let entObj1=0,entObj2=0,entObj3=0;for(let ih=it+1;ih<histogram$1.length;ih++)histogram$1[ih]!==0&&(entObj1-=normHisto[ih]/P2[it]*Math.log(normHisto[ih]/P2[it])),entObj2+=Math.sqrt(normHisto[ih]/P2[it]),entObj3+=normHisto[ih]*normHisto[ih]/(P2[it]*P2[it]);let totEnt1=entBack1+entObj1,totEnt2=2*(entBack2*entObj2>0?Math.log(entBack2*entObj2):0),totEnt3=-1*(entBack3*entObj3>0?Math.log(entBack3*entObj3):0);totEnt1>maxEnt1&&(maxEnt1=totEnt1,threshold1=it),totEnt2>maxEnt2&&(maxEnt2=totEnt2,threshold2=it),totEnt3>maxEnt3&&(maxEnt3=totEnt3,threshold3=it)}let tStars=new Uint32Array([threshold1,threshold2,threshold3]);tStars.sort();let betas;betas=Math.abs(tStars[0]-tStars[1])<=5?Math.abs(tStars[1]-tStars[2])<=5?[1,2,1]:[0,1,3]:Math.abs(tStars[1]-tStars[2])<=5?[3,1,0]:[1,2,1];let omega=P1[tStars[2]]-P1[tStars[0]];return Math.round(tStars[0]*(P1[tStars[0]]+.25*omega*betas[0])+.25*tStars[1]*omega*betas[1]+tStars[2]*(P2[tStars[2]]+.25*omega*betas[2]))}function shanbhag(histogram$1,total){let normHisto=Array(histogram$1.length);for(let ih=0;ih<histogram$1.length;ih++)normHisto[ih]=histogram$1[ih]/total;let P1=Array(histogram$1.length),P2=Array(histogram$1.length);P1[0]=normHisto[0],P2[0]=1-P1[0];for(let ih=1;ih<histogram$1.length;ih++)P1[ih]=P1[ih-1]+normHisto[ih],P2[ih]=1-P1[ih];let firstBin=0;for(let ih=0;ih<histogram$1.length;ih++)if(Math.abs(P1[ih])>=2**-52){firstBin=ih;break}let lastBin=histogram$1.length-1;for(let ih=histogram$1.length-1;ih>=firstBin;ih--)if(Math.abs(P2[ih])>=2**-52){lastBin=ih;break}let threshold$1=-1,minEnt=Number.MAX_VALUE,term,totEnt,entBack,entObj;for(let it=firstBin;it<=lastBin;it++){entBack=0,term=.5/P1[it];for(let ih=1;ih<=it;ih++)entBack-=normHisto[ih]*Math.log(1-term*P1[ih-1]);entBack*=term,entObj=0,term=.5/P2[it];for(let ih=it+1;ih<histogram$1.length;ih++)entObj-=normHisto[ih]*Math.log(1-term*P2[ih]);entObj*=term,totEnt=Math.abs(entBack-entObj),totEnt<minEnt&&(minEnt=totEnt,threshold$1=it)}return threshold$1}function triangle(histogram$1){let min$2=0,dmax=0,max$2=0,min2=0;for(let i$3=0;i$3<histogram$1.length;i$3++)if(histogram$1[i$3]>0){min$2=i$3;break}min$2>0&&min$2--;for(let i$3=histogram$1.length-1;i$3>0;i$3--)if(histogram$1[i$3]>0){min2=i$3;break}min2<histogram$1.length-1&&min2++;for(let i$3=0;i$3<histogram$1.length;i$3++)histogram$1[i$3]>dmax&&(max$2=i$3,dmax=histogram$1[i$3]);let inverted=!1;if(max$2-min$2<min2-max$2){inverted=!0;let left=0,right=histogram$1.length-1;for(;left<right;){let temp=histogram$1[left];histogram$1[left]=histogram$1[right],histogram$1[right]=temp,left++,right--}min$2=histogram$1.length-1-min2,max$2=histogram$1.length-1-max$2}if(min$2===max$2)return min$2;let nx,ny,d$2;nx=histogram$1[max$2],ny=min$2-max$2,d$2=Math.hypot(nx,ny),nx/=d$2,ny/=d$2,d$2=nx*min$2+ny*histogram$1[min$2];let split$1=min$2,splitDistance=0;for(let i$3=min$2+1;i$3<=max$2;i$3++){let newDistance=nx*i$3+ny*histogram$1[i$3]-d$2;newDistance>splitDistance&&(split$1=i$3,splitDistance=newDistance)}if(split$1--,inverted){let left=0,right=histogram$1.length-1;for(;left<right;){let temp=histogram$1[left];histogram$1[left]=histogram$1[right],histogram$1[right]=temp,left++,right--}return histogram$1.length-1-split$1}else return split$1}function yen(histogram$1,total){let normHisto=Array(histogram$1.length);for(let ih=0;ih<histogram$1.length;ih++)normHisto[ih]=histogram$1[ih]/total;let P1=Array(histogram$1.length);P1[0]=normHisto[0];for(let ih=1;ih<histogram$1.length;ih++)P1[ih]=P1[ih-1]+normHisto[ih];let P1Sq=Array(histogram$1.length);P1Sq[0]=normHisto[0]*normHisto[0];for(let ih=1;ih<histogram$1.length;ih++)P1Sq[ih]=P1Sq[ih-1]+normHisto[ih]*normHisto[ih];let P2Sq=Array(histogram$1.length);P2Sq[histogram$1.length-1]=0;for(let ih=histogram$1.length-2;ih>=0;ih--)P2Sq[ih]=P2Sq[ih+1]+normHisto[ih+1]*normHisto[ih+1];let threshold$1=-1,maxCrit=Number.MIN_VALUE,crit;for(let it=0;it<histogram$1.length;it++)crit=-1*(P1Sq[it]*P2Sq[it]>0?Math.log(P1Sq[it]*P2Sq[it]):0)+2*(P1[it]*(1-P1[it])>0?Math.log(P1[it]*(1-P1[it])):0),crit>maxCrit&&(maxCrit=crit,threshold$1=it);return threshold$1}function computeThreshold(image,options={}){let{algorithm=`otsu`,slots}=options;if(image.channels!==1)throw TypeError(`threshold can only be computed on images with one channel`);let histogram$1=image.histogram({slots}),scale=slots?2**image.bitDepth/slots:1;return M(algorithm).with(`huang`,()=>huang(histogram$1)*scale).with(`intermodes`,()=>intermodes(histogram$1)*scale).with(`isodata`,()=>isodata(histogram$1)*scale).with(`li`,()=>li(histogram$1,image.size)*scale).with(`maxEntropy`,()=>maxEntropy(histogram$1,image.size)*scale).with(`mean`,()=>mean$1(histogram$1,image.size)*scale).with(`minimum`,()=>minimum(histogram$1)*scale).with(`minError`,()=>minError(histogram$1,image.size)*scale).with(`moments`,()=>moments(histogram$1,image.size)*scale).with(`otsu`,()=>otsu(histogram$1,image.size)*scale).with(`percentile`,()=>percentile(histogram$1)*scale).with(`renyiEntropy`,()=>renyiEntropy(histogram$1,image.size)*scale).with(`shanbhag`,()=>shanbhag(histogram$1,image.size)*scale).with(`triangle`,()=>triangle(histogram$1)*scale).with(`yen`,()=>yen(histogram$1,image.size)*scale).exhaustive()}function threshold(image,options={}){let thresholdValue;if(`threshold`in options){let threshold$1=options.threshold;if(threshold$1<0||threshold$1>1)throw RangeError(`threshold must be a value between 0 and 1`);thresholdValue=threshold$1*image.maxValue}else thresholdValue=computeThreshold(image,options);let result=imageToOutputMask(image,options);for(let i$3=0;i$3<image.size;i$3++)result.setBitByIndex(i$3,image.getValueByIndex(i$3,0)>thresholdValue?1:0);return result}var greyAlgorithms_exports=__export({average:()=>average,black:()=>black,blue:()=>blue,cyan:()=>cyan,green:()=>green,hue:()=>hue,lightness:()=>lightness,luma601:()=>luma601,luma709:()=>luma709,magenta:()=>magenta,max:()=>max,min:()=>min,minmax:()=>minmax,red:()=>red,saturation:()=>saturation,yellow:()=>yellow});function luma709(red$1,green$1,blue$1){return red$1*6966+green$1*23436+blue$1*2366>>15}function luma601(red$1,green$1,blue$1){return red$1*9798+green$1*19235+blue$1*3735>>15}function max(red$1,green$1,blue$1){return Math.max(red$1,green$1,blue$1)}function min(red$1,green$1,blue$1){return Math.min(red$1,green$1,blue$1)}function average(red$1,green$1,blue$1){return(red$1+green$1+blue$1)/3>>0}function minmax(red$1,green$1,blue$1){return(Math.max(red$1,green$1,blue$1)+Math.min(red$1,green$1,blue$1))/2}function red(red$1){return red$1}function green(red$1,green$1){return green$1}function blue(red$1,green$1,blue$1){return blue$1}function black(red$1,green$1,blue$1,image){return Math.min(image.maxValue-red$1,image.maxValue-green$1,image.maxValue-blue$1)}function cyan(red$1,green$1,blue$1,image){let blackColor=black(red$1,green$1,blue$1,image);return(image.maxValue-red$1-blackColor)/(1-blackColor/image.maxValue)>>0}function magenta(red$1,green$1,blue$1,image){let blackColor=black(red$1,green$1,blue$1,image);return(image.maxValue-green$1-blackColor)/(1-blackColor/image.maxValue)>>0}function yellow(red$1,green$1,blue$1,image){let blackColor=black(red$1,green$1,blue$1,image);return(image.maxValue-blue$1-blackColor)/(1-blackColor/image.maxValue)>>0}function hue(red$1,green$1,blue$1,image){let minValue=min(red$1,green$1,blue$1),maxValue=max(red$1,green$1,blue$1);if(maxValue===minValue)return 0;let hue$1=0,delta=maxValue-minValue;return maxValue===red$1?hue$1=(green$1-blue$1)/delta+(green$1<blue$1?6:0):maxValue===green$1?hue$1=(blue$1-red$1)/delta+2:(assert(maxValue===blue$1),hue$1=(red$1-green$1)/delta+4),hue$1/6*image.maxValue>>0}function saturation(red$1,green$1,blue$1,image){let minValue=min(red$1,green$1,blue$1),maxValue=max(red$1,green$1,blue$1),delta=maxValue-minValue;return maxValue===0?0:delta/maxValue*image.maxValue}function lightness(red$1,green$1,blue$1){let minValue=min(red$1,green$1,blue$1);return(max(red$1,green$1,blue$1)+minValue)/2}const GreyAlgorithm={LUMA_709:`luma709`,LUMA_601:`luma601`,MAX:`max`,MIN:`min`,AVERAGE:`average`,MINMAX:`minmax`,RED:`red`,GREEN:`green`,BLUE:`blue`,BLACK:`black`,CYAN:`cyan`,MAGENTA:`magenta`,YELLOW:`yellow`,HUE:`hue`,SATURATION:`saturation`,LIGHTNESS:`lightness`};{let algos=new Set(Object.values(GreyAlgorithm));for(let algo of Object.keys(greyAlgorithms_exports))assert(algos.has(algo),`Grey algorithm ${algo} is missing in the GreyAlgorithm enum`)}function grey(image,options={}){let{keepAlpha=!1,mergeAlpha=!0}=options,{algorithm=`luma709`}=options;checkProcessable(image,{colorModel:[`RGB`,`RGBA`]}),keepAlpha&&=image.alpha,mergeAlpha&&=image.alpha,keepAlpha&&(mergeAlpha=!1);let newImage=getOutputImage(image,options,{newParameters:{colorModel:keepAlpha?`GREYA`:`GREY`}}),method;method=typeof algorithm==`function`?algorithm:greyAlgorithms_exports[algorithm];let clamp=getClamp(newImage);for(let i$3=0;i$3<image.size;i$3++){let red$1=image.getValueByIndex(i$3,0),green$1=image.getValueByIndex(i$3,1),blue$1=image.getValueByIndex(i$3,2),newValue;if(mergeAlpha){let alpha=image.getValueByIndex(i$3,3);newValue=clamp(method(red$1,green$1,blue$1,image)*alpha/image.maxValue)}else if(newValue=clamp(method(red$1,green$1,blue$1,image)),keepAlpha){let alpha=image.getValueByIndex(i$3,3);newImage.setValueByIndex(i$3,1,alpha)}newImage.setValueByIndex(i$3,0,newValue)}return newImage}function copyTo(source,target,options={}){let{origin={column:0,row:0}}=options,{column,row}=origin;if(source.colorModel!==target.colorModel)throw RangeError(`source and target must have the same color model`);checkPointIsInteger(origin,`Origin`);let result;result=target instanceof Image?getOutputImage(target,options,{clone:!0}):maskToOutputMask(target,options,{clone:!0});for(let currentRow=Math.max(row,0);currentRow<Math.min(source.height+row,target.height);currentRow++)for(let currentColumn=Math.max(column,0);currentColumn<Math.min(source.width+column,target.width);currentColumn++){let sourcePixel=source.getPixel(currentColumn-column,currentRow-row);setBlendedPixel(result,currentColumn,currentRow,sourcePixel)}return result}function crop(image,options={}){let{origin={row:0,column:0},width=image.width-origin.column,height=image.height-origin.row}=options,{column,row}=origin;if(checkProcessable(image,{bitDepth:[8,16]}),checkPointIsInteger(origin,`Origin`),!Number.isInteger(width)||!Number.isInteger(height))throw RangeError(`Width and height (width:${width}; height:${height}) must be integers`);if(row>image.height-1||column>image.width-1)throw RangeError(`Origin (row:${row}, column:${column}) out of range (${image.width-1}; ${image.height-1})`);if(width<=0||height<=0)throw RangeError(`Width and height (width:${width}; height:${height}) must be positive numbers`);if(row<0||column<0)throw RangeError(`Row and column (row:${row}, column:${column}) must be positive numbers`);if(width>image.width-column||height>image.height-row)throw RangeError(`Size is out of range (row:${row}, column:${column}, width:${width}, height:${height})`);let newImage=Image.createFrom(image,{width,height});for(let currentRow=0;currentRow<height;currentRow++)for(let currentColumn=0;currentColumn<width;currentColumn++)newImage.setPixel(currentColumn,currentRow,image.getPixel(column+currentColumn,row+currentRow));return newImage}function cropAlpha(image,options={}){checkProcessable(image,{alpha:!0});let{threshold:threshold$1=image.maxValue}=options,left=findLeft(image,threshold$1,image.components);if(left===-1)throw RangeError(`could not find new dimensions. Threshold may be too high: ${threshold$1}`);let top=findTop(image,threshold$1,image.components,left),bottom=findBottom(image,threshold$1,image.components,left),right=findRight(image,threshold$1,image.components,left,top,bottom);return image.crop({origin:{column:left,row:top},width:right-left+1,height:bottom-top+1})}function findLeft(image,threshold$1,channel){for(let row=0;row<image.width;row++)for(let column=0;column<image.height;column++)if(image.getValue(row,column,channel)>=threshold$1)return row;return-1}function findTop(image,threshold$1,channel,left){for(let row=0;row<image.height;row++)for(let column=left;column<image.width;column++)if(image.getValue(column,row,channel)>=threshold$1)return row;return-1}function findBottom(image,threshold$1,channel,left){for(let row=image.height-1;row>=0;row--)for(let column=left;column<image.width;column++)if(image.getValue(column,row,channel)>=threshold$1)return row;return-1}function findRight(image,threshold$1,channel,left,top,bottom){for(let row=image.width-1;row>=left;row--)for(let column=top;column<=bottom;column++)if(image.getValue(row,column,channel)>=threshold$1)return row;return-1}function getInterpolationFunction(interpolationType){return M(interpolationType).with(`nearest`,()=>interpolateNearest).with(`bilinear`,()=>interpolateBilinear).with(`bicubic`,()=>interpolateBicubic).exhaustive()}function interpolateNearest(image,column,row,channel,interpolateBorder){return column=Math.round(column),row=Math.round(row),interpolateBorder(column,row,channel,image)}function interpolateBilinear(image,column,row,channel,interpolateBorder){let px0=Math.floor(column),py0=Math.floor(row),px1=px0+1,py1=py0+1;if(px1<image.width&&py1<image.height&&px0>=0&&py0>=0){let vx0y0=image.getValue(px0,py0,channel),vx1y0=image.getValue(px1,py0,channel),vx0y1=image.getValue(px0,py1,channel),vx1y1=image.getValue(px1,py1,channel),r1=(px1-column)*vx0y0+(column-px0)*vx1y0,r2=(px1-column)*vx0y1+(column-px0)*vx1y1;return round((py1-row)*r1+(row-py0)*r2)}else{let vx0y0=interpolateBorder(px0,py0,channel,image),vx1y0=interpolateBorder(px1,py0,channel,image),vx0y1=interpolateBorder(px0,py1,channel,image),vx1y1=interpolateBorder(px1,py1,channel,image),r1=(px1-column)*vx0y0+(column-px0)*vx1y0,r2=(px1-column)*vx0y1+(column-px0)*vx1y1;return round((py1-row)*r1+(row-py0)*r2)}}function interpolateBicubic(image,column,row,channel,interpolateBorder,clamp){let px1=Math.floor(column),py1=Math.floor(row);if(px1===column&&py1===row)return interpolateBorder(px1,py1,channel,image);let xNorm=column-px1,yNorm=row-py1,vx0y0=interpolateBorder(px1-1,py1-1,channel,image),vx1y0=interpolateBorder(px1,py1-1,channel,image),vx2y0=interpolateBorder(px1+1,py1-1,channel,image),vx3y0=interpolateBorder(px1+2,py1-1,channel,image),v0=cubic(vx0y0,vx1y0,vx2y0,vx3y0,xNorm),vx0y1=interpolateBorder(px1-1,py1,channel,image),vx1y1=interpolateBorder(px1,py1,channel,image),vx2y1=interpolateBorder(px1+1,py1,channel,image),vx3y1=interpolateBorder(px1+2,py1,channel,image),v1=cubic(vx0y1,vx1y1,vx2y1,vx3y1,xNorm),vx0y2=interpolateBorder(px1-1,py1+1,channel,image),vx1y2=interpolateBorder(px1,py1+1,channel,image),vx2y2=interpolateBorder(px1+1,py1+1,channel,image),vx3y2=interpolateBorder(px1+2,py1+1,channel,image),v2=cubic(vx0y2,vx1y2,vx2y2,vx3y2,xNorm),vx0y3=interpolateBorder(px1-1,py1+2,channel,image),vx1y3=interpolateBorder(px1,py1+2,channel,image),vx2y3=interpolateBorder(px1+1,py1+2,channel,image),vx3y3=interpolateBorder(px1+2,py1+2,channel,image),v3=cubic(vx0y3,vx1y3,vx2y3,vx3y3,xNorm);return round(clamp(cubic(v0,v1,v2,v3,yNorm)))}function cubic(a$3,b$3,c$2,d$2,x$2){return b$3+.5*x$2*(c$2-a$3+x$2*(2*a$3-5*b$3+4*c$2-d$2+x$2*(3*(b$3-c$2)+d$2-a$3)))}function transform(image,transformMatrix,options={}){let{borderType=`constant`,borderValue=0,interpolationType=`bilinear`,fullImage}=options,{width=image.width,height=image.height}=options;if(!isValidMatrix(transformMatrix))throw TypeError(`transformation matrix must be 2x3 or 3x3. Received ${transformMatrix.length}x${transformMatrix[1].length}`);if(transformMatrix.length===2&&transformMatrix.push([0,0,1]),fullImage){transformMatrix=transformMatrix.map(row=>row.slice()),transformMatrix[0][2]=0,transformMatrix[1][2]=0;let corners=[image.getCoordinates(`top-left`),image.getCoordinates(`top-right`),image.getCoordinates(`bottom-right`),image.getCoordinates(`bottom-left`)];corners[1].column+=1,corners[2].column+=1,corners[2].row+=1,corners[3].row+=1;let transformedCorners=corners.map(corner=>[transformPoint(transformMatrix[0],transformMatrix[2],corner.column,corner.row),transformPoint(transformMatrix[1],transformMatrix[2],corner.column,corner.row)]),xCoordinates=transformedCorners.map(c$2=>c$2[0]),yCoordinates=transformedCorners.map(c$2=>c$2[1]),maxX=Math.max(...xCoordinates),maxY=Math.max(...yCoordinates),minX=Math.min(...xCoordinates),minY=Math.min(...yCoordinates),center=[(image.width-1)/2,(image.height-1)/2];width=maxX-minX,height=maxY-minY;let centerX=transformPoint(transformMatrix[0],transformMatrix[2],center[0],center[1]),centerY=transformPoint(transformMatrix[1],transformMatrix[2],center[0],center[1]),a$3=(width-1)/2-centerX,b$3=(height-1)/2-centerY;transformMatrix[0][2]=a$3,transformMatrix[1][2]=b$3,width=Math.round(width),height=Math.round(height)}options.inverse||(transformMatrix=inverse(new Matrix(transformMatrix)).to2DArray());let newImage=Image.createFrom(image,{width,height}),interpolateBorder=getBorderInterpolation(borderType,borderValue),clamp=getClamp(newImage),interpolate=getInterpolationFunction(interpolationType);for(let row=0;row<newImage.height;row++)for(let column=0;column<newImage.width;column++){let nx=transformPoint(transformMatrix[0],transformMatrix[2],column,row),ny=transformPoint(transformMatrix[1],transformMatrix[2],column,row);for(let channel=0;channel<newImage.channels;channel++){let newValue=interpolate(image,nx,ny,channel,interpolateBorder,clamp);newImage.setValue(column,row,channel,newValue)}}return newImage}function transformPoint(transform$1,perspective,column,row){return(transform$1[0]*column+transform$1[1]*row+transform$1[2])/(perspective[0]*column+perspective[1]*row+perspective[2])}function isValidMatrix(transformationMatrix){return transformationMatrix.length===3&&transformationMatrix[0].length===3&&transformationMatrix[1].length===3&&transformationMatrix[2].length===3||transformationMatrix.length===2&&transformationMatrix[0].length===3&&transformationMatrix[1].length===3}function resize(image,options){let{interpolationType=`bilinear`,borderType=`replicate`,borderValue=0}=options,{width,height,xFactor,yFactor}=checkOptions(image,options);return transform(image,[[xFactor,0,xFactor/2],[0,yFactor,yFactor/2]],{interpolationType,borderType,borderValue,height,width})}function checkOptions(image,options){let{width,height,xFactor,yFactor,preserveAspectRatio=!0}=options;if(width===void 0&&height===void 0&&xFactor===void 0&&yFactor===void 0)throw TypeError(`at least one of the width, height, xFactor or yFactor options must be passed`);let newWidth,newHeight,maybeWidth=getSize(width,xFactor,image.width,preserveAspectRatio),maybeHeight=getSize(height,yFactor,image.height,preserveAspectRatio);return maybeWidth===void 0?(assert(maybeHeight!==void 0),newWidth=Math.round(maybeHeight*(image.width/image.height))):newWidth=maybeWidth,maybeHeight===void 0?(assert(maybeWidth!==void 0),newHeight=Math.round(maybeWidth*(image.height/image.width))):newHeight=maybeHeight,{width:newWidth,height:newHeight,xFactor:xFactor??newWidth/image.width,yFactor:yFactor??newHeight/image.height}}function getSize(sizeOpt,factor,sizeImg,preserveAspectRatio){if(sizeOpt===void 0){if(factor!==void 0)return Math.round(sizeImg*factor);if(!preserveAspectRatio)return sizeImg}else if(factor!==void 0)throw TypeError(`factor and size cannot be passed together`);else return sizeOpt}function rotate(image,angle){let newWidth=angle%180==0?image.width:image.height,newHeight=angle%180==0?image.height:image.width,newImage=Image.createFrom(image,{width:newWidth,height:newHeight});if(angle===90||angle===-270)for(let column=0;column<image.width;column++)for(let row=0;row<image.height;row++)for(let channel=0;channel<image.channels;channel++)newImage.setValue(newImage.width-row-1,column,channel,image.getValue(column,row,channel));else if(angle===180||angle===-180)for(let column=0;column<image.width;column++)for(let row=0;row<image.height;row++)for(let channel=0;channel<image.channels;channel++)newImage.setValue(newImage.width-column-1,newImage.height-row-1,channel,image.getValue(column,row,channel));else if(angle===270||angle===-90)for(let column=0;column<image.width;column++)for(let row=0;row<image.height;row++)for(let channel=0;channel<image.channels;channel++)newImage.setValue(row,newImage.height-column-1,channel,image.getValue(column,row,channel));else throw RangeError(`invalid angle: ${angle}`);return newImage}function transformRotate(image,angle,options={}){let{center=`center`,scale=1,...otherOptions}=options,centerCoordinates;centerCoordinates=typeof center==`string`?image.getCoordinates(center):center;let transformMatrix=getRotationMatrix(angle,centerCoordinates,scale);return transform(image,transformMatrix,otherOptions)}function getRotationMatrix(angle,center,scale){let angleRadians=angle*Math.PI/180,cos=scale*Math.cos(angleRadians),sin=scale*Math.sin(angleRadians);return[[cos,sin,(1-cos)*center.column-sin*center.row],[-sin,cos,sin*center.column+(1-cos)*center.row],[0,0,1]]}function rotatePoint(point,rotationCenter,angle){let angleCos=Math.cos(angle),angleSin=Math.sin(angle),column=point.column*angleCos-point.row*angleSin+(1-angleCos)*rotationCenter.column+rotationCenter.row*angleSin,row=point.column*angleSin+point.row*angleCos+(1-angleCos)*rotationCenter.row-rotationCenter.column*angleSin;return{column,row}}function cropRectangle(image,points,options){if(points.length!==4)throw Error(`The points array must contain 4 points`);let angle=getSmallestAngle(points),center={row:(points[0].row+points[2].row)/2,column:(points[0].column+points[2].column)/2},rotatedPoints=points.map(p$3=>rotatePoint(p$3,center,angle)),[p1,p2,p3]=rotatedPoints,originalWidth=Math.max(Math.abs(p1.column-p2.column),Math.abs(p2.column-p3.column)),originalHeight=Math.max(Math.abs(p1.row-p2.row),Math.abs(p2.row-p3.row)),width=Math.min(Math.ceil(originalWidth),Math.ceil(originalWidth-1e-10)),height=Math.min(Math.ceil(originalHeight),Math.ceil(originalHeight-1e-10)),expandedTopLeft={row:Math.min(...rotatedPoints.map(p$3=>p$3.row))-(height-originalHeight)/2,column:Math.min(...rotatedPoints.map(p$3=>p$3.column))-(width-originalWidth)/2},translation=rotatePoint(expandedTopLeft,center,-angle),angleCos=Math.cos(-angle),angleSin=Math.sin(-angle),matrix=[[angleCos,-angleSin,translation.column],[angleSin,angleCos,translation.row]];return transform(image,matrix,{inverse:!0,width,height,...options})}function getSmallestAngle(points){let angleHorizontal=-getAngle(points[1],points[0]);angleHorizontal>Math.PI/2?angleHorizontal-=Math.PI:angleHorizontal<-Math.PI/2&&(angleHorizontal+=Math.PI);let angle=angleHorizontal;return Math.abs(angleHorizontal)>Math.PI/4&&(angle=angleHorizontal>0?-Math.PI/2+angleHorizontal:Math.PI/2+angleHorizontal),angle}function paintMaskOnImage(image,mask,options={}){let{origin={row:0,column:0},color=getDefaultColor(image),blend=!0}=options,{column,row}=origin;if(color.length!==image.channels)throw RangeError(`the given color is not compatible with the image`);checkPointIsInteger(origin,`Origin`);let result=getOutputImage(image,options,{clone:!0});if(blend){checkColorIsNumberArray(color);for(let currentRow=Math.max(row,0);currentRow<Math.min(mask.height+row,image.height);currentRow++)for(let currentColumn=Math.max(column,0);currentColumn<Math.min(mask.width+column,image.width);currentColumn++)mask.getBit(currentColumn-column,currentRow-row)&&setBlendedPixel(result,currentColumn,currentRow,color)}else for(let currentRow=Math.max(row,0);currentRow<Math.min(mask.height+row,image.height);currentRow++)for(let currentColumn=Math.max(column,0);currentColumn<Math.min(mask.width+column,image.width);currentColumn++)if(mask.getBit(currentColumn-column,currentRow-row))for(let channel=0;channel<image.channels;channel++){let currentValue=color[channel];typeof currentValue==`number`&&result.setValue(currentColumn,currentRow,channel,currentValue)}return result}function checkColorIsNumberArray(color){for(let channel of color)if(typeof channel!=`number`)throw TypeError(`cannot have null channels in color if blend is true`)}function paintMaskOnMask(image,mask,options={}){let{origin={row:0,column:0},value=1}=options,{column,row}=origin;checkPointIsInteger(origin,`Origin`);let result=maskToOutputMask(image,options,{clone:!0});for(let currentRow=Math.max(row,0);currentRow<Math.min(mask.height+row,image.height);currentRow++)for(let currentColumn=Math.max(column,0);currentColumn<Math.min(mask.width+column,image.width);currentColumn++)mask.getBit(currentColumn-column,currentRow-row)&&result.setBit(currentColumn,currentRow,value);return result}function invert(image,options){if(image instanceof Image){let newImage=getOutputImage(image,options);image.alpha&&copyAlpha(image,newImage);let{maxValue,size}=newImage;for(let i$3=0;i$3<size;i$3++)for(let component=0;component<image.components;component++)newImage.setValueByIndex(i$3,component,maxValue-image.getValueByIndex(i$3,component));return newImage}else{let newImage=maskToOutputMask(image,options);for(let i$3=0;i$3<newImage.size;i$3++)newImage.setBitByIndex(i$3,!image.getBitByIndex(i$3));return newImage}}function level(image,options={}){let minMax=image.minMax(),{inputMin=minMax.min,inputMax=minMax.max,outputMin=0,outputMax=image.maxValue,gamma=1}=options,{channels=Array(image.components).fill(0).map((value,index)=>index)}=options;validateChannels(channels,image),checkProcessable(image,{bitDepth:[8,16]});let newImage=getOutputImage(image,options,{clone:!0}),clamp=getClamp(image);inputMin=getValueArray(inputMin,image.channels),inputMax=getValueArray(inputMax,image.channels),outputMin=getValueArray(outputMin,image.channels),outputMax=getValueArray(outputMax,image.channels),gamma=getValueArray(gamma,image.channels);for(let row=0;row<image.height;row++)for(let column=0;column<image.width;column++)for(let channel of channels){let currentValue=image.getValue(column,row,channel),clamped=Math.max(Math.min(currentValue,inputMax[channel]),inputMin[channel]),ratio=clamp((clamped-inputMin[channel])/(inputMax[channel]-inputMin[channel]));Number.isNaN(ratio)&&(ratio=0);let result=clamp(ratio**(1/gamma[channel])*(outputMax[channel]-outputMin[channel])+outputMin[channel]);newImage.setValue(column,row,channel,result)}return newImage}function getValueArray(value,imageChannels){if(Array.isArray(value)){if(value.length===imageChannels)return value;throw RangeError(`array length is not compatible with channel option`)}else return Array(imageChannels).fill(value)}function or(mask,otherMask,options){let newMask=maskToOutputMask(mask,options);if(mask.width!==otherMask.width||mask.height!==otherMask.height)throw RangeError(`both masks must have the same size`);for(let i$3=0;i$3<newMask.size;i$3++)mask.getBitByIndex(i$3)||otherMask.getBitByIndex(i$3)?newMask.setBitByIndex(i$3,1):newMask.setBitByIndex(i$3,0);return newMask}function flipX(image){checkProcessable(image,{bitDepth:[8,16]});for(let row=0;row<image.height;row++)for(let column=0;column<Math.floor(image.width/2);column++){let currentCol=column,oppositeCol=image.width-column-1;for(let channel=0;channel<image.channels;channel++){let tmp=image.getValue(currentCol,row,channel);image.setValue(currentCol,row,channel,image.getValue(oppositeCol,row,channel)),image.setValue(oppositeCol,row,channel,tmp)}}return image}function flipY(image){checkProcessable(image,{bitDepth:[8,16]});for(let row=0;row<Math.floor(image.height/2);row++)for(let column=0;column<image.width;column++){let currentRow=row,oppositeRow=image.height-row-1;for(let channel=0;channel<image.channels;channel++){let tmp=image.getValue(column,currentRow,channel);image.setValue(column,currentRow,channel,image.getValue(column,oppositeRow,channel)),image.setValue(column,oppositeRow,channel,tmp)}}return image}function flip(image,options={}){let{axis=`horizontal`}=options,newImage=getOutputImage(image,options,{clone:!0});return axis===`horizontal`?flipX(newImage):flipY(axis===`vertical`?newImage:flipX(newImage))}function medianFilter(image,options){let{cellSize=3,borderType=`reflect101`,borderValue}=options;if(checkProcessable(image,{bitDepth:[8,16]}),cellSize<1)throw RangeError(`Invalid property "cellSize". Must be greater than 0. Received ${cellSize}.`);if(cellSize%2==0)throw RangeError(`Invalid property "cellSize". Must be an odd number. Received ${cellSize}.`);let interpolateBorder=getBorderInterpolation(borderType,borderValue),newImage=Image.createFrom(image),size=cellSize**2,cellValues=new Uint16Array(size),halfCellSize=(cellSize-1)/2;for(let channel=0;channel<image.channels;channel++)for(let row=0;row<image.height;row++)for(let column=0;column<image.width;column++){let n$3=0;for(let cellRow=-halfCellSize;cellRow<=halfCellSize;cellRow++)for(let cellColumn=-halfCellSize;cellColumn<=halfCellSize;cellColumn++)cellValues[n$3++]=interpolateBorder(column+cellColumn,row+cellRow,channel,image);newImage.setValue(column,row,channel,xMedian(cellValues))}return newImage}function pixelate(image,options){let{cellSize,algorithm=`center`}=options;if(!Number.isInteger(cellSize))throw TypeError(`cellSize must be an integer`);if(cellSize<2)throw RangeError(`cellSize must be greater than 1`);let newImage=getOutputImage(image,options),getCellValue=getCellValueFunction(algorithm);for(let channel=0;channel<image.channels;channel++)for(let column=0;column<image.width;column+=cellSize)for(let row=0;row<image.height;row+=cellSize){let currentCellWidth=Math.min(cellSize,image.width-column),currentCellHeight=Math.min(cellSize,image.height-row),value=getCellValue(image,channel,{width:currentCellWidth,height:currentCellHeight,origin:{column,row}});for(let newColumn=column;newColumn<column+currentCellWidth;newColumn++)for(let newRow=row;newRow<row+currentCellHeight;newRow++)newImage.setValue(newColumn,newRow,channel,value)}return newImage}function getCellCenter(image,channel,options){let center={column:Math.floor((options.origin.column+options.origin.column+options.width-1)/2),row:Math.floor((options.origin.row+options.origin.row+options.height-1)/2)};return image.getValue(center.column,center.row,channel)}function getCellMean(image,channel,options){let sum=0;for(let column=options.origin.column;column<options.origin.column+options.width;column++)for(let row=options.origin.row;row<options.origin.row+options.height;row++)sum+=image.getValue(column,row,channel);return Math.round(sum/(options.width*options.height))}function getCellMedian(image,channel,options){let array=[];for(let column=options.origin.column;column<options.origin.column+options.width;column++)for(let row=options.origin.row;row<options.origin.row+options.height;row++)array.push(image.getValue(column,row,channel));return xMedian(array)}function getCellValueFunction(algorithm){switch(algorithm){case`mean`:return getCellMean;case`median`:return getCellMedian;case`center`:return getCellCenter;default:assertUnreachable(algorithm);break}}function getBorderPoints(mask,options={}){let{innerBorders=!1,allowCorners=!1}=options;innerBorders||(mask=mask.solidFill());let borders=[];for(let column=0;column<mask.width;column++)mask.getBit(column,0)&&borders.push({column,row:0}),mask.getBit(column,mask.height-1)&&borders.push({column,row:mask.height-1});for(let row=0;row<mask.height;row++)mask.getBit(0,row)&&borders.push({column:0,row}),mask.getBit(mask.width-1,row)&&borders.push({column:mask.width-1,row});for(let row=1;row<mask.height-1;row++)for(let column=1;column<mask.width-1;column++)mask.getBit(column,row)&&((mask.getBit(column-1,row)===0||mask.getBit(column,row-1)===0||mask.getBit(column+1,row)===0||mask.getBit(column,row+1)===0)&&borders.push({column,row}),allowCorners&&(mask.getBit(column-1,row-1)===0||mask.getBit(column-1,row+1)===0||mask.getBit(column+1,row-1)===0||mask.getBit(column+1,row+1)===0)&&borders.push({column,row}));return borders}function getLineLength(p1,p2){return Math.hypot(p1.column-p2.column,p1.row-p2.row)}function getPolygonPerimeter(points){let perimeter=0;for(let i$3=0;i$3<points.length;i$3++)perimeter+=getLineLength(points[(i$3+1)%points.length],points[i$3]);return perimeter}function getPolygonArea(points){let area=0;for(let current=0;current<points.length;current++){let next=(current+1)%points.length;area+=points[current].column*points[next].row,area-=points[current].row*points[next].column}return Math.abs(area/2)}function getExtendedBorderPoints(mask){let borderPoints=mask.getBorderPoints({allowCorners:!0,innerBorders:!1}),result=[];for(let point of borderPoints)result.push(point,{column:point.column+1,row:point.row},{column:point.column+1,row:point.row+1},{column:point.column,row:point.row+1});return result}function monotoneChainConvexHull(points,options={}){let{sorted=!1}=options;sorted||(points=points.slice(),points.sort(byXThenY));let n$3=points.length,result=Array(n$3*2),k$2=0;for(let i$3=0;i$3<n$3;i$3++){let point=points[i$3];for(;k$2>=2&&cw(result[k$2-2],result[k$2-1],point)<=0;)k$2--;result[k$2++]=point}let t$3=k$2+1;for(let i$3=n$3-2;i$3>=0;i$3--){let point=points[i$3];for(;k$2>=t$3&&cw(result[k$2-2],result[k$2-1],point)<=0;)k$2--;result[k$2++]=point}return result.slice(0,k$2-1)}function cw(p1,p2,p3){return(p2.row-p1.row)*(p3.column-p1.column)-(p2.column-p1.column)*(p3.row-p1.row)}function byXThenY(point1,point2){return point1.column===point2.column?point1.row-point2.row:point1.column-point2.column}function getConvexHull(mask){let borderPoints=getExtendedBorderPoints(mask);if(borderPoints.length===0)return{points:[],surface:0,perimeter:0};let points=monotoneChainConvexHull(borderPoints),perimeter=getPolygonPerimeter(points),surface=getPolygonArea(points);return{points,perimeter,surface}}function getFeret(mask){let hull=mask.getConvexHull(),hullPoints=hull.points;if(hull.surface===0)return{minDiameter:{length:0,points:[{column:0,row:0},{column:0,row:0}],angle:0,calliperLines:[[{column:0,row:0},{column:0,row:0}],[{column:0,row:0},{column:0,row:0}]]},maxDiameter:{length:0,points:[{column:0,row:0},{column:0,row:0}],angle:0,calliperLines:[[{column:0,row:0},{column:0,row:0}],[{column:0,row:0},{column:0,row:0}]]},aspectRatio:1};let minWidth=1/0,minWidthAngle=0,minLinePoints=[],minLines;for(let i$3=0;i$3<hullPoints.length;i$3++){let angle=getAngle(hullPoints[i$3],hullPoints[(i$3+1)%hullPoints.length]),rotatedPoints=rotate$1(-angle,hullPoints),currentWidth=0,currentMinLinePoints=[];for(let j$2=0;j$2<hullPoints.length;j$2++){let absWidth=Math.abs(rotatedPoints[i$3].row-rotatedPoints[j$2].row);absWidth>currentWidth&&(currentWidth=absWidth,currentMinLinePoints=[rotatedPoints[i$3],rotatedPoints[j$2]])}if(currentWidth<minWidth){minWidth=currentWidth,minWidthAngle=angle,minLinePoints=currentMinLinePoints;let{minIndex:currentMin$1,maxIndex:currentMax$1}=findPointIndexesOfExtremeColumns(rotatedPoints);minLines=getMinLines(minWidthAngle,currentMin$1,currentMax$1,rotatedPoints,minLinePoints)}}let minDiameter={points:rotate$1(minWidthAngle,minLinePoints),length:minWidth,angle:toDegrees(minWidthAngle),calliperLines:minLines},maxLinePoints=[],maxSquaredWidth=0,maxLineIndex=[];for(let i$3=0;i$3<hullPoints.length-1;i$3++)for(let j$2=i$3+1;j$2<hullPoints.length;j$2++){let currentSquaredWidth=(hullPoints[i$3].column-hullPoints[j$2].column)**2+(hullPoints[i$3].row-hullPoints[j$2].row)**2;currentSquaredWidth>maxSquaredWidth&&(maxSquaredWidth=currentSquaredWidth,maxLinePoints=[hullPoints[i$3],hullPoints[j$2]],maxLineIndex=[i$3,j$2])}let maxAngle=getAngle(maxLinePoints[0],maxLinePoints[1]),rotatedMaxPoints=rotate$1(-maxAngle,hullPoints),{minIndex:currentMin,maxIndex:currentMax}=findPointsIndexesOfExtremeRows(rotatedMaxPoints),maxLines=getMaxLines(maxAngle,currentMin,currentMax,rotatedMaxPoints,maxLineIndex),maxDiameter={length:Math.sqrt(maxSquaredWidth),angle:toDegrees(getAngle(maxLinePoints[0],maxLinePoints[1])),points:maxLinePoints,calliperLines:maxLines};return{minDiameter,maxDiameter,aspectRatio:minDiameter.length/maxDiameter.length}}function findPointIndexesOfExtremeColumns(points){let maxIndex=0,minIndex=0;for(let i$3=0;i$3<points.length;i$3++)points[i$3].column>points[maxIndex].column&&(maxIndex=i$3),points[i$3].column<points[minIndex].column&&(minIndex=i$3);return{minIndex,maxIndex}}function findPointsIndexesOfExtremeRows(points){let maxIndex=0,minIndex=0;for(let i$3=0;i$3<points.length;i$3++)points[i$3].row>points[maxIndex].row&&(maxIndex=i$3),points[i$3].row<points[minIndex].row&&(minIndex=i$3);return{minIndex,maxIndex}}function getMinLines(angle,min$2,max$2,rotatedPoints,feretPoints){let minLine1=[{column:rotatedPoints[min$2].column,row:feretPoints[0].row},{column:rotatedPoints[max$2].column,row:feretPoints[0].row}],minLine2=[{column:rotatedPoints[min$2].column,row:feretPoints[1].row},{column:rotatedPoints[max$2].column,row:feretPoints[1].row}];return[rotate$1(angle,minLine1),rotate$1(angle,minLine2)]}function getMaxLines(angle,min$2,max$2,rotatedPoints,index){let maxLine1=[{column:rotatedPoints[index[0]].column,row:rotatedPoints[min$2].row},{column:rotatedPoints[index[0]].column,row:rotatedPoints[max$2].row}],maxLine2=[{column:rotatedPoints[index[1]].column,row:rotatedPoints[min$2].row},{column:rotatedPoints[index[1]].column,row:rotatedPoints[max$2].row}];return[rotate$1(angle,maxLine1),rotate$1(angle,maxLine2)]}var leftFirst=(mbrPoint1,mbrPoint2)=>mbrPoint1.column<=mbrPoint2.column?-1:1,topFirst=(mbrPoint1,mbrPoint2)=>mbrPoint1.row>=mbrPoint2.row?-1:1;function getMbrAngle(mbr){let sorted=mbr.slice();sorted.sort(leftFirst);let left=sorted.slice(0,2),right=sorted.slice(2,4);left.sort(topFirst),right.sort(topFirst);let topLeft=left[0],topRight=right[0];return-toDegrees(getAngle(topLeft,topRight))}function getMbrFromPoints(points){if(points.length===0)return{points:[],angle:0,width:0,height:0,surface:0,perimeter:0,aspectRatio:0};if(points.length===1)return{points:[points[0],points[0],points[0],points[0]],perimeter:0,surface:0,angle:0,width:0,height:0,aspectRatio:1};let rotatedVertices=[],minSurface=1/0,minSurfaceAngle=0,mbr=[];for(let i$3=0;i$3<points.length;i$3++){let angle=getAngle(points[i$3],points[(i$3+1)%points.length]);rotatedVertices=rotate$1(-angle,points);let aX=rotatedVertices[i$3].column,aY=rotatedVertices[i$3].row,bX=rotatedVertices[(i$3+1)%rotatedVertices.length].column,bY=rotatedVertices[(i$3+1)%rotatedVertices.length].row,tUndefined=!0,tMin=0,tMax=0,maxWidth=0;for(let point of rotatedVertices){let cX=point.column,cY=point.row,t$3=(cX-aX)/(bX-aX);tUndefined?(tUndefined=!1,tMin=t$3,tMax=t$3):(t$3<tMin&&(tMin=t$3),t$3>tMax&&(tMax=t$3));let width=(-(bX-aX)*cY+bX*aY-bY*aX)/(bX-aX);Math.abs(width)>Math.abs(maxWidth)&&(maxWidth=width)}let minPoint={column:aX+tMin*(bX-aX),row:aY},maxPoint={column:aX+tMax*(bX-aX),row:aY},currentSurface=Math.abs(maxWidth*(tMin-tMax)*(bX-aX));currentSurface<minSurface&&(minSurfaceAngle=angle,minSurface=currentSurface,mbr=[maxPoint,minPoint,{column:minPoint.column,row:minPoint.row-maxWidth},{column:maxPoint.column,row:maxPoint.row-maxWidth}])}let mbrRotated=rotate$1(minSurfaceAngle,mbr),sides=[Math.hypot(mbr[0].column-mbr[1].column,mbr[0].row-mbr[1].row),Math.hypot(mbr[0].column-mbr[3].column,mbr[0].row-mbr[3].row)],maxSide=Math.max(...sides),minSide=Math.min(...sides),mbrAngle=getMbrAngle(mbrRotated),ratio=minSide/maxSide;return{points:mbrRotated,surface:minSurface,angle:mbrAngle,width:maxSide,height:minSide,perimeter:2*maxSide+2*minSide,aspectRatio:ratio}}function getMbr(mask){let vertices=monotoneChainConvexHull(getExtendedBorderPoints(mask));return getMbrFromPoints(vertices)}function checkKernel(kernel){if(kernel.length%2==0||kernel[0].length%2==0)throw TypeError(`the number of rows and columns of the kernel must be odd`)}function erode(image,options={}){let defaultKernel=!1;options.kernel===void 0&&(defaultKernel=!0);let{kernel=[[1,1,1],[1,1,1],[1,1,1]],iterations=1}=options;image instanceof Image&&checkProcessable(image,{bitDepth:[1,8,16],components:1,alpha:!1}),checkKernel(kernel);let onlyOnes=!0;if(!defaultKernel){outer:for(let row of kernel)for(let bit of row)if(bit!==1){onlyOnes=!1;break outer}}let result=image;for(let i$3=0;i$3<iterations;i$3++)if(result instanceof Mask)if(onlyOnes){let newImage=result.clone();result=erodeMaskOnlyOnes(result,newImage,kernel[0].length,kernel.length)}else{let newImage=Mask.createFrom(image);result=erodeMask(result,newImage,kernel)}else if(onlyOnes){let newImage=Image.createFrom(image);result=erodeGreyOnlyOnes(result,newImage,kernel[0].length,kernel.length)}else{let newImage=Image.createFrom(image);result=erodeGrey(result,newImage,kernel)}return result}function erodeGrey(img,newImage,kernel){let kernelWidth=kernel[0].length,kernelHeight=kernel.length,radiusX=(kernelWidth-1)/2,radiusY=(kernelHeight-1)/2;for(let row=0;row<img.height;row++)for(let column=0;column<img.width;column++){let min$2=img.maxValue;for(let kernelRow=0;kernelRow<kernelHeight;kernelRow++)for(let kernelColumn=0;kernelColumn<kernelWidth;kernelColumn++){if(kernel[kernelRow][kernelColumn]!==1)continue;let currentColumn=kernelColumn-radiusX+column,currentRow=kernelRow-radiusY+row;if(currentColumn<0||currentRow<0||currentColumn>=img.width||currentRow>=img.height)continue;let value=img.getValue(currentColumn,currentRow,0);value<min$2&&(min$2=value)}newImage.setValue(column,row,0,min$2)}return newImage}function erodeGreyOnlyOnes(image,newImage,kernelWidth,kernelHeight){let radiusX=(kernelWidth-1)/2,radiusY=(kernelHeight-1)/2,minList=[];for(let column=0;column<image.width;column++)minList.push(0);for(let row=0;row<image.height;row++){for(let column=0;column<image.width;column++){let min$2=image.maxValue;for(let h$3=Math.max(0,row-radiusY);h$3<Math.min(image.height,row+radiusY+1);h$3++){let value=image.getValue(column,h$3,0);value<min$2&&(min$2=value)}minList[column]=min$2}for(let column=0;column<image.width;column++){let min$2=image.maxValue;for(let i$3=Math.max(0,column-radiusX);i$3<Math.min(image.width,column+radiusX+1);i$3++)minList[i$3]<min$2&&(min$2=minList[i$3]);newImage.setValue(column,row,0,min$2)}}return newImage}function erodeMask(mask,newMask,kernel){let kernelWidth=kernel[0].length,kernelHeight=kernel.length,radiusX=(kernelWidth-1)/2,radiusY=(kernelHeight-1)/2;for(let row=0;row<mask.height;row++)for(let column=0;column<mask.width;column++){let min$2=1;for(let kernelRow=0;kernelRow<kernelHeight;kernelRow++)for(let kernelColumn=0;kernelColumn<kernelWidth;kernelColumn++){if(kernel[kernelRow][kernelColumn]!==1)continue;let currentColumn=kernelColumn-radiusX+column,currentRow=kernelRow-radiusY+row;if(!(currentRow<0||currentColumn<0||currentColumn>=mask.width||currentRow>=mask.height)&&mask.getBit(currentColumn,currentRow)===0){min$2=0;break}}min$2===1&&newMask.setBit(column,row,1)}return newMask}function erodeMaskOnlyOnes(mask,newMask,kernelWidth,kernelHeight){let radiusX=(kernelWidth-1)/2,radiusY=(kernelHeight-1)/2,minList=[];for(let column=0;column<mask.width;column++)minList.push(0);for(let row=0;row<mask.height;row++){for(let column=0;column<mask.width;column++){minList[column]=1;for(let h$3=Math.max(0,row-radiusY);h$3<Math.min(mask.height,row+radiusY+1);h$3++)if(mask.getBit(column,h$3)===0){minList[column]=0;break}}for(let column=0;column<mask.width;column++)if(newMask.getBit(column,row)!==0){for(let i$3=Math.max(0,column-radiusX);i$3<Math.min(mask.width,column+radiusX+1);i$3++)if(minList[i$3]===0){newMask.setBit(column,row,0);break}}}return newMask}function dilate(image,options={}){let defaultKernel=!1;options.kernel===void 0&&(defaultKernel=!0);let{kernel=[[1,1,1],[1,1,1],[1,1,1]],iterations=1}=options;image instanceof Image&&checkProcessable(image,{bitDepth:[1,8,16],components:1,alpha:!1}),checkKernel(kernel);let onlyOnes=!0;if(!defaultKernel){outer:for(let row of kernel)for(let value of row)if(value!==1){onlyOnes=!1;break outer}}let result=image;for(let i$3=0;i$3<iterations;i$3++)if(result instanceof Mask)if(onlyOnes){let newMask=result.clone();result=dilatMaskOnlyOnes(result,newMask,kernel[0].length,kernel.length)}else{let newMask=Mask.createFrom(result);result=dilateMask(result,newMask,kernel)}else if(onlyOnes){let newImage=Image.createFrom(result);result=dilateGreyOnlyOnes(result,newImage,kernel[0].length,kernel.length)}else{let newImage=Image.createFrom(result);result=dilateGrey(result,newImage,kernel)}return result}function dilateGrey(image,newImage,kernel){let kernelWidth=kernel[0].length,kernelHeight=kernel.length,radiusX=(kernelWidth-1)/2,radiusY=(kernelHeight-1)/2;for(let row=0;row<image.height;row++)for(let column=0;column<image.width;column++){let max$2=0;for(let kernelRow=0;kernelRow<kernelHeight;kernelRow++)for(let kernelColumn=0;kernelColumn<kernelWidth;kernelColumn++){if(kernel[kernelRow][kernelColumn]!==1)continue;let currentColumn=kernelColumn-radiusX+column,currentRow=kernelRow-radiusY+row;if(currentColumn<0||currentRow<0||currentColumn>=image.width||currentRow>=image.height)continue;let value=image.getValue(currentColumn,currentRow,0);value>max$2&&(max$2=value)}newImage.setValue(column,row,0,max$2)}return newImage}function dilateGreyOnlyOnes(image,newImage,kernelWidth,kernelHeight){let radiusX=(kernelWidth-1)/2,radiusY=(kernelHeight-1)/2,maxList=[];for(let column=0;column<image.width;column++)maxList.push(0);for(let row=0;row<image.height;row++){for(let column=0;column<image.width;column++){let max$2=0;for(let h$3=Math.max(0,row-radiusY);h$3<Math.min(image.height,row+radiusY+1);h$3++){let value=image.getValue(column,h$3,0);value>max$2&&(max$2=value)}maxList[column]=max$2}for(let column=0;column<image.width;column++){let max$2=0;for(let i$3=Math.max(0,column-radiusX);i$3<Math.min(image.width,column+radiusX+1);i$3++)maxList[i$3]>max$2&&(max$2=maxList[i$3]);newImage.setValue(column,row,0,max$2)}}return newImage}function dilateMask(mask,newMask,kernel){let kernelWidth=kernel[0].length,kernelHeight=kernel.length,radiusX=(kernelWidth-1)/2,radiusY=(kernelHeight-1)/2;for(let row=0;row<mask.height;row++)for(let column=0;column<mask.width;column++){let max$2=0;for(let kernelRow=0;kernelRow<kernelHeight;kernelRow++)for(let kernelColumn=0;kernelColumn<kernelWidth;kernelColumn++){if(kernel[kernelRow][kernelColumn]!==1)continue;let currentColumn=kernelColumn-radiusX+column,currentRow=kernelRow-radiusY+row;if(!(currentRow<0||currentColumn<0||currentColumn>=mask.width||currentRow>=mask.height)&&mask.getBit(currentColumn,currentRow)===1){max$2=1;break}}max$2===1&&newMask.setBit(column,row,1)}return newMask}function dilatMaskOnlyOnes(mask,newMask,kernelWidth,kernelHeight){let radiusX=(kernelWidth-1)/2,radiusY=(kernelHeight-1)/2,maxList=[];for(let column=0;column<mask.width;column++)maxList.push(1);for(let row=0;row<mask.height;row++){for(let column=0;column<mask.width;column++){maxList[column]=0;for(let h$3=Math.max(0,row-radiusY);h$3<Math.min(mask.height,row+radiusY+1);h$3++)if(mask.getBit(column,h$3)===1){maxList[column]=1;break}}for(let column=0;column<mask.width;column++)if(newMask.getBit(column,row)!==1){for(let i$3=Math.max(0,column-radiusX);i$3<Math.min(mask.width,column+radiusX+1);i$3++)if(maxList[i$3]===1){newMask.setBit(column,row,1);break}}}return newMask}function open(image,options={}){let{kernel=[[1,1,1],[1,1,1],[1,1,1]],iterations=1}=options;image instanceof Image&&checkProcessable(image,{bitDepth:[1,8,16],components:1,alpha:!1}),checkKernel(kernel);let newImage=image;for(let i$3=0;i$3<iterations;i$3++)newImage=newImage.erode({kernel}),newImage=newImage.dilate({kernel});return newImage}function close(image,options={}){let{kernel=[[1,1,1],[1,1,1],[1,1,1]],iterations=1}=options;image instanceof Image&&checkProcessable(image,{bitDepth:[1,8,16],components:1,alpha:!1}),checkKernel(kernel);let newImage=image;for(let i$3=0;i$3<iterations;i$3++)newImage=newImage.dilate({kernel}).erode({kernel});return newImage}function topHat(image,options={}){let{kernel=[[1,1,1],[1,1,1],[1,1,1]],iterations=1}=options;image instanceof Image&&checkProcessable(image,{bitDepth:[1,8,16],components:1,alpha:!1}),checkKernel(kernel);let newImage=image;for(let i$3=0;i$3<iterations;i$3++){let openImage=newImage.open({kernel});newImage=subtract(openImage,newImage,{absolute:!0})}return newImage}function bottomHat(image,options={}){let{kernel=[[1,1,1],[1,1,1],[1,1,1]],iterations=1}=options;image instanceof Image&&checkProcessable(image,{bitDepth:[1,8,16],components:1,alpha:!1}),checkKernel(kernel);let newImage=image;for(let i$3=0;i$3<iterations;i$3++){let openImage=newImage.close({kernel});newImage=subtract(openImage,newImage,{absolute:!0})}return newImage}function morphologicalGradient(image,options={}){let{kernel=[[1,1,1],[1,1,1],[1,1,1]],iterations=1}=options;image instanceof Image&&checkProcessable(image,{bitDepth:[1,8,16],components:1,alpha:!1}),checkKernel(kernel);let newImage=image;for(let i$3=0;i$3<iterations;i$3++){let dilatedImage=newImage.dilate({kernel}),erodedImage=newImage.erode({kernel});newImage=subtract(dilatedImage,erodedImage,{absolute:!0})}return newImage}function*borderIterator(image){for(let col=0;col<image.width;col++)yield col;for(let row=2;row<image.height;row++)yield row*image.width-1;for(let col=0;col<image.width;col++)yield image.width*image.height-col-1;for(let row=image.height-2;row>=1;row--)yield row*image.width}var MAX_ARRAY=65536,toProcess=new Uint32Array(MAX_ARRAY);function multipleFloodFill(mask,options={}){let{startPixels=[0],startPixelValue=0,newPixelValue=1,allowCorners=!1}=options,newMask=maskToOutputMask(mask,options,{clone:!0}),alreadyConsidered=Mask.createFrom(mask),from=0,to=0;for(let pixelIndex of startPixels)newMask.getBitByIndex(pixelIndex)===startPixelValue&&(toProcess[to++%MAX_ARRAY]=pixelIndex,alreadyConsidered.setBitByIndex(pixelIndex,1),newMask.setBitByIndex(pixelIndex,newPixelValue));for(;from<to;){assert(to-from<=MAX_ARRAY);let currentPixel=toProcess[from++%MAX_ARRAY];newMask.setBitByIndex(currentPixel,newPixelValue);let topBorder=currentPixel<mask.width,leftBorder=currentPixel%mask.width===0,rightBorder=currentPixel%mask.width===mask.width-1,bottomBorder=currentPixel>mask.size-mask.width;if(!bottomBorder){let bottom=currentPixel+mask.width;addToProcess(bottom)}if(!leftBorder){let left=currentPixel-1;addToProcess(left)}if(!topBorder){let top=currentPixel-mask.width;addToProcess(top)}if(!rightBorder){let right=currentPixel+1;addToProcess(right)}if(allowCorners){if(!topBorder){if(!leftBorder){let topLeft=currentPixel-mask.width-1;addToProcess(topLeft)}if(!rightBorder){let topRight=currentPixel-mask.width+1;addToProcess(topRight)}}if(!bottomBorder){if(!leftBorder){let bottomLeft=currentPixel+mask.width-1;addToProcess(bottomLeft)}if(!rightBorder){let bottomRight=currentPixel+mask.width+1;addToProcess(bottomRight)}}}}function addToProcess(pixel){alreadyConsidered.getBitByIndex(pixel)||newMask.getBitByIndex(pixel)===startPixelValue&&(toProcess[to++%MAX_ARRAY]=pixel,alreadyConsidered.setBitByIndex(pixel,1))}return newMask}function clearBorder(mask,options={}){let{allowCorners=!1,out,color=`white`}=options;return multipleFloodFill(mask,{startPixels:borderIterator(mask),startPixelValue:color===`white`?1:0,newPixelValue:color===`white`?0:1,allowCorners,out})}var kernelX=[[-1,0,1],[-2,0,2],[-1,0,1]],kernelY=[[-1,-2,-1],[0,0,0],[1,2,1]];function cannyEdgeDetector(image,options={}){let{hysteresis=!0,lowThreshold=.04,highThreshold=.1,gaussianBlurOptions={sigma:1}}=options,minValue=lowThreshold*image.maxValue,maxValue=highThreshold*image.maxValue;checkProcessable(image,{colorModel:`GREY`});let width=image.width,height=image.height,blurred=image.gaussianBlur(gaussianBlurOptions),gradientX=blurred.rawDirectConvolution(kernelY),gradientY=blurred.rawDirectConvolution(kernelX),gradient=new Float64Array(image.size);for(let i$3=0;i$3<image.size;i$3++)gradient[i$3]=Math.hypot(gradientX[i$3],gradientY[i$3]);let nonMaxSuppression=new Float64Array(image.size),edges=new Float64Array(image.size),finalImage=imageToOutputMask(image,options);for(let column=1;column<width-1;column++)for(let row=1;row<height-1;row++){let currentGradientX=gradientX[getIndex(column,row,image,0)],currentGradientY=gradientY[getIndex(column,row,image,0)],direction=getDirection(currentGradientX,currentGradientY),currentGradient=gradient[getIndex(column,row,image,0)];(direction===0&&currentGradient>=gradient[getIndex(column,row-1,image,0)]&&currentGradient>=gradient[getIndex(column,row+1,image,0)]||direction===1&&currentGradient>=gradient[getIndex(column-1,row-1,image,0)]&&currentGradient>=gradient[getIndex(column+1,row+1,image,0)]||direction===2&&currentGradient>=gradient[getIndex(column-1,row,image,0)]&&currentGradient>=gradient[getIndex(column+1,row,image,0)]||direction===3&&currentGradient>=gradient[getIndex(column-1,row+1,image,0)]&&currentGradient>=gradient[getIndex(column+1,row-1,image,0)])&&(nonMaxSuppression[getIndex(column,row,image,0)]=currentGradient)}for(let i$3=0;i$3<width*height;++i$3){let currentNms=nonMaxSuppression[i$3],currentEdge=0;currentNms>maxValue&&(currentEdge++,finalImage.setBitByIndex(i$3,1)),currentNms>minValue&&currentEdge++,edges[i$3]=currentEdge}if(hysteresis){let currentPixels=[];for(let column=1;column<width-1;++column)for(let row=1;row<height-1;++row)if(edges[getIndex(column,row,image,0)]===1){outer:for(let hystColumn=column-1;hystColumn<column+2;++hystColumn)for(let hystRow=row-1;hystRow<row+2;++hystRow)if(edges[getIndex(hystColumn,hystRow,image,0)]===2){currentPixels.push([column,row]),finalImage.setValue(column,row,0,1);break outer}}for(;currentPixels.length>0;){let newPixels=[];for(let currentPixel of currentPixels)for(let j$2=-1;j$2<2;++j$2)for(let k$2=-1;k$2<2;++k$2){if(j$2===0&&k$2===0)continue;let row=currentPixel[0]+j$2,column=currentPixel[1]+k$2;edges[getIndex(column,row,image,0)]===1&&finalImage.getValue(column,row,0)===0&&(newPixels.push([row,column]),finalImage.setValue(column,row,0,1))}currentPixels=newPixels}}return finalImage}function getDirection(x$2,y$2){return(Math.round(Math.atan2(y$2,x$2)*(4/Math.PI))+4)%4}function floodFill(mask,options={}){let{origin={row:0,column:0},allowCorners=!1,out}=options,startPixel=getIndex(origin.column,origin.row,mask);return multipleFloodFill(mask,{startPixels:[startPixel],allowCorners,out})}function solidFill(mask,options={}){let{allowCorners=!1}=options,newImage=maskToOutputMask(mask,options,{clone:!0}),cleared=mask.invert().clearBorder({allowCorners});return newImage.or(cleared,{out:newImage})}function boolToNumber(value){let result;return result=typeof value==`boolean`?value?1:0:value,result}var Mask=class Mask{width;height;size;bitDepth;colorModel;components;channels;alpha;maxValue;origin;data;constructor(width,height,options={}){let{data,origin={row:0,column:0}}=options;if(width<1||!Number.isInteger(width))throw RangeError(`width must be an integer and at least 1. Received ${width}`);if(height<1||!Number.isInteger(height))throw RangeError(`height must be an integer and at least 1. Received ${height}`);this.width=width,this.height=height,this.size=width*height,this.bitDepth=1,this.colorModel=`BINARY`,this.origin=origin;let colorModelDef=colorModels[this.colorModel];if(this.components=colorModelDef.components,this.alpha=colorModelDef.alpha,this.channels=colorModelDef.channels,this.maxValue=1,data===void 0)this.data=new Uint8Array(this.size);else{let expectedLength=this.size*this.channels;if(data.length!==expectedLength)throw RangeError(`incorrect data size: ${data.length}. Expected ${expectedLength}`);this.data=data}}static createFrom(other,options={}){let{width=other.width,height=other.height,origin=other.origin}=options;return new Mask(width,height,{origin,...options})}getPixel(column,row){let result=[],index=row*this.width+column;return result.push(this.data[index]),result}setPixel(column,row,value){let index=row*this.width+column;this.data[index]=value[0]}setVisiblePixel(column,row,value){column>=0&&column<this.width&&row>=0&&row<this.height&&this.setPixel(column,row,value)}getPixelByIndex(index){return[this.data[index]]}setPixelByIndex(index,value){this.data[index]=value[0]}static fromPoints(width,height,points){let mask=new Mask(width,height);for(let point of points)mask.setBit(point.column,point.row,1);return mask}clone(){return Mask.createFrom(this,{data:this.data.slice()})}getBit(column,row){let index=row*this.width+column;return this.data[index]}setBit(column,row,value){let index=row*this.width+column;this.data[index]=value}getBitByIndex(index){return this.data[index*this.channels]}setBitByIndex(index,value){this.data[index*this.channels]=boolToNumber(value)}getNbNonZeroPixels(){let count=0;for(let datum of this.data)datum&&count++;return count}getValue(column,row,channel){return checkChannel(channel),this.getBit(column,row)}setValue(column,row,channel,value){checkChannel(channel),this.setBit(column,row,value)}getValueByIndex(index,channel){return checkChannel(channel),this.getBitByIndex(index)}setValueByIndex(index,channel,value){checkChannel(channel),this.setBitByIndex(index,value)}getValueByPoint(point){return this.getValue(point.column,point.row,0)}setValueByPoint(point,value){this.setValue(point.column,point.row,0,value)}getRawImage(){return{width:this.width,height:this.height,data:this.data}}[Symbol.for(`nodejs.util.inspect.custom`)](){let dataString;return dataString=this.height>20||this.width>20?`[...]`:printData$1(this),`Mask {
  width: ${this.width}
  height: ${this.height}
  data: ${dataString}
}`}fill(value){let result=boolToNumber(value);return this.data.fill(result),this}convertColor(colorModel){return convertColor(this,colorModel)}invert(options){return invert(this,options)}subtract(other,options){return subtract(this,other,options)}and(other,options){return and(this,other,options)}or(other,options){return or(this,other,options)}getBorderPoints(options){return getBorderPoints(this,options)}getConvexHull(){return getConvexHull(this)}getMbr(){return getMbr(this)}getFeret(){return getFeret(this)}erode(options){return erode(this,options)}dilate(options){return dilate(this,options)}open(options){return open(this,options)}close(options){return close(this,options)}topHat(options){return topHat(this,options)}bottomHat(options){return bottomHat(this,options)}morphologicalGradient(options){return morphologicalGradient(this,options)}clearBorder(options){return clearBorder(this,options)}floodFill(options){return floodFill(this,options)}solidFill(options){return solidFill(this,options)}drawPoints(points,options={}){return drawPoints(this,points,options)}drawLine(from,to,options={}){return drawLineOnMask(this,from,to,options)}drawPolyline(points,options={}){return drawPolylineOnMask(this,points,options)}drawPolygon(points,options={}){return drawPolygonOnMask(this,points,options)}drawRectangle(options={}){return drawRectangle(this,options)}copyTo(target,options={}){return copyTo(this,target,options)}paintMask(mask,options){return paintMaskOnMask(this,mask,options)}};function printData$1(mask){let result=[];for(let row=0;row<mask.height;row++){let line$3=[];for(let column=0;column<mask.width;column++)line$3.push(String(mask.getBit(column,row)));result.push(`[${line$3.join(` `)}]`)}return result.join(`
        `)}function checkChannel(channel){if(channel!==0)throw RangeError(`channel value must be 0 on type Mask. Received ${channel}`)}function subtract(image,otherImage,options={}){let{absolute=!1}=options;image instanceof Image&&checkProcessable(image,{bitDepth:[1,8,16],components:[1,3],alpha:!1}),validateForComparison(image,otherImage);let newImage=image.clone();if(newImage instanceof Image)for(let index=0;index<image.size;index++)for(let channel=0;channel<image.channels;channel++){let value=image.getValueByIndex(index,channel)-otherImage.getValueByIndex(index,channel);absolute?value<0?newImage.setValueByIndex(index,channel,-value):newImage.setValueByIndex(index,channel,value):value<0?newImage.setValueByIndex(index,channel,0):newImage.setValueByIndex(index,channel,value)}else if(image instanceof Mask&&otherImage instanceof Mask)for(let index=0;index<image.size;index++){let value=image.getBitByIndex(index)-otherImage.getBitByIndex(index);absolute?newImage.setBitByIndex(index,value?1:0):newImage.setBitByIndex(index,value>0?1:0)}return newImage}function add(image,otherImage){image instanceof Image&&checkProcessable(image,{bitDepth:[8,16],components:[1,3],alpha:!1}),validateForComparison(image,otherImage);let newImage=image.clone(),clamp=getClamp(image);for(let index=0;index<image.size;index++)for(let channel=0;channel<image.channels;channel++){let value=image.getValueByIndex(index,channel)+otherImage.getValueByIndex(index,channel);newImage.setValueByIndex(index,channel,clamp(value))}return newImage}function multiply(image,value,options={}){let{channels=Array(image.channels).fill(0).map((value$1,index)=>index)}=options;validateChannels(channels,image);let newImage=getOutputImage(image,options,{clone:!0});if(channels.length===0)return newImage;for(let channel of channels)for(let row=0;row<newImage.height;row++)for(let column=0;column<newImage.width;column++){let newIntensity=newImage.getValue(column,row,channel)*value;newImage.setClampedValue(column,row,channel,newIntensity)}return newImage}function mean(image,options){let pixelSum=Array(image.channels).fill(0),nbValues=options?options.points.length:image.size;if(nbValues===0)throw RangeError(`Array of coordinates is empty.`);if(options)for(let point of options.points)for(let channel=0;channel<image.channels;channel++){if(point.column<0||point.column>=image.width||point.row<0||point.row>=image.height)throw RangeError(`Invalid coordinate: {column: ${point.column}, row: ${point.row}}.`);pixelSum[channel]+=image.getValueByPoint(point,channel)}else for(let row=0;row<image.height;row++)for(let column=0;column<image.width;column++)for(let channel=0;channel<image.channels;channel++)pixelSum[channel]+=image.getValue(column,row,channel);return pixelSum.map(channelSum=>channelSum/nbValues)}function histogram(image,options={}){let{channel}=options,{slots=2**image.bitDepth}=options;if(!(slots!==0&&!(slots&slots-1)))throw RangeError(`slots must be a power of 2, for example: 64, 256, 1024`);if(typeof channel!=`number`){if(image.channels!==1)throw TypeError(`channel option is mandatory for multi-channel images`);channel=0}validateChannel(channel,image);let hist=new Uint32Array(slots),bitShift=0,bitSlots=Math.log2(slots);bitShift=image.bitDepth-bitSlots;for(let i$3=0;i$3<image.size;i$3++)hist[image.getValueByIndex(i$3,channel)>>bitShift]++;return hist}var import_median_quickselect_min$1=__toESM(require_median_quickselect_min());function median(image,options){let pixel=Array(image.channels).fill(0);if(options){if(options.points.length===0)throw RangeError(`Array of coordinates is empty.`);for(let i$3=0;i$3<image.channels;i$3++){let channel=[];for(let point of options.points){if(point.column<0||point.column>=image.width||point.row<0||point.row>=image.height)throw RangeError(`Invalid coordinate: {column: ${point.column}, row: ${point.row}}.`);channel.push(image.getValueByPoint(point,i$3))}pixel[i$3]=(0,import_median_quickselect_min$1.default)(channel)}}else for(let i$3=0;i$3<image.channels;i$3++){let channel=image.getChannel(i$3);pixel[i$3]=(0,import_median_quickselect_min$1.default)(channel)}return pixel}function variance(image,options){let mean$2=image.mean(options),sum=Array(image.channels).fill(0);if(options)for(let point of options.points)for(let channel=0;channel<image.channels;channel++)sum[channel]+=(image.getValue(point.column,point.row,channel)-mean$2[channel])**2;else for(let i$3=0;i$3<image.size;i$3++)for(let channel=0;channel<image.channels;channel++)sum[channel]+=(image.getValueByIndex(i$3,channel)-mean$2[channel])**2;let nbValues=options?options.points.length*image.channels:image.size*image.channels;return sum.map(channel=>channel/nbValues)}var MultivariateLinearRegression=class MultivariateLinearRegression{constructor(x$2,y$2,options={}){let{intercept=!0,statistics=!0}=options;if(this.statistics=statistics,x$2===!0)this.weights=y$2.weights,this.inputs=y$2.inputs,this.outputs=y$2.outputs,this.intercept=y$2.intercept;else{x$2=new Matrix(x$2),y$2=new Matrix(y$2),intercept&&x$2.addColumn(Array(x$2.rows).fill(1));let xt=x$2.transpose(),xx=xt.mmul(x$2),xy=xt.mmul(y$2),invxx=new SVD(xx).inverse(),beta=xy.transpose().mmul(invxx).transpose();if(this.weights=beta.to2DArray(),this.inputs=x$2.columns,this.outputs=y$2.columns,intercept&&this.inputs--,this.intercept=intercept,statistics){let fittedValues=x$2.mmul(beta),variance$1=y$2.clone().addM(fittedValues.neg()).to2DArray().map(ri=>ri[0]**2).reduce((a$3,b$3)=>a$3+b$3)/(y$2.rows-x$2.columns);this.stdError=Math.sqrt(variance$1),this.stdErrorMatrix=pseudoInverse(xx).mul(variance$1),this.stdErrors=this.stdErrorMatrix.diagonal().map(d$2=>Math.sqrt(d$2)),this.tStats=this.weights.map((d$2,i$3)=>this.stdErrors[i$3]===0?0:d$2[0]/this.stdErrors[i$3])}}}predict(x$2){if(Array.isArray(x$2)){if(typeof x$2[0]==`number`)return this._predict(x$2);if(Array.isArray(x$2[0])){let y$2=Array(x$2.length);for(let i$3=0;i$3<x$2.length;i$3++)y$2[i$3]=this._predict(x$2[i$3]);return y$2}}else if(Matrix.isMatrix(x$2)){let y$2=new Matrix(x$2.rows,this.outputs);for(let i$3=0;i$3<x$2.rows;i$3++)y$2.setRow(i$3,this._predict(x$2.getRow(i$3)));return y$2}throw TypeError(`x must be a matrix or array of numbers`)}_predict(x$2){let result=Array(this.outputs);if(this.intercept)for(let i$3=0;i$3<this.outputs;i$3++)result[i$3]=this.weights[this.inputs][i$3];else result.fill(0);for(let i$3=0;i$3<this.inputs;i$3++)for(let j$2=0;j$2<this.outputs;j$2++)result[j$2]+=this.weights[i$3][j$2]*x$2[i$3];return result}score(){throw Error(`score method is not implemented yet`)}toJSON(){return{name:`multivariateLinearRegression`,weights:this.weights,inputs:this.inputs,outputs:this.outputs,intercept:this.intercept,summary:this.statistics?{regressionStatistics:{standardError:this.stdError,observations:this.outputs},variables:this.weights.map((d$2,i$3)=>({label:i$3===this.weights.length-1?`Intercept`:`X Variable ${i$3+1}`,coefficients:d$2,standardError:this.stdErrors[i$3],tStat:this.tStats[i$3]}))}:void 0}}static load(model){if(model.name!==`multivariateLinearRegression`)throw Error(`not a MLR model`);return new MultivariateLinearRegression(!0,model)}},r$1={grad:.9,turn:360,rad:360/(2*Math.PI)},t$1=function(r$3){return typeof r$3==`string`?r$3.length>0:typeof r$3==`number`},n$1=function(r$3,t$3,n$3){return t$3===void 0&&(t$3=0),n$3===void 0&&(n$3=10**t$3),Math.round(n$3*r$3)/n$3+0},e$1=function(r$3,t$3,n$3){return t$3===void 0&&(t$3=0),n$3===void 0&&(n$3=1),r$3>n$3?n$3:r$3>t$3?r$3:t$3},u$1=function(r$3){return(r$3=isFinite(r$3)?r$3%360:0)>0?r$3:r$3+360},a$1=function(r$3){return{r:e$1(r$3.r,0,255),g:e$1(r$3.g,0,255),b:e$1(r$3.b,0,255),a:e$1(r$3.a)}},o$1=function(r$3){return{r:n$1(r$3.r),g:n$1(r$3.g),b:n$1(r$3.b),a:n$1(r$3.a,3)}},i$1=/^#([0-9a-f]{3,8})$/i,s=function(r$3){var t$3=r$3.toString(16);return t$3.length<2?`0`+t$3:t$3},h$1=function(r$3){var t$3=r$3.r,n$3=r$3.g,e$3=r$3.b,u$2=r$3.a,a$3=Math.max(t$3,n$3,e$3),o$3=a$3-Math.min(t$3,n$3,e$3),i$3=o$3?a$3===t$3?(n$3-e$3)/o$3:a$3===n$3?2+(e$3-t$3)/o$3:4+(t$3-n$3)/o$3:0;return{h:60*(i$3<0?i$3+6:i$3),s:a$3?o$3/a$3*100:0,v:a$3/255*100,a:u$2}},b$1=function(r$3){var t$3=r$3.h,n$3=r$3.s,e$3=r$3.v,u$2=r$3.a;t$3=t$3/360*6,n$3/=100,e$3/=100;var a$3=Math.floor(t$3),o$3=e$3*(1-n$3),i$3=e$3*(1-(t$3-a$3)*n$3),s$2=e$3*(1-(1-t$3+a$3)*n$3),h$3=a$3%6;return{r:255*[e$3,i$3,o$3,o$3,s$2,e$3][h$3],g:255*[s$2,e$3,e$3,i$3,o$3,o$3][h$3],b:255*[o$3,o$3,s$2,e$3,e$3,i$3][h$3],a:u$2}},g=function(r$3){return{h:u$1(r$3.h),s:e$1(r$3.s,0,100),l:e$1(r$3.l,0,100),a:e$1(r$3.a)}},d=function(r$3){return{h:n$1(r$3.h),s:n$1(r$3.s),l:n$1(r$3.l),a:n$1(r$3.a,3)}},f=function(r$3){return b$1((n$3=(t$3=r$3).s,{h:t$3.h,s:(n$3*=((e$3=t$3.l)<50?e$3:100-e$3)/100)>0?2*n$3/(e$3+n$3)*100:0,v:e$3+n$3,a:t$3.a}));var t$3,n$3,e$3},c=function(r$3){return{h:(t$3=h$1(r$3)).h,s:(u$2=(200-(n$3=t$3.s))*(e$3=t$3.v)/100)>0&&u$2<200?n$3*e$3/100/(u$2<=100?u$2:200-u$2)*100:0,l:u$2/2,a:t$3.a};var t$3,n$3,e$3,u$2},l$1=/^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,p$1=/^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,v=/^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,m=/^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,y={string:[[function(r$3){var t$3=i$1.exec(r$3);return t$3?(r$3=t$3[1]).length<=4?{r:parseInt(r$3[0]+r$3[0],16),g:parseInt(r$3[1]+r$3[1],16),b:parseInt(r$3[2]+r$3[2],16),a:r$3.length===4?n$1(parseInt(r$3[3]+r$3[3],16)/255,2):1}:r$3.length===6||r$3.length===8?{r:parseInt(r$3.substr(0,2),16),g:parseInt(r$3.substr(2,2),16),b:parseInt(r$3.substr(4,2),16),a:r$3.length===8?n$1(parseInt(r$3.substr(6,2),16)/255,2):1}:null:null},`hex`],[function(r$3){var t$3=v.exec(r$3)||m.exec(r$3);return t$3?t$3[2]!==t$3[4]||t$3[4]!==t$3[6]?null:a$1({r:Number(t$3[1])/(t$3[2]?100/255:1),g:Number(t$3[3])/(t$3[4]?100/255:1),b:Number(t$3[5])/(t$3[6]?100/255:1),a:t$3[7]===void 0?1:Number(t$3[7])/(t$3[8]?100:1)}):null},`rgb`],[function(t$3){var n$3=l$1.exec(t$3)||p$1.exec(t$3);if(!n$3)return null;var e$3,u$2,a$3=g({h:(e$3=n$3[1],u$2=n$3[2],u$2===void 0&&(u$2=`deg`),Number(e$3)*(r$1[u$2]||1)),s:Number(n$3[3]),l:Number(n$3[4]),a:n$3[5]===void 0?1:Number(n$3[5])/(n$3[6]?100:1)});return f(a$3)},`hsl`]],object:[[function(r$3){var n$3=r$3.r,e$3=r$3.g,u$2=r$3.b,o$3=r$3.a,i$3=o$3===void 0?1:o$3;return t$1(n$3)&&t$1(e$3)&&t$1(u$2)?a$1({r:Number(n$3),g:Number(e$3),b:Number(u$2),a:Number(i$3)}):null},`rgb`],[function(r$3){var n$3=r$3.h,e$3=r$3.s,u$2=r$3.l,a$3=r$3.a,o$3=a$3===void 0?1:a$3;if(!t$1(n$3)||!t$1(e$3)||!t$1(u$2))return null;var i$3=g({h:Number(n$3),s:Number(e$3),l:Number(u$2),a:Number(o$3)});return f(i$3)},`hsl`],[function(r$3){var n$3=r$3.h,a$3=r$3.s,o$3=r$3.v,i$3=r$3.a,s$2=i$3===void 0?1:i$3;if(!t$1(n$3)||!t$1(a$3)||!t$1(o$3))return null;var h$3=function(r$4){return{h:u$1(r$4.h),s:e$1(r$4.s,0,100),v:e$1(r$4.v,0,100),a:e$1(r$4.a)}}({h:Number(n$3),s:Number(a$3),v:Number(o$3),a:Number(s$2)});return b$1(h$3)},`hsv`]]},N=function(r$3,t$3){for(var n$3=0;n$3<t$3.length;n$3++){var e$3=t$3[n$3][0](r$3);if(e$3)return[e$3,t$3[n$3][1]]}return[null,void 0]},x=function(r$3){return typeof r$3==`string`?N(r$3.trim(),y.string):typeof r$3==`object`&&r$3?N(r$3,y.object):[null,void 0]},I=function(r$3){return x(r$3)[1]},M$2=function(r$3,t$3){var n$3=c(r$3);return{h:n$3.h,s:e$1(n$3.s+100*t$3,0,100),l:n$3.l,a:n$3.a}},H=function(r$3){return(299*r$3.r+587*r$3.g+114*r$3.b)/1e3/255},$=function(r$3,t$3){var n$3=c(r$3);return{h:n$3.h,s:n$3.s,l:e$1(n$3.l+100*t$3,0,100),a:n$3.a}},j=function(){function r$3(r$4){this.parsed=x(r$4)[0],this.rgba=this.parsed||{r:0,g:0,b:0,a:1}}return r$3.prototype.isValid=function(){return this.parsed!==null},r$3.prototype.brightness=function(){return n$1(H(this.rgba),2)},r$3.prototype.isDark=function(){return H(this.rgba)<.5},r$3.prototype.isLight=function(){return H(this.rgba)>=.5},r$3.prototype.toHex=function(){return r$4=o$1(this.rgba),t$3=r$4.r,e$3=r$4.g,u$2=r$4.b,i$3=(a$3=r$4.a)<1?s(n$1(255*a$3)):``,`#`+s(t$3)+s(e$3)+s(u$2)+i$3;var r$4,t$3,e$3,u$2,a$3,i$3},r$3.prototype.toRgb=function(){return o$1(this.rgba)},r$3.prototype.toRgbString=function(){return r$4=o$1(this.rgba),t$3=r$4.r,n$3=r$4.g,e$3=r$4.b,(u$2=r$4.a)<1?`rgba(`+t$3+`, `+n$3+`, `+e$3+`, `+u$2+`)`:`rgb(`+t$3+`, `+n$3+`, `+e$3+`)`;var r$4,t$3,n$3,e$3,u$2},r$3.prototype.toHsl=function(){return d(c(this.rgba))},r$3.prototype.toHslString=function(){return r$4=d(c(this.rgba)),t$3=r$4.h,n$3=r$4.s,e$3=r$4.l,(u$2=r$4.a)<1?`hsla(`+t$3+`, `+n$3+`%, `+e$3+`%, `+u$2+`)`:`hsl(`+t$3+`, `+n$3+`%, `+e$3+`%)`;var r$4,t$3,n$3,e$3,u$2},r$3.prototype.toHsv=function(){return r$4=h$1(this.rgba),{h:n$1(r$4.h),s:n$1(r$4.s),v:n$1(r$4.v),a:n$1(r$4.a,3)};var r$4},r$3.prototype.invert=function(){return w({r:255-(r$4=this.rgba).r,g:255-r$4.g,b:255-r$4.b,a:r$4.a});var r$4},r$3.prototype.saturate=function(r$4){return r$4===void 0&&(r$4=.1),w(M$2(this.rgba,r$4))},r$3.prototype.desaturate=function(r$4){return r$4===void 0&&(r$4=.1),w(M$2(this.rgba,-r$4))},r$3.prototype.grayscale=function(){return w(M$2(this.rgba,-1))},r$3.prototype.lighten=function(r$4){return r$4===void 0&&(r$4=.1),w($(this.rgba,r$4))},r$3.prototype.darken=function(r$4){return r$4===void 0&&(r$4=.1),w($(this.rgba,-r$4))},r$3.prototype.rotate=function(r$4){return r$4===void 0&&(r$4=15),this.hue(this.hue()+r$4)},r$3.prototype.alpha=function(r$4){return typeof r$4==`number`?w({r:(t$3=this.rgba).r,g:t$3.g,b:t$3.b,a:r$4}):n$1(this.rgba.a,3);var t$3},r$3.prototype.hue=function(r$4){var t$3=c(this.rgba);return typeof r$4==`number`?w({h:r$4,s:t$3.s,l:t$3.l,a:t$3.a}):n$1(t$3.h)},r$3.prototype.isEqual=function(r$4){return this.toHex()===w(r$4).toHex()},r$3}(),w=function(r$3){return r$3 instanceof j?r$3:new j(r$3)},S=[],k=function(r$3){r$3.forEach(function(r$4){S.indexOf(r$4)<0&&(r$4(j,y),S.push(r$4))})},E=function(){return new j({r:255*Math.random(),g:255*Math.random(),b:255*Math.random()})},a=function(a$3){return typeof a$3==`string`?a$3.length>0:typeof a$3==`number`},t=function(a$3,t$3,o$3){return t$3===void 0&&(t$3=0),o$3===void 0&&(o$3=10**t$3),Math.round(o$3*a$3)/o$3+0},o=function(a$3,t$3,o$3){return t$3===void 0&&(t$3=0),o$3===void 0&&(o$3=1),a$3>o$3?o$3:a$3>t$3?a$3:t$3},r=function(a$3){var t$3=a$3/255;return t$3<.04045?t$3/12.92:((t$3+.055)/1.055)**2.4},h=function(a$3){return 255*(a$3>.0031308?1.055*a$3**(1/2.4)-.055:12.92*a$3)},n=96.422,p=100,M$1=82.521,u=function(a$3){var t$3,r$3,n$3={x:.9555766*(t$3=a$3).x+-.0230393*t$3.y+.0631636*t$3.z,y:-.0282895*t$3.x+1.0099416*t$3.y+.0210077*t$3.z,z:.0122982*t$3.x+-.020483*t$3.y+1.3299098*t$3.z};return r$3={r:h(.032404542*n$3.x-.015371385*n$3.y-.004985314*n$3.z),g:h(-.00969266*n$3.x+.018760108*n$3.y+41556e-8*n$3.z),b:h(556434e-9*n$3.x-.002040259*n$3.y+.010572252*n$3.z),a:a$3.a},{r:o(r$3.r,0,255),g:o(r$3.g,0,255),b:o(r$3.b,0,255),a:o(r$3.a)}},e=function(a$3){var t$3=r(a$3.r),h$3=r(a$3.g),u$2=r(a$3.b);return function(a$4){return{x:o(a$4.x,0,n),y:o(a$4.y,0,p),z:o(a$4.z,0,M$1),a:o(a$4.a)}}(function(a$4){return{x:1.0478112*a$4.x+.0228866*a$4.y+-.050127*a$4.z,y:.0295424*a$4.x+.9904844*a$4.y+-.0170491*a$4.z,z:-.0092345*a$4.x+.0150436*a$4.y+.7521316*a$4.z,a:a$4.a}}({x:100*(.4124564*t$3+.3575761*h$3+.1804375*u$2),y:100*(.2126729*t$3+.7151522*h$3+.072175*u$2),z:100*(.0193339*t$3+.119192*h$3+.9503041*u$2),a:a$3.a}))},w$1=216/24389,b=24389/27,i=function(t$3){var r$3=t$3.l,h$3=t$3.a,n$3=t$3.b,p$3=t$3.alpha,M$3=p$3===void 0?1:p$3;if(!a(r$3)||!a(h$3)||!a(n$3))return null;var u$2=function(a$3){return{l:o(a$3.l,0,400),a:a$3.a,b:a$3.b,alpha:o(a$3.alpha)}}({l:Number(r$3),a:Number(h$3),b:Number(n$3),alpha:Number(M$3)});return l(u$2)},l=function(a$3){var t$3=(a$3.l+16)/116,o$3=a$3.a/500+t$3,r$3=t$3-a$3.b/200;return u({x:(o$3**3>w$1?o$3**3:(116*o$3-16)/b)*n,y:(a$3.l>8?((a$3.l+16)/116)**3:a$3.l/b)*p,z:(r$3**3>w$1?r$3**3:(116*r$3-16)/b)*M$1,a:a$3.alpha})};function lab_default(a$3,r$3){a$3.prototype.toLab=function(){return o$3=e(this.rgba),h$3=o$3.y/p,u$2=o$3.z/M$1,r$4=(r$4=o$3.x/n)>w$1?Math.cbrt(r$4):(b*r$4+16)/116,a$4={l:116*(h$3=h$3>w$1?Math.cbrt(h$3):(b*h$3+16)/116)-16,a:500*(r$4-h$3),b:200*(h$3-(u$2=u$2>w$1?Math.cbrt(u$2):(b*u$2+16)/116)),alpha:o$3.a},{l:t(a$4.l,2),a:t(a$4.a,2),b:t(a$4.b,2),alpha:t(a$4.alpha,3)};var a$4,o$3,r$4,h$3,u$2},a$3.prototype.delta=function(r$4){r$4===void 0&&(r$4=`#FFF`);var h$3=r$4 instanceof a$3?r$4:new a$3(r$4),n$3=function(a$4,t$3){var o$3=a$4.l,r$5=a$4.a,h$4=a$4.b,n$4=t$3.l,p$3=t$3.a,M$3=t$3.b,u$2=180/Math.PI,e$3=Math.PI/180,w$3=(r$5**2+h$4**2)**.5,b$3=(p$3**2+M$3**2)**.5,i$3=(o$3+n$4)/2,l$2=((w$3+b$3)/2)**7,c$2=.5*(1-(l$2/(l$2+25**7))**.5),f$1=r$5*(1+c$2),y$2=p$3*(1+c$2),v$2=(f$1**2+h$4**2)**.5,x$2=(y$2**2+M$3**2)**.5,z=(v$2+x$2)/2,s$2=f$1===0&&h$4===0?0:Math.atan2(h$4,f$1)*u$2,d$2=y$2===0&&M$3===0?0:Math.atan2(M$3,y$2)*u$2;s$2<0&&(s$2+=360),d$2<0&&(d$2+=360);var g$1=d$2-s$2,m$1=Math.abs(d$2-s$2);m$1>180&&d$2<=s$2?g$1+=360:m$1>180&&d$2>s$2&&(g$1-=360);var N$2=s$2+d$2;m$1<=180?N$2/=2:N$2=(s$2+d$2<360?N$2+360:N$2-360)/2;var F$1=1-.17*Math.cos(e$3*(N$2-30))+.24*Math.cos(2*e$3*N$2)+.32*Math.cos(e$3*(3*N$2+6))-.2*Math.cos(e$3*(4*N$2-63)),L$1=n$4-o$3,I$2=x$2-v$2,P$1=2*Math.sin(e$3*g$1/2)*(v$2*x$2)**.5,j$2=1+.015*(i$3-50)**2/(20+(i$3-50)**2)**.5,k$2=1+.045*z,q=1+.015*z*F$1,A$1=30*Math.exp(-1*((N$2-275)/25)**2),B$1=-2*(l$2/(l$2+25**7))**.5*Math.sin(2*e$3*A$1);return((L$1/1/j$2)**2+(I$2/1/k$2)**2+(P$1/1/q)**2+B$1*I$2*P$1/(1*k$2*1*q))**.5}(this.toLab(),h$3.toLab())/100;return o(t(n$3,3))},r$3.object.push([i,`lab`])}k([lab_default]);function formatReferenceForMlr(referenceColors,maxValue){let referenceData={r:[],g:[],b:[]};for(let color of referenceColors)referenceData.r.push([color.r/maxValue]),referenceData.g.push([color.g/maxValue]),referenceData.b.push([color.b/maxValue]);return referenceData}function formatInputForMlr(inputColors,maxValue){let inputData=[];for(let color of inputColors)inputData.push(getRegressionVariables(color.r,color.g,color.b,maxValue));return inputData}function correctColor(image,measuredColors,referenceColors){if(checkProcessable(image,{colorModel:[`RGB`,`RGBA`]}),measuredColors.length!==referenceColors.length)throw RangeError(`number of measured colors and reference colors must be the same`);let inputData=formatInputForMlr(measuredColors,image.maxValue),referenceData=formatReferenceForMlr(referenceColors,image.maxValue),mlrRed=new MultivariateLinearRegression(inputData,referenceData.r),mlrGreen=new MultivariateLinearRegression(inputData,referenceData.g),mlrBlue=new MultivariateLinearRegression(inputData,referenceData.b),result=Image.createFrom(image);for(let row=0;row<image.height;row++)for(let column=0;column<image.width;column++){let pixel=image.getPixel(column,row),variables=getRegressionVariables(pixel[0],pixel[1],pixel[2],image.maxValue),clamp=getClamp(image),newPixel=[0,0,0],red$1=mlrRed.predict(variables)[0]*image.maxValue,green$1=mlrGreen.predict(variables)[0]*image.maxValue,blue$1=mlrBlue.predict(variables)[0]*image.maxValue;newPixel[0]=clamp(red$1),newPixel[1]=clamp(green$1),newPixel[2]=clamp(blue$1),image.alpha&&(newPixel[3]=image.getValue(column,row,3)),result.setPixel(column,row,newPixel)}return result}function getRegressionVariables(r$3,g$1,b$3,maxValue){return r$3/=maxValue,g$1/=maxValue,b$3/=maxValue,[r$3,g$1,b$3,r$3**2,g$1**2,b$3**2,r$3**3,g$1**3,b$3**3,r$3*g$1,r$3*b$3,b$3*g$1]}function getMinMax(image){let min$2=Array(image.channels).fill(image.maxValue),max$2=Array(image.channels).fill(0);for(let row=0;row<image.height;row++)for(let column=0;column<image.width;column++)for(let channel=0;channel<image.channels;channel++){let currentValue=image.getValue(column,row,channel);currentValue<min$2[channel]&&(min$2[channel]=currentValue),currentValue>max$2[channel]&&(max$2[channel]=currentValue)}return{min:min$2,max:max$2}}var Image=class Image{width;height;size;bitDepth;colorModel;components;channels;alpha;maxValue;origin;meta;data;constructor(width,height,options={}){let{bitDepth=8,data,colorModel=`RGB`,origin={row:0,column:0},meta}=options;if(width<1||!Number.isInteger(width))throw RangeError(`width must be an integer and at least 1. Received ${width}`);if(height<1||!Number.isInteger(height))throw RangeError(`height must be an integer and at least 1. Received ${height}`);this.width=width,this.height=height,this.size=width*height,this.bitDepth=bitDepth,this.colorModel=colorModel,this.origin=origin,this.meta=meta;let colorModelDef=colorModels[colorModel];if(this.components=colorModelDef.components,this.alpha=colorModelDef.alpha,this.channels=colorModelDef.channels,this.maxValue=2**bitDepth-1,data===void 0)this.data=createPixelArray(this.size,this.channels,this.alpha,this.bitDepth,this.maxValue);else{if(bitDepth===8&&data instanceof Uint16Array)throw RangeError(`bitDepth is ${bitDepth} but data is Uint16Array`);if(bitDepth===16&&data instanceof Uint8Array)throw RangeError(`bitDepth is ${bitDepth} but data is Uint8Array`);let expectedLength=this.size*this.channels;if(data.length!==expectedLength)throw RangeError(`incorrect data size: ${data.length}. Expected ${expectedLength}`);this.data=data}}static createFrom(other,options={}){let{width=other.width,height=other.height}=options,bitDepth;return bitDepth=other instanceof Image?other.bitDepth:8,new Image(width,height,{bitDepth,colorModel:other.colorModel,origin:other.origin,...options})}getPixel(column,row){let result=[],start=(row*this.width+column)*this.channels;for(let i$3=0;i$3<this.channels;i$3++)result.push(this.data[start+i$3]);return result}getColumn(column){let columnValues=[];for(let i$3=0;i$3<this.channels;i$3++){let channelValues=[];for(let j$2=0;j$2<this.height;j$2++)channelValues.push(this.getValue(column,j$2,i$3));columnValues.push(channelValues)}return columnValues}getRow(row){let rowValues=[];for(let i$3=0;i$3<this.channels;i$3++){let channelValues=[];for(let j$2=0;j$2<this.width;j$2++)channelValues.push(this.getValue(j$2,row,i$3));rowValues.push(channelValues)}return rowValues}setPixel(column,row,value){let start=(row*this.width+column)*this.channels;for(let i$3=0;i$3<this.channels;i$3++)this.data[start+i$3]=value[i$3]}setVisiblePixel(column,row,value){column>=0&&column<this.width&&row>=0&&row<this.height&&this.setPixel(column,row,value)}getPixelByIndex(index){let result=[],start=index*this.channels;for(let i$3=0;i$3<this.channels;i$3++)result.push(this.data[start+i$3]);return result}setPixelByIndex(index,value){let start=index*this.channels;for(let i$3=0;i$3<this.channels;i$3++)this.data[start+i$3]=value[i$3]}getValue(column,row,channel){return this.data[(row*this.width+column)*this.channels+channel]}setValue(column,row,channel,value){this.data[(row*this.width+column)*this.channels+channel]=value}setClampedValue(column,row,channel,value){value<0?value=0:value>this.maxValue&&(value=this.maxValue),this.data[(row*this.width+column)*this.channels+channel]=value}getValueByIndex(index,channel){return this.data[index*this.channels+channel]}setValueByIndex(index,channel,value){this.data[index*this.channels+channel]=value}setClampedValueByIndex(index,channel,value){value<0?value=0:value>this.maxValue&&(value=this.maxValue),this.data[index*this.channels+channel]=value}getValueByPoint(point,channel){return this.getValue(point.column,point.row,channel)}setValueByPoint(point,channel,value){this.setValue(point.column,point.row,channel,value)}minMax(){return getMinMax(this)}getRawImage(){return{width:this.width,height:this.height,data:this.data,channels:this.channels,bitDepth:this.bitDepth}}[Symbol.for(`nodejs.util.inspect.custom`)](){let dataString;return dataString=this.height>20||this.width>20?`[...]`:printData(this),`Image {
  width: ${this.width}
  height: ${this.height}
  bitDepth: ${this.bitDepth}
  colorModel: ${this.colorModel}
  channels: ${this.channels}
  data: ${dataString}
}`}fill(value){if(typeof value==`number`)return validateValue(value,this),this.data.fill(value),this;if(value.length!==this.channels)throw RangeError(`the size of value must match the number of channels (${this.channels}). Received ${value.length}`);for(let val of value)validateValue(val,this);for(let i$3=0;i$3<this.data.length;i$3+=this.channels)for(let j$2=0;j$2<=this.channels;j$2++)this.data[i$3+j$2]=value[j$2];return this}fillChannel(channel,value){validateChannel(channel,this),validateValue(value,this);for(let i$3=channel;i$3<this.data.length;i$3+=this.channels)this.data[i$3]=value;return this}getChannel(channel){validateChannel(channel,this);let result=Array(this.size);for(let i$3=0;i$3<this.size;i$3++)result[i$3]=this.data[channel+i$3*this.channels];return result}fillAlpha(value){if(validateValue(value,this),!this.alpha)throw TypeError(`fillAlpha can only be called if the image has an alpha channel`);let alphaIndex=this.channels-1;return this.fillChannel(alphaIndex,value)}clone(){return Image.createFrom(this,{data:this.data.slice()})}changeEach(cb){for(let i$3=0;i$3<this.data.length;i$3++)this.data[i$3]=cb(this.data[i$3])}getCoordinates(coordinates,round$1=!1){return M(coordinates).with(`center`,()=>{let centerX=(this.width-1)/2,centerY=(this.height-1)/2;return round$1?{column:Math.round(centerX),row:Math.round(centerY)}:{column:centerX,row:centerY}}).with(`top-left`,()=>({column:0,row:0})).with(`top-right`,()=>({column:this.width-1,row:0})).with(`bottom-left`,()=>({column:0,row:this.height-1})).with(`bottom-right`,()=>({column:this.width-1,row:this.height-1})).exhaustive()}subtract(other,options={}){return subtract(this,other,options)}add(other){return add(this,other)}multiply(value,options={}){return multiply(this,value,options)}divide(value,options={}){return divide(this,value,options)}histogram(options){return histogram(this,options)}mean(options){return mean(this,options)}median(options){return median(this,options)}variance(options){return variance(this,options)}drawPoints(points,options={}){return drawPoints(this,points,options)}drawLine(from,to,options={}){return drawLineOnImage(this,from,to,options)}drawRectangle(options={}){return drawRectangle(this,options)}drawPolyline(points,options={}){return drawPolylineOnImage(this,points,options)}drawPolygon(points,options={}){return drawPolygonOnImage(this,points,options)}drawCircle(center,radius,options={}){return drawCircleOnImage(this,center,radius,options)}drawMarker(point,options={}){return drawMarker(this,point,options)}drawMarkers(points,options={}){return drawMarkers(this,points,options)}split(){return split(this)}convertColor(colorModel,options){return convertColor(this,colorModel,options)}convertBitDepth(newDepth,options){return convertBitDepth(this,newDepth,options)}grey(options){return grey(this,options)}copyTo(target,options={}){return copyTo(this,target,options)}threshold(options={}){return threshold(this,options)}crop(options){return crop(this,options)}cropRectangle(points,options){return cropRectangle(this,points,options)}cropAlpha(options={}){return cropAlpha(this,options)}extract(mask,options){return extract(this,mask,options)}paintMask(mask,options){return paintMaskOnImage(this,mask,options)}blur(options){return blur(this,options)}pixelate(options){return pixelate(this,options)}directConvolution(kernel,options){return directConvolution(this,kernel,options)}rawDirectConvolution(kernel,options){return rawDirectConvolution(this,kernel,options)}separableConvolution(kernelX$1,kernelY$1,options){return separableConvolution(this,kernelX$1,kernelY$1,options)}gaussianBlur(options){return gaussianBlur(this,options)}flip(options){return flip(this,options)}invert(options){return invert(this,options)}hypotenuse(other,options){return hypotenuse(this,other,options)}gradientFilter(options){return gradientFilter(this,options)}derivativeFilter(options){return derivativeFilter(this,options)}level(options){return level(this,options)}increaseContrast(options={}){return increaseContrast(this,options)}correctColor(measuredColors,referenceColors){return correctColor(this,measuredColors,referenceColors)}medianFilter(options){return medianFilter(this,options)}resize(options){return resize(this,options)}rotate(angle){return rotate(this,angle)}transform(transformMatrix,options){return transform(this,transformMatrix,options)}transformRotate(angle,options){return transformRotate(this,angle,options)}erode(options){return erode(this,options)}dilate(options){return dilate(this,options)}open(options){return open(this,options)}close(options){return close(this,options)}topHat(options){return topHat(this,options)}bottomHat(options){return bottomHat(this,options)}morphologicalGradient(options){return morphologicalGradient(this,options)}cannyEdgeDetector(options){return cannyEdgeDetector(this,options)}};function createPixelArray(size,channels,alpha,bitDepth,maxValue){let length=channels*size,arr=M(bitDepth).with(8,()=>new Uint8Array(length)).with(16,()=>new Uint16Array(length)).otherwise(()=>{throw RangeError(`invalid bitDepth: ${bitDepth}`)});if(alpha)for(let i$3=channels-1;i$3<length;i$3+=channels)arr[i$3]=maxValue;return arr}function printData(img){let result=[],padding=img.bitDepth===8?3:5;for(let row=0;row<img.height;row++){let currentRow=[];for(let column=0;column<img.width;column++)for(let channel=0;channel<img.channels;channel++)currentRow.push(String(img.getValue(column,row,channel)).padStart(padding,` `));result.push(`[${currentRow.join(` `)}]`)}return`{
    [\n     ${result.join(`
     `)}\n    ]
  }`}function copyData(source,target){if(target.width!==source.width||target.height!==source.height||target.colorModel!==source.colorModel)throw RangeError(`images width, height or color model is different`);target.data=source.data.slice()}function getOutputImage(thisImage,options={},internalOptions={}){let{out}=options,{newParameters,clone}=internalOptions;if(out===void 0)return clone?thisImage.clone():Image.createFrom(thisImage,newParameters);{if(!(out instanceof Image))throw TypeError(`out must be an Image`);let requirements={width:thisImage.width,height:thisImage.height,bitDepth:thisImage.bitDepth,colorModel:thisImage.colorModel,...newParameters};return checkRequirements(requirements,out),clone&&thisImage!==out&&copyData(thisImage,out),out}}function maskToOutputImage(mask,options={}){let{out}=options;if(out===void 0)return Image.createFrom(mask,{colorModel:`GREY`});{if(!(out instanceof Image))throw TypeError(`out must be an Image`);let requirements={width:mask.width,height:mask.height,bitDepth:8,colorModel:`GREY`};return checkRequirements(requirements,out),out}}function imageToOutputMask(image,options={}){let{out}=options;if(out===void 0)return Mask.createFrom(image);{if(!(out instanceof Mask))throw TypeError(`out must be a Mask`);let requirements={width:image.width,height:image.height,bitDepth:1,colorModel:`BINARY`};return checkRequirements(requirements,out),out}}function checkRequirements(requirements,out){for(let property in requirements){let prop=property;if(out[prop]!==requirements[prop])throw RangeError(`cannot use out image. Its ${property} property must be ${requirements[prop]}. Received ${out[prop]}`)}}function maskToOutputMask(mask,options={},internalOptions={}){let{out}=options,{newParameters,clone}=internalOptions;if(out===void 0)return clone?mask.clone():Mask.createFrom(mask,newParameters);{if(!(out instanceof Mask))throw TypeError(`out must be a Mask`);let requirements={width:mask.width,height:mask.height,bitDepth:1,colorModel:`BINARY`};return checkRequirements(requirements,out),clone&&mask!==out&&copyData(mask,out),out}}var encoder=new TextEncoder,defaultByteLength=1024*8,hostBigEndian=(()=>{let array=new Uint8Array(4),view=new Uint32Array(array.buffer);return!((view[0]=1)&array[0])})(),typedArrays={int8:globalThis.Int8Array,uint8:globalThis.Uint8Array,int16:globalThis.Int16Array,uint16:globalThis.Uint16Array,int32:globalThis.Int32Array,uint32:globalThis.Uint32Array,uint64:globalThis.BigUint64Array,int64:globalThis.BigInt64Array,float32:globalThis.Float32Array,float64:globalThis.Float64Array},require_encoder=__commonJSMin(((exports,module)=>{function JPEGEncoder(quality){Math.round;var ffloor=Math.floor,YTable=Array(64),UVTable=Array(64),fdtbl_Y=Array(64),fdtbl_UV=Array(64),YDC_HT,UVDC_HT,YAC_HT,UVAC_HT,bitcode=Array(65535),category=Array(65535),outputfDCTQuant=Array(64),DU=Array(64),byteout=[],bytenew=0,bytepos=7,YDU=Array(64),UDU=Array(64),VDU=Array(64),clt=Array(256),RGB_YUV_TABLE=Array(2048),currentQuality,ZigZag=[0,1,5,6,14,15,27,28,2,4,7,13,16,26,29,42,3,8,12,17,25,30,41,43,9,11,18,24,31,40,44,53,10,19,23,32,39,45,52,54,20,22,33,38,46,51,55,60,21,34,37,47,50,56,59,61,35,36,48,49,57,58,62,63],std_dc_luminance_nrcodes=[0,0,1,5,1,1,1,1,1,1,0,0,0,0,0,0,0],std_dc_luminance_values=[0,1,2,3,4,5,6,7,8,9,10,11],std_ac_luminance_nrcodes=[0,0,2,1,3,3,2,4,3,5,5,4,4,0,0,1,125],std_ac_luminance_values=[1,2,3,0,4,17,5,18,33,49,65,6,19,81,97,7,34,113,20,50,129,145,161,8,35,66,177,193,21,82,209,240,36,51,98,114,130,9,10,22,23,24,25,26,37,38,39,40,41,42,52,53,54,55,56,57,58,67,68,69,70,71,72,73,74,83,84,85,86,87,88,89,90,99,100,101,102,103,104,105,106,115,116,117,118,119,120,121,122,131,132,133,134,135,136,137,138,146,147,148,149,150,151,152,153,154,162,163,164,165,166,167,168,169,170,178,179,180,181,182,183,184,185,186,194,195,196,197,198,199,200,201,202,210,211,212,213,214,215,216,217,218,225,226,227,228,229,230,231,232,233,234,241,242,243,244,245,246,247,248,249,250],std_dc_chrominance_nrcodes=[0,0,3,1,1,1,1,1,1,1,1,1,0,0,0,0,0],std_dc_chrominance_values=[0,1,2,3,4,5,6,7,8,9,10,11],std_ac_chrominance_nrcodes=[0,0,2,1,2,4,4,3,4,7,5,4,4,0,1,2,119],std_ac_chrominance_values=[0,1,2,3,17,4,5,33,49,6,18,65,81,7,97,113,19,34,50,129,8,20,66,145,161,177,193,9,35,51,82,240,21,98,114,209,10,22,36,52,225,37,241,23,24,25,26,38,39,40,41,42,53,54,55,56,57,58,67,68,69,70,71,72,73,74,83,84,85,86,87,88,89,90,99,100,101,102,103,104,105,106,115,116,117,118,119,120,121,122,130,131,132,133,134,135,136,137,138,146,147,148,149,150,151,152,153,154,162,163,164,165,166,167,168,169,170,178,179,180,181,182,183,184,185,186,194,195,196,197,198,199,200,201,202,210,211,212,213,214,215,216,217,218,226,227,228,229,230,231,232,233,234,242,243,244,245,246,247,248,249,250];function initQuantTables(sf){for(var YQT=[16,11,10,16,24,40,51,61,12,12,14,19,26,58,60,55,14,13,16,24,40,57,69,56,14,17,22,29,51,87,80,62,18,22,37,56,68,109,103,77,24,35,55,64,81,104,113,92,49,64,78,87,103,121,120,101,72,92,95,98,112,100,103,99],i$3=0;i$3<64;i$3++){var t$3=ffloor((YQT[i$3]*sf+50)/100);t$3<1?t$3=1:t$3>255&&(t$3=255),YTable[ZigZag[i$3]]=t$3}for(var UVQT=[17,18,24,47,99,99,99,99,18,21,26,66,99,99,99,99,24,26,56,99,99,99,99,99,47,66,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99],j$2=0;j$2<64;j$2++){var u$2=ffloor((UVQT[j$2]*sf+50)/100);u$2<1?u$2=1:u$2>255&&(u$2=255),UVTable[ZigZag[j$2]]=u$2}for(var aasf=[1,1.387039845,1.306562965,1.175875602,1,.785694958,.5411961,.275899379],k$2=0,row=0;row<8;row++)for(var col=0;col<8;col++)fdtbl_Y[k$2]=1/(YTable[ZigZag[k$2]]*aasf[row]*aasf[col]*8),fdtbl_UV[k$2]=1/(UVTable[ZigZag[k$2]]*aasf[row]*aasf[col]*8),k$2++}function computeHuffmanTbl(nrcodes,std_table){for(var codevalue=0,pos_in_table=0,HT=[],k$2=1;k$2<=16;k$2++){for(var j$2=1;j$2<=nrcodes[k$2];j$2++)HT[std_table[pos_in_table]]=[],HT[std_table[pos_in_table]][0]=codevalue,HT[std_table[pos_in_table]][1]=k$2,pos_in_table++,codevalue++;codevalue*=2}return HT}function initHuffmanTbl(){YDC_HT=computeHuffmanTbl(std_dc_luminance_nrcodes,std_dc_luminance_values),UVDC_HT=computeHuffmanTbl(std_dc_chrominance_nrcodes,std_dc_chrominance_values),YAC_HT=computeHuffmanTbl(std_ac_luminance_nrcodes,std_ac_luminance_values),UVAC_HT=computeHuffmanTbl(std_ac_chrominance_nrcodes,std_ac_chrominance_values)}function initCategoryNumber(){for(var nrlower=1,nrupper=2,cat=1;cat<=15;cat++){for(var nr=nrlower;nr<nrupper;nr++)category[32767+nr]=cat,bitcode[32767+nr]=[],bitcode[32767+nr][1]=cat,bitcode[32767+nr][0]=nr;for(var nrneg=-(nrupper-1);nrneg<=-nrlower;nrneg++)category[32767+nrneg]=cat,bitcode[32767+nrneg]=[],bitcode[32767+nrneg][1]=cat,bitcode[32767+nrneg][0]=nrupper-1+nrneg;nrlower<<=1,nrupper<<=1}}function initRGBYUVTable(){for(var i$3=0;i$3<256;i$3++)RGB_YUV_TABLE[i$3]=19595*i$3,RGB_YUV_TABLE[i$3+256>>0]=38470*i$3,RGB_YUV_TABLE[i$3+512>>0]=7471*i$3+32768,RGB_YUV_TABLE[i$3+768>>0]=-11059*i$3,RGB_YUV_TABLE[i$3+1024>>0]=-21709*i$3,RGB_YUV_TABLE[i$3+1280>>0]=32768*i$3+8421375,RGB_YUV_TABLE[i$3+1536>>0]=-27439*i$3,RGB_YUV_TABLE[i$3+1792>>0]=-5329*i$3}function writeBits(bs){for(var value=bs[0],posval=bs[1]-1;posval>=0;)value&1<<posval&&(bytenew|=1<<bytepos),posval--,bytepos--,bytepos<0&&(bytenew==255?(writeByte(255),writeByte(0)):writeByte(bytenew),bytepos=7,bytenew=0)}function writeByte(value){byteout.push(value)}function writeWord(value){writeByte(value>>8&255),writeByte(value&255)}function fDCTQuant(data,fdtbl){var d0,d1,d2,d3,d4,d5,d6,d7,dataOff=0,i$3,I8=8,I64=64;for(i$3=0;i$3<I8;++i$3){d0=data[dataOff],d1=data[dataOff+1],d2=data[dataOff+2],d3=data[dataOff+3],d4=data[dataOff+4],d5=data[dataOff+5],d6=data[dataOff+6],d7=data[dataOff+7];var tmp0=d0+d7,tmp7=d0-d7,tmp1=d1+d6,tmp6=d1-d6,tmp2=d2+d5,tmp5=d2-d5,tmp3=d3+d4,tmp4=d3-d4,tmp10=tmp0+tmp3,tmp13=tmp0-tmp3,tmp11=tmp1+tmp2,tmp12=tmp1-tmp2;data[dataOff]=tmp10+tmp11,data[dataOff+4]=tmp10-tmp11;var z1=(tmp12+tmp13)*.707106781;data[dataOff+2]=tmp13+z1,data[dataOff+6]=tmp13-z1,tmp10=tmp4+tmp5,tmp11=tmp5+tmp6,tmp12=tmp6+tmp7;var z5=(tmp10-tmp12)*.382683433,z2=.5411961*tmp10+z5,z4=1.306562965*tmp12+z5,z3=tmp11*.707106781,z11=tmp7+z3,z13=tmp7-z3;data[dataOff+5]=z13+z2,data[dataOff+3]=z13-z2,data[dataOff+1]=z11+z4,data[dataOff+7]=z11-z4,dataOff+=8}for(dataOff=0,i$3=0;i$3<I8;++i$3){d0=data[dataOff],d1=data[dataOff+8],d2=data[dataOff+16],d3=data[dataOff+24],d4=data[dataOff+32],d5=data[dataOff+40],d6=data[dataOff+48],d7=data[dataOff+56];var tmp0p2=d0+d7,tmp7p2=d0-d7,tmp1p2=d1+d6,tmp6p2=d1-d6,tmp2p2=d2+d5,tmp5p2=d2-d5,tmp3p2=d3+d4,tmp4p2=d3-d4,tmp10p2=tmp0p2+tmp3p2,tmp13p2=tmp0p2-tmp3p2,tmp11p2=tmp1p2+tmp2p2,tmp12p2=tmp1p2-tmp2p2;data[dataOff]=tmp10p2+tmp11p2,data[dataOff+32]=tmp10p2-tmp11p2;var z1p2=(tmp12p2+tmp13p2)*.707106781;data[dataOff+16]=tmp13p2+z1p2,data[dataOff+48]=tmp13p2-z1p2,tmp10p2=tmp4p2+tmp5p2,tmp11p2=tmp5p2+tmp6p2,tmp12p2=tmp6p2+tmp7p2;var z5p2=(tmp10p2-tmp12p2)*.382683433,z2p2=.5411961*tmp10p2+z5p2,z4p2=1.306562965*tmp12p2+z5p2,z3p2=tmp11p2*.707106781,z11p2=tmp7p2+z3p2,z13p2=tmp7p2-z3p2;data[dataOff+40]=z13p2+z2p2,data[dataOff+24]=z13p2-z2p2,data[dataOff+8]=z11p2+z4p2,data[dataOff+56]=z11p2-z4p2,dataOff++}var fDCTQuant$1;for(i$3=0;i$3<I64;++i$3)fDCTQuant$1=data[i$3]*fdtbl[i$3],outputfDCTQuant[i$3]=fDCTQuant$1>0?fDCTQuant$1+.5|0:fDCTQuant$1-.5|0;return outputfDCTQuant}function writeAPP0(){writeWord(65504),writeWord(16),writeByte(74),writeByte(70),writeByte(73),writeByte(70),writeByte(0),writeByte(1),writeByte(1),writeByte(0),writeWord(1),writeWord(1),writeByte(0),writeByte(0)}function writeAPP1(exifBuffer){if(exifBuffer){writeWord(65505),exifBuffer[0]===69&&exifBuffer[1]===120&&exifBuffer[2]===105&&exifBuffer[3]===102?writeWord(exifBuffer.length+2):(writeWord(exifBuffer.length+5+2),writeByte(69),writeByte(120),writeByte(105),writeByte(102),writeByte(0));for(var i$3=0;i$3<exifBuffer.length;i$3++)writeByte(exifBuffer[i$3])}}function writeSOF0(width,height){writeWord(65472),writeWord(17),writeByte(8),writeWord(height),writeWord(width),writeByte(3),writeByte(1),writeByte(17),writeByte(0),writeByte(2),writeByte(17),writeByte(1),writeByte(3),writeByte(17),writeByte(1)}function writeDQT(){writeWord(65499),writeWord(132),writeByte(0);for(var i$3=0;i$3<64;i$3++)writeByte(YTable[i$3]);writeByte(1);for(var j$2=0;j$2<64;j$2++)writeByte(UVTable[j$2])}function writeDHT(){writeWord(65476),writeWord(418),writeByte(0);for(var i$3=0;i$3<16;i$3++)writeByte(std_dc_luminance_nrcodes[i$3+1]);for(var j$2=0;j$2<=11;j$2++)writeByte(std_dc_luminance_values[j$2]);writeByte(16);for(var k$2=0;k$2<16;k$2++)writeByte(std_ac_luminance_nrcodes[k$2+1]);for(var l$2=0;l$2<=161;l$2++)writeByte(std_ac_luminance_values[l$2]);writeByte(1);for(var m$1=0;m$1<16;m$1++)writeByte(std_dc_chrominance_nrcodes[m$1+1]);for(var n$3=0;n$3<=11;n$3++)writeByte(std_dc_chrominance_values[n$3]);writeByte(17);for(var o$3=0;o$3<16;o$3++)writeByte(std_ac_chrominance_nrcodes[o$3+1]);for(var p$3=0;p$3<=161;p$3++)writeByte(std_ac_chrominance_values[p$3])}function writeCOM(comments){comments===void 0||comments.constructor!==Array||comments.forEach(e$3=>{if(typeof e$3==`string`){writeWord(65534);var l$2=e$3.length;writeWord(l$2+2);var i$3;for(i$3=0;i$3<l$2;i$3++)writeByte(e$3.charCodeAt(i$3))}})}function writeSOS(){writeWord(65498),writeWord(12),writeByte(3),writeByte(1),writeByte(0),writeByte(2),writeByte(17),writeByte(3),writeByte(17),writeByte(0),writeByte(63),writeByte(0)}function processDU(CDU,fdtbl,DC,HTDC,HTAC){for(var EOB=HTAC[0],M16zeroes=HTAC[240],pos,I16=16,I63=63,I64=64,DU_DCT=fDCTQuant(CDU,fdtbl),j$2=0;j$2<I64;++j$2)DU[ZigZag[j$2]]=DU_DCT[j$2];var Diff=DU[0]-DC;DC=DU[0],Diff==0?writeBits(HTDC[0]):(pos=32767+Diff,writeBits(HTDC[category[pos]]),writeBits(bitcode[pos]));for(var end0pos=63;end0pos>0&&DU[end0pos]==0;end0pos--);if(end0pos==0)return writeBits(EOB),DC;for(var i$3=1,lng;i$3<=end0pos;){for(var startpos=i$3;DU[i$3]==0&&i$3<=end0pos;++i$3);var nrzeroes=i$3-startpos;if(nrzeroes>=I16){lng=nrzeroes>>4;for(var nrmarker=1;nrmarker<=lng;++nrmarker)writeBits(M16zeroes);nrzeroes&=15}pos=32767+DU[i$3],writeBits(HTAC[(nrzeroes<<4)+category[pos]]),writeBits(bitcode[pos]),i$3++}return end0pos!=I63&&writeBits(EOB),DC}function initCharLookupTable(){for(var sfcc=String.fromCharCode,i$3=0;i$3<256;i$3++)clt[i$3]=sfcc(i$3)}this.encode=function(image,quality$1){new Date().getTime(),quality$1&&setQuality(quality$1),byteout=[],bytenew=0,bytepos=7,writeWord(65496),writeAPP0(),writeCOM(image.comments),writeAPP1(image.exifBuffer),writeDQT(),writeSOF0(image.width,image.height),writeDHT(),writeSOS();var DCY=0,DCU=0,DCV=0;bytenew=0,bytepos=7,this.encode.displayName=`_encode_`;var imageData=image.data,width=image.width,height=image.height,quadWidth=width*4;width*3;for(var x$2,y$2=0,r$3,g$1,b$3,start,p$3,col,row,pos;y$2<height;){for(x$2=0;x$2<quadWidth;){for(start=quadWidth*y$2+x$2,p$3=start,col=-1,row=0,pos=0;pos<64;pos++)row=pos>>3,col=(pos&7)*4,p$3=start+row*quadWidth+col,y$2+row>=height&&(p$3-=quadWidth*(y$2+1+row-height)),x$2+col>=quadWidth&&(p$3-=x$2+col-quadWidth+4),r$3=imageData[p$3++],g$1=imageData[p$3++],b$3=imageData[p$3++],YDU[pos]=(RGB_YUV_TABLE[r$3]+RGB_YUV_TABLE[g$1+256>>0]+RGB_YUV_TABLE[b$3+512>>0]>>16)-128,UDU[pos]=(RGB_YUV_TABLE[r$3+768>>0]+RGB_YUV_TABLE[g$1+1024>>0]+RGB_YUV_TABLE[b$3+1280>>0]>>16)-128,VDU[pos]=(RGB_YUV_TABLE[r$3+1280>>0]+RGB_YUV_TABLE[g$1+1536>>0]+RGB_YUV_TABLE[b$3+1792>>0]>>16)-128;DCY=processDU(YDU,fdtbl_Y,DCY,YDC_HT,YAC_HT),DCU=processDU(UDU,fdtbl_UV,DCU,UVDC_HT,UVAC_HT),DCV=processDU(VDU,fdtbl_UV,DCV,UVDC_HT,UVAC_HT),x$2+=32}y$2+=8}if(bytepos>=0){var fillbits=[];fillbits[1]=bytepos+1,fillbits[0]=(1<<bytepos+1)-1,writeBits(fillbits)}return writeWord(65497),module===void 0?new Uint8Array(byteout):Buffer.from(byteout)};function setQuality(quality$1){if(quality$1<=0&&(quality$1=1),quality$1>100&&(quality$1=100),currentQuality!=quality$1){var sf=0;sf=quality$1<50?Math.floor(5e3/quality$1):Math.floor(200-quality$1*2),initQuantTables(sf),currentQuality=quality$1}}function init(){var time_start=new Date().getTime();quality||=50,initCharLookupTable(),initHuffmanTbl(),initCategoryNumber(),initRGBYUVTable(),setQuality(quality),new Date().getTime()-time_start}init()}module===void 0?typeof window<`u`&&(window[`jpeg-js`]=window[`jpeg-js`]||{},window[`jpeg-js`].encode=encode$2):module.exports=encode$2;function encode$2(imgData,qu){return qu===void 0&&(qu=50),{data:new JPEGEncoder(qu).encode(imgData,qu),width:imgData.width,height:imgData.height}}})),require_decoder=__commonJSMin(((exports,module)=>{var JpegImage=(function(){var dctZigZag=new Int32Array([0,1,8,16,9,2,3,10,17,24,32,25,18,11,4,5,12,19,26,33,40,48,41,34,27,20,13,6,7,14,21,28,35,42,49,56,57,50,43,36,29,22,15,23,30,37,44,51,58,59,52,45,38,31,39,46,53,60,61,54,47,55,62,63]),dctCos1=4017,dctSin1=799,dctCos3=3406,dctSin3=2276,dctCos6=1567,dctSin6=3784,dctSqrt2=5793,dctSqrt1d2=2896;function constructor(){}function buildHuffmanTable(codeLengths,values){for(var k$2=0,code=[],i$3,j$2,length=16;length>0&&!codeLengths[length-1];)length--;code.push({children:[],index:0});var p$3=code[0],q;for(i$3=0;i$3<length;i$3++){for(j$2=0;j$2<codeLengths[i$3];j$2++){for(p$3=code.pop(),p$3.children[p$3.index]=values[k$2];p$3.index>0;){if(code.length===0)throw Error(`Could not recreate Huffman Table`);p$3=code.pop()}for(p$3.index++,code.push(p$3);code.length<=i$3;)code.push(q={children:[],index:0}),p$3.children[p$3.index]=q.children,p$3=q;k$2++}i$3+1<length&&(code.push(q={children:[],index:0}),p$3.children[p$3.index]=q.children,p$3=q)}return code[0].children}function decodeScan(data,offset,frame,components,resetInterval,spectralStart,spectralEnd,successivePrev,successive,opts){frame.precision,frame.samplesPerLine,frame.scanLines;var mcusPerLine=frame.mcusPerLine,progressive=frame.progressive;frame.maxH,frame.maxV;var startOffset=offset,bitsData=0,bitsCount=0;function readBit(){if(bitsCount>0)return bitsCount--,bitsData>>bitsCount&1;if(bitsData=data[offset++],bitsData==255){var nextByte=data[offset++];if(nextByte)throw Error(`unexpected marker: `+(bitsData<<8|nextByte).toString(16))}return bitsCount=7,bitsData>>>7}function decodeHuffman(tree){for(var node=tree,bit;(bit=readBit())!==null;){if(node=node[bit],typeof node==`number`)return node;if(typeof node!=`object`)throw Error(`invalid huffman sequence`)}return null}function receive(length){for(var n$4=0;length>0;){var bit=readBit();if(bit===null)return;n$4=n$4<<1|bit,length--}return n$4}function receiveAndExtend(length){var n$4=receive(length);return n$4>=1<<length-1?n$4:n$4+(-1<<length)+1}function decodeBaseline(component$1,zz){var t$3=decodeHuffman(component$1.huffmanTableDC),diff=t$3===0?0:receiveAndExtend(t$3);zz[0]=component$1.pred+=diff;for(var k$3=1;k$3<64;){var rs=decodeHuffman(component$1.huffmanTableAC),s$2=rs&15,r$3=rs>>4;if(s$2===0){if(r$3<15)break;k$3+=16;continue}k$3+=r$3;var z=dctZigZag[k$3];zz[z]=receiveAndExtend(s$2),k$3++}}function decodeDCFirst(component$1,zz){var t$3=decodeHuffman(component$1.huffmanTableDC),diff=t$3===0?0:receiveAndExtend(t$3)<<successive;zz[0]=component$1.pred+=diff}function decodeDCSuccessive(component$1,zz){zz[0]|=readBit()<<successive}var eobrun=0;function decodeACFirst(component$1,zz){if(eobrun>0){eobrun--;return}for(var k$3=spectralStart,e$3=spectralEnd;k$3<=e$3;){var rs=decodeHuffman(component$1.huffmanTableAC),s$2=rs&15,r$3=rs>>4;if(s$2===0){if(r$3<15){eobrun=receive(r$3)+(1<<r$3)-1;break}k$3+=16;continue}k$3+=r$3;var z=dctZigZag[k$3];zz[z]=receiveAndExtend(s$2)*(1<<successive),k$3++}}var successiveACState=0,successiveACNextValue;function decodeACSuccessive(component$1,zz){for(var k$3=spectralStart,e$3=spectralEnd,r$3=0;k$3<=e$3;){var z=dctZigZag[k$3],direction=zz[z]<0?-1:1;switch(successiveACState){case 0:var rs=decodeHuffman(component$1.huffmanTableAC),s$2=rs&15,r$3=rs>>4;if(s$2===0)r$3<15?(eobrun=receive(r$3)+(1<<r$3),successiveACState=4):(r$3=16,successiveACState=1);else{if(s$2!==1)throw Error(`invalid ACn encoding`);successiveACNextValue=receiveAndExtend(s$2),successiveACState=r$3?2:3}continue;case 1:case 2:zz[z]?zz[z]+=(readBit()<<successive)*direction:(r$3--,r$3===0&&(successiveACState=successiveACState==2?3:0));break;case 3:zz[z]?zz[z]+=(readBit()<<successive)*direction:(zz[z]=successiveACNextValue<<successive,successiveACState=0);break;case 4:zz[z]&&(zz[z]+=(readBit()<<successive)*direction);break}k$3++}successiveACState===4&&(eobrun--,eobrun===0&&(successiveACState=0))}function decodeMcu(component$1,decode$3,mcu$1,row,col){var mcuRow=mcu$1/mcusPerLine|0,mcuCol=mcu$1%mcusPerLine,blockRow=mcuRow*component$1.v+row,blockCol=mcuCol*component$1.h+col;component$1.blocks[blockRow]===void 0&&opts.tolerantDecoding||decode$3(component$1,component$1.blocks[blockRow][blockCol])}function decodeBlock(component$1,decode$3,mcu$1){var blockRow=mcu$1/component$1.blocksPerLine|0,blockCol=mcu$1%component$1.blocksPerLine;component$1.blocks[blockRow]===void 0&&opts.tolerantDecoding||decode$3(component$1,component$1.blocks[blockRow][blockCol])}var componentsLength=components.length,component,i$3,j$2,k$2,n$3,decodeFn=progressive?spectralStart===0?successivePrev===0?decodeDCFirst:decodeDCSuccessive:successivePrev===0?decodeACFirst:decodeACSuccessive:decodeBaseline,mcu=0,marker,mcuExpected=componentsLength==1?components[0].blocksPerLine*components[0].blocksPerColumn:mcusPerLine*frame.mcusPerColumn;resetInterval||=mcuExpected;for(var h$3,v$2;mcu<mcuExpected;){for(i$3=0;i$3<componentsLength;i$3++)components[i$3].pred=0;if(eobrun=0,componentsLength==1)for(component=components[0],n$3=0;n$3<resetInterval;n$3++)decodeBlock(component,decodeFn,mcu),mcu++;else for(n$3=0;n$3<resetInterval;n$3++){for(i$3=0;i$3<componentsLength;i$3++)for(component=components[i$3],h$3=component.h,v$2=component.v,j$2=0;j$2<v$2;j$2++)for(k$2=0;k$2<h$3;k$2++)decodeMcu(component,decodeFn,mcu,j$2,k$2);if(mcu++,mcu===mcuExpected)break}if(mcu===mcuExpected)do{if(data[offset]===255&&data[offset+1]!==0)break;offset+=1}while(offset<data.length-2);if(bitsCount=0,marker=data[offset]<<8|data[offset+1],marker<65280)throw Error(`marker was not found`);if(marker>=65488&&marker<=65495)offset+=2;else break}return offset-startOffset}function buildComponentData(frame,component){var lines=[],blocksPerLine=component.blocksPerLine,blocksPerColumn=component.blocksPerColumn,samplesPerLine=blocksPerLine<<3,R$1=new Int32Array(64),r$3=new Uint8Array(64);function quantizeAndInverse(zz,dataOut,dataIn){var qt=component.quantizationTable,v0,v1,v2,v3,v4,v5,v6,v7,t$3,p$3=dataIn,i$4;for(i$4=0;i$4<64;i$4++)p$3[i$4]=zz[i$4]*qt[i$4];for(i$4=0;i$4<8;++i$4){var row=8*i$4;if(p$3[1+row]==0&&p$3[2+row]==0&&p$3[3+row]==0&&p$3[4+row]==0&&p$3[5+row]==0&&p$3[6+row]==0&&p$3[7+row]==0){t$3=dctSqrt2*p$3[0+row]+512>>10,p$3[0+row]=t$3,p$3[1+row]=t$3,p$3[2+row]=t$3,p$3[3+row]=t$3,p$3[4+row]=t$3,p$3[5+row]=t$3,p$3[6+row]=t$3,p$3[7+row]=t$3;continue}v0=dctSqrt2*p$3[0+row]+128>>8,v1=dctSqrt2*p$3[4+row]+128>>8,v2=p$3[2+row],v3=p$3[6+row],v4=dctSqrt1d2*(p$3[1+row]-p$3[7+row])+128>>8,v7=dctSqrt1d2*(p$3[1+row]+p$3[7+row])+128>>8,v5=p$3[3+row]<<4,v6=p$3[5+row]<<4,t$3=v0-v1+1>>1,v0=v0+v1+1>>1,v1=t$3,t$3=v2*dctSin6+v3*dctCos6+128>>8,v2=v2*dctCos6-v3*dctSin6+128>>8,v3=t$3,t$3=v4-v6+1>>1,v4=v4+v6+1>>1,v6=t$3,t$3=v7+v5+1>>1,v5=v7-v5+1>>1,v7=t$3,t$3=v0-v3+1>>1,v0=v0+v3+1>>1,v3=t$3,t$3=v1-v2+1>>1,v1=v1+v2+1>>1,v2=t$3,t$3=v4*dctSin3+v7*dctCos3+2048>>12,v4=v4*dctCos3-v7*dctSin3+2048>>12,v7=t$3,t$3=v5*dctSin1+v6*dctCos1+2048>>12,v5=v5*dctCos1-v6*dctSin1+2048>>12,v6=t$3,p$3[0+row]=v0+v7,p$3[7+row]=v0-v7,p$3[1+row]=v1+v6,p$3[6+row]=v1-v6,p$3[2+row]=v2+v5,p$3[5+row]=v2-v5,p$3[3+row]=v3+v4,p$3[4+row]=v3-v4}for(i$4=0;i$4<8;++i$4){var col=i$4;if(p$3[8+col]==0&&p$3[16+col]==0&&p$3[24+col]==0&&p$3[32+col]==0&&p$3[40+col]==0&&p$3[48+col]==0&&p$3[56+col]==0){t$3=dctSqrt2*dataIn[i$4+0]+8192>>14,p$3[0+col]=t$3,p$3[8+col]=t$3,p$3[16+col]=t$3,p$3[24+col]=t$3,p$3[32+col]=t$3,p$3[40+col]=t$3,p$3[48+col]=t$3,p$3[56+col]=t$3;continue}v0=dctSqrt2*p$3[0+col]+2048>>12,v1=dctSqrt2*p$3[32+col]+2048>>12,v2=p$3[16+col],v3=p$3[48+col],v4=dctSqrt1d2*(p$3[8+col]-p$3[56+col])+2048>>12,v7=dctSqrt1d2*(p$3[8+col]+p$3[56+col])+2048>>12,v5=p$3[24+col],v6=p$3[40+col],t$3=v0-v1+1>>1,v0=v0+v1+1>>1,v1=t$3,t$3=v2*dctSin6+v3*dctCos6+2048>>12,v2=v2*dctCos6-v3*dctSin6+2048>>12,v3=t$3,t$3=v4-v6+1>>1,v4=v4+v6+1>>1,v6=t$3,t$3=v7+v5+1>>1,v5=v7-v5+1>>1,v7=t$3,t$3=v0-v3+1>>1,v0=v0+v3+1>>1,v3=t$3,t$3=v1-v2+1>>1,v1=v1+v2+1>>1,v2=t$3,t$3=v4*dctSin3+v7*dctCos3+2048>>12,v4=v4*dctCos3-v7*dctSin3+2048>>12,v7=t$3,t$3=v5*dctSin1+v6*dctCos1+2048>>12,v5=v5*dctCos1-v6*dctSin1+2048>>12,v6=t$3,p$3[0+col]=v0+v7,p$3[56+col]=v0-v7,p$3[8+col]=v1+v6,p$3[48+col]=v1-v6,p$3[16+col]=v2+v5,p$3[40+col]=v2-v5,p$3[24+col]=v3+v4,p$3[32+col]=v3-v4}for(i$4=0;i$4<64;++i$4){var sample$1=128+(p$3[i$4]+8>>4);dataOut[i$4]=sample$1<0?0:sample$1>255?255:sample$1}}requestMemoryAllocation(samplesPerLine*blocksPerColumn*8);for(var i$3,j$2,blockRow=0;blockRow<blocksPerColumn;blockRow++){var scanLine=blockRow<<3;for(i$3=0;i$3<8;i$3++)lines.push(new Uint8Array(samplesPerLine));for(var blockCol=0;blockCol<blocksPerLine;blockCol++){quantizeAndInverse(component.blocks[blockRow][blockCol],r$3,R$1);var offset=0,sample=blockCol<<3;for(j$2=0;j$2<8;j$2++){var line$3=lines[scanLine+j$2];for(i$3=0;i$3<8;i$3++)line$3[sample+i$3]=r$3[offset++]}}}return lines}function clampTo8bit(a$3){return a$3<0?0:a$3>255?255:a$3}constructor.prototype={load:function(path){var xhr=new XMLHttpRequest;xhr.open(`GET`,path,!0),xhr.responseType=`arraybuffer`,xhr.onload=(function(){var data=new Uint8Array(xhr.response||xhr.mozResponseArrayBuffer);this.parse(data),this.onload&&this.onload()}).bind(this),xhr.send(null)},parse:function(data){var maxResolutionInPixels=this.opts.maxResolutionInMP*1e3*1e3,offset=0;data.length;function readUint16(){var value=data[offset]<<8|data[offset+1];return offset+=2,value}function readDataBlock(){var length=readUint16(),array=data.subarray(offset,offset+length-2);return offset+=array.length,array}function prepareComponents(frame$1){var maxH=1,maxV=1,component$1,componentId$1;for(componentId$1 in frame$1.components)frame$1.components.hasOwnProperty(componentId$1)&&(component$1=frame$1.components[componentId$1],maxH<component$1.h&&(maxH=component$1.h),maxV<component$1.v&&(maxV=component$1.v));var mcusPerLine=Math.ceil(frame$1.samplesPerLine/8/maxH),mcusPerColumn=Math.ceil(frame$1.scanLines/8/maxV);for(componentId$1 in frame$1.components)if(frame$1.components.hasOwnProperty(componentId$1)){component$1=frame$1.components[componentId$1];var blocksPerLine=Math.ceil(Math.ceil(frame$1.samplesPerLine/8)*component$1.h/maxH),blocksPerColumn=Math.ceil(Math.ceil(frame$1.scanLines/8)*component$1.v/maxV),blocksPerLineForMcu=mcusPerLine*component$1.h,blocksPerColumnForMcu=mcusPerColumn*component$1.v,blocksToAllocate=blocksPerColumnForMcu*blocksPerLineForMcu,blocks=[];requestMemoryAllocation(blocksToAllocate*256);for(var i$4=0;i$4<blocksPerColumnForMcu;i$4++){for(var row=[],j$3=0;j$3<blocksPerLineForMcu;j$3++)row.push(new Int32Array(64));blocks.push(row)}component$1.blocksPerLine=blocksPerLine,component$1.blocksPerColumn=blocksPerColumn,component$1.blocks=blocks}frame$1.maxH=maxH,frame$1.maxV=maxV,frame$1.mcusPerLine=mcusPerLine,frame$1.mcusPerColumn=mcusPerColumn}var jfif=null,adobe=null,frame,resetInterval,quantizationTables=[],frames=[],huffmanTablesAC=[],huffmanTablesDC=[],fileMarker=readUint16(),malformedDataOffset=-1;if(this.comments=[],fileMarker!=65496)throw Error(`SOI not found`);for(fileMarker=readUint16();fileMarker!=65497;){var i$3,j$2;switch(fileMarker){case 65280:break;case 65504:case 65505:case 65506:case 65507:case 65508:case 65509:case 65510:case 65511:case 65512:case 65513:case 65514:case 65515:case 65516:case 65517:case 65518:case 65519:case 65534:var appData=readDataBlock();if(fileMarker===65534){var comment=String.fromCharCode.apply(null,appData);this.comments.push(comment)}fileMarker===65504&&appData[0]===74&&appData[1]===70&&appData[2]===73&&appData[3]===70&&appData[4]===0&&(jfif={version:{major:appData[5],minor:appData[6]},densityUnits:appData[7],xDensity:appData[8]<<8|appData[9],yDensity:appData[10]<<8|appData[11],thumbWidth:appData[12],thumbHeight:appData[13],thumbData:appData.subarray(14,14+3*appData[12]*appData[13])}),fileMarker===65505&&appData[0]===69&&appData[1]===120&&appData[2]===105&&appData[3]===102&&appData[4]===0&&(this.exifBuffer=appData.subarray(5,appData.length)),fileMarker===65518&&appData[0]===65&&appData[1]===100&&appData[2]===111&&appData[3]===98&&appData[4]===101&&appData[5]===0&&(adobe={version:appData[6],flags0:appData[7]<<8|appData[8],flags1:appData[9]<<8|appData[10],transformCode:appData[11]});break;case 65499:for(var quantizationTablesEnd=readUint16()+offset-2;offset<quantizationTablesEnd;){var quantizationTableSpec=data[offset++];requestMemoryAllocation(256);var tableData=new Int32Array(64);if(quantizationTableSpec>>4)if(quantizationTableSpec>>4==1)for(j$2=0;j$2<64;j$2++){var z=dctZigZag[j$2];tableData[z]=readUint16()}else throw Error(`DQT: invalid table spec`);else for(j$2=0;j$2<64;j$2++){var z=dctZigZag[j$2];tableData[z]=data[offset++]}quantizationTables[quantizationTableSpec&15]=tableData}break;case 65472:case 65473:case 65474:readUint16(),frame={},frame.extended=fileMarker===65473,frame.progressive=fileMarker===65474,frame.precision=data[offset++],frame.scanLines=readUint16(),frame.samplesPerLine=readUint16(),frame.components={},frame.componentsOrder=[];var pixelsInFrame=frame.scanLines*frame.samplesPerLine;if(pixelsInFrame>maxResolutionInPixels){var exceededAmount=Math.ceil((pixelsInFrame-maxResolutionInPixels)/1e6);throw Error(`maxResolutionInMP limit exceeded by ${exceededAmount}MP`)}var componentsCount=data[offset++],componentId;for(i$3=0;i$3<componentsCount;i$3++){componentId=data[offset];var h$3=data[offset+1]>>4,v$2=data[offset+1]&15,qId=data[offset+2];if(h$3<=0||v$2<=0)throw Error(`Invalid sampling factor, expected values above 0`);frame.componentsOrder.push(componentId),frame.components[componentId]={h:h$3,v:v$2,quantizationIdx:qId},offset+=3}prepareComponents(frame),frames.push(frame);break;case 65476:var huffmanLength=readUint16();for(i$3=2;i$3<huffmanLength;){var huffmanTableSpec=data[offset++],codeLengths=new Uint8Array(16),codeLengthSum=0;for(j$2=0;j$2<16;j$2++,offset++)codeLengthSum+=codeLengths[j$2]=data[offset];requestMemoryAllocation(16+codeLengthSum);var huffmanValues=new Uint8Array(codeLengthSum);for(j$2=0;j$2<codeLengthSum;j$2++,offset++)huffmanValues[j$2]=data[offset];i$3+=17+codeLengthSum,(huffmanTableSpec>>4?huffmanTablesAC:huffmanTablesDC)[huffmanTableSpec&15]=buildHuffmanTable(codeLengths,huffmanValues)}break;case 65501:readUint16(),resetInterval=readUint16();break;case 65500:readUint16(),readUint16();break;case 65498:readUint16();var selectorsCount=data[offset++],components=[],component;for(i$3=0;i$3<selectorsCount;i$3++){component=frame.components[data[offset++]];var tableSpec=data[offset++];component.huffmanTableDC=huffmanTablesDC[tableSpec>>4],component.huffmanTableAC=huffmanTablesAC[tableSpec&15],components.push(component)}var spectralStart=data[offset++],spectralEnd=data[offset++],successiveApproximation=data[offset++],processed=decodeScan(data,offset,frame,components,resetInterval,spectralStart,spectralEnd,successiveApproximation>>4,successiveApproximation&15,this.opts);offset+=processed;break;case 65535:data[offset]!==255&&offset--;break;default:if(data[offset-3]==255&&data[offset-2]>=192&&data[offset-2]<=254){offset-=3;break}else if(fileMarker===224||fileMarker==225){if(malformedDataOffset!==-1)throw Error(`first unknown JPEG marker at offset ${malformedDataOffset.toString(16)}, second unknown JPEG marker ${fileMarker.toString(16)} at offset ${(offset-1).toString(16)}`);malformedDataOffset=offset-1;let nextOffset=readUint16();if(data[offset+nextOffset-2]===255){offset+=nextOffset-2;break}}throw Error(`unknown JPEG marker `+fileMarker.toString(16))}fileMarker=readUint16()}if(frames.length!=1)throw Error(`only single frame JPEGs supported`);for(var i$3=0;i$3<frames.length;i$3++){var cp=frames[i$3].components;for(var j$2 in cp)cp[j$2].quantizationTable=quantizationTables[cp[j$2].quantizationIdx],delete cp[j$2].quantizationIdx}this.width=frame.samplesPerLine,this.height=frame.scanLines,this.jfif=jfif,this.adobe=adobe,this.components=[];for(var i$3=0;i$3<frame.componentsOrder.length;i$3++){var component=frame.components[frame.componentsOrder[i$3]];this.components.push({lines:buildComponentData(frame,component),scaleX:component.h/frame.maxH,scaleY:component.v/frame.maxV})}},getData:function(width,height){var scaleX=this.width/width,scaleY=this.height/height,component1,component2,component3,component4,component1Line,component2Line,component3Line,component4Line,x$2,y$2,offset=0,Y,Cb,Cr,K$1,C,M$3,Ye,R$1,G,B$1,colorTransform,dataLength=width*height*this.components.length;requestMemoryAllocation(dataLength);var data=new Uint8Array(dataLength);switch(this.components.length){case 1:for(component1=this.components[0],y$2=0;y$2<height;y$2++)for(component1Line=component1.lines[0|y$2*component1.scaleY*scaleY],x$2=0;x$2<width;x$2++)Y=component1Line[0|x$2*component1.scaleX*scaleX],data[offset++]=Y;break;case 2:for(component1=this.components[0],component2=this.components[1],y$2=0;y$2<height;y$2++)for(component1Line=component1.lines[0|y$2*component1.scaleY*scaleY],component2Line=component2.lines[0|y$2*component2.scaleY*scaleY],x$2=0;x$2<width;x$2++)Y=component1Line[0|x$2*component1.scaleX*scaleX],data[offset++]=Y,Y=component2Line[0|x$2*component2.scaleX*scaleX],data[offset++]=Y;break;case 3:for(colorTransform=!0,this.adobe&&this.adobe.transformCode?colorTransform=!0:this.opts.colorTransform!==void 0&&(colorTransform=!!this.opts.colorTransform),component1=this.components[0],component2=this.components[1],component3=this.components[2],y$2=0;y$2<height;y$2++)for(component1Line=component1.lines[0|y$2*component1.scaleY*scaleY],component2Line=component2.lines[0|y$2*component2.scaleY*scaleY],component3Line=component3.lines[0|y$2*component3.scaleY*scaleY],x$2=0;x$2<width;x$2++)colorTransform?(Y=component1Line[0|x$2*component1.scaleX*scaleX],Cb=component2Line[0|x$2*component2.scaleX*scaleX],Cr=component3Line[0|x$2*component3.scaleX*scaleX],R$1=clampTo8bit(Y+1.402*(Cr-128)),G=clampTo8bit(Y-.3441363*(Cb-128)-.71413636*(Cr-128)),B$1=clampTo8bit(Y+1.772*(Cb-128))):(R$1=component1Line[0|x$2*component1.scaleX*scaleX],G=component2Line[0|x$2*component2.scaleX*scaleX],B$1=component3Line[0|x$2*component3.scaleX*scaleX]),data[offset++]=R$1,data[offset++]=G,data[offset++]=B$1;break;case 4:if(!this.adobe)throw Error(`Unsupported color mode (4 components)`);for(colorTransform=!1,this.adobe&&this.adobe.transformCode?colorTransform=!0:this.opts.colorTransform!==void 0&&(colorTransform=!!this.opts.colorTransform),component1=this.components[0],component2=this.components[1],component3=this.components[2],component4=this.components[3],y$2=0;y$2<height;y$2++)for(component1Line=component1.lines[0|y$2*component1.scaleY*scaleY],component2Line=component2.lines[0|y$2*component2.scaleY*scaleY],component3Line=component3.lines[0|y$2*component3.scaleY*scaleY],component4Line=component4.lines[0|y$2*component4.scaleY*scaleY],x$2=0;x$2<width;x$2++)colorTransform?(Y=component1Line[0|x$2*component1.scaleX*scaleX],Cb=component2Line[0|x$2*component2.scaleX*scaleX],Cr=component3Line[0|x$2*component3.scaleX*scaleX],K$1=component4Line[0|x$2*component4.scaleX*scaleX],C=255-clampTo8bit(Y+1.402*(Cr-128)),M$3=255-clampTo8bit(Y-.3441363*(Cb-128)-.71413636*(Cr-128)),Ye=255-clampTo8bit(Y+1.772*(Cb-128))):(C=component1Line[0|x$2*component1.scaleX*scaleX],M$3=component2Line[0|x$2*component2.scaleX*scaleX],Ye=component3Line[0|x$2*component3.scaleX*scaleX],K$1=component4Line[0|x$2*component4.scaleX*scaleX]),data[offset++]=255-C,data[offset++]=255-M$3,data[offset++]=255-Ye,data[offset++]=255-K$1;break;default:throw Error(`Unsupported color mode`)}return data},copyToImageData:function(imageData,formatAsRGBA){var width=imageData.width,height=imageData.height,imageDataArray=imageData.data,data=this.getData(width,height),i$3=0,j$2=0,x$2,y$2,Y,K$1,C,M$3,R$1,G,B$1;switch(this.components.length){case 1:for(y$2=0;y$2<height;y$2++)for(x$2=0;x$2<width;x$2++)Y=data[i$3++],imageDataArray[j$2++]=Y,imageDataArray[j$2++]=Y,imageDataArray[j$2++]=Y,formatAsRGBA&&(imageDataArray[j$2++]=255);break;case 3:for(y$2=0;y$2<height;y$2++)for(x$2=0;x$2<width;x$2++)R$1=data[i$3++],G=data[i$3++],B$1=data[i$3++],imageDataArray[j$2++]=R$1,imageDataArray[j$2++]=G,imageDataArray[j$2++]=B$1,formatAsRGBA&&(imageDataArray[j$2++]=255);break;case 4:for(y$2=0;y$2<height;y$2++)for(x$2=0;x$2<width;x$2++)C=data[i$3++],M$3=data[i$3++],Y=data[i$3++],K$1=data[i$3++],R$1=255-clampTo8bit(C*(1-K$1/255)+K$1),G=255-clampTo8bit(M$3*(1-K$1/255)+K$1),B$1=255-clampTo8bit(Y*(1-K$1/255)+K$1),imageDataArray[j$2++]=R$1,imageDataArray[j$2++]=G,imageDataArray[j$2++]=B$1,formatAsRGBA&&(imageDataArray[j$2++]=255);break;default:throw Error(`Unsupported color mode`)}}};var totalBytesAllocated=0,maxMemoryUsageBytes=0;function requestMemoryAllocation(increaseAmount=0){var totalMemoryImpactBytes=totalBytesAllocated+increaseAmount;if(totalMemoryImpactBytes>maxMemoryUsageBytes){var exceededAmount=Math.ceil((totalMemoryImpactBytes-maxMemoryUsageBytes)/1024/1024);throw Error(`maxMemoryUsageInMB limit exceeded by at least ${exceededAmount}MB`)}totalBytesAllocated=totalMemoryImpactBytes}return constructor.resetMaxMemoryUsage=function(maxMemoryUsageBytes_){totalBytesAllocated=0,maxMemoryUsageBytes=maxMemoryUsageBytes_},constructor.getBytesAllocated=function(){return totalBytesAllocated},constructor.requestMemoryAllocation=requestMemoryAllocation,constructor})();module===void 0?typeof window<`u`&&(window[`jpeg-js`]=window[`jpeg-js`]||{},window[`jpeg-js`].decode=decode$2):module.exports=decode$2;function decode$2(jpegData,userOpts={}){var opts={colorTransform:void 0,useTArray:!1,formatAsRGBA:!0,tolerantDecoding:!0,maxResolutionInMP:100,maxMemoryUsageInMB:512,...userOpts},arr=new Uint8Array(jpegData),decoder=new JpegImage;decoder.opts=opts,JpegImage.resetMaxMemoryUsage(opts.maxMemoryUsageInMB*1024*1024),decoder.parse(arr);var channels=opts.formatAsRGBA?4:3,bytesNeeded=decoder.width*decoder.height*channels;try{JpegImage.requestMemoryAllocation(bytesNeeded);var image={width:decoder.width,height:decoder.height,exifBuffer:decoder.exifBuffer,data:opts.useTArray?new Uint8Array(bytesNeeded):Buffer.alloc(bytesNeeded)};decoder.comments.length>0&&(image.comments=decoder.comments)}catch(err$1){throw err$1 instanceof RangeError?Error(`Could not allocate enough memory for the image. Required: `+bytesNeeded):err$1 instanceof ReferenceError&&err$1.message===`Buffer is not defined`?Error(`Buffer is not globally defined in this environment. Consider setting useTArray to true`):err$1}return decoder.copyToImageData(image,opts.formatAsRGBA),image}})),require_jpeg_js=__commonJSMin(((exports,module)=>{var encode$1=require_encoder(),decode$1=require_decoder();module.exports={encode:encode$1,decode:decode$1}})),import_jpeg_js$1=__toESM(require_jpeg_js()),Z_FIXED$1=4,Z_BINARY=0,Z_TEXT=1,Z_UNKNOWN$1=2;function zero$1(buf){let len=buf.length;for(;--len>=0;)buf[len]=0}var STORED_BLOCK=0,STATIC_TREES=1,DYN_TREES=2,MIN_MATCH$1=3,MAX_MATCH$1=258,LENGTH_CODES$1=29,LITERALS$1=256,L_CODES$1=LITERALS$1+1+LENGTH_CODES$1,D_CODES$1=30,BL_CODES$1=19,HEAP_SIZE$1=2*L_CODES$1+1,MAX_BITS$1=15,Buf_size=16,MAX_BL_BITS=7,END_BLOCK=256,REP_3_6=16,REPZ_3_10=17,REPZ_11_138=18,extra_lbits=new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]),extra_dbits=new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]),extra_blbits=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]),bl_order=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),DIST_CODE_LEN=512,static_ltree=Array((L_CODES$1+2)*2);zero$1(static_ltree);var static_dtree=Array(D_CODES$1*2);zero$1(static_dtree);var _dist_code=Array(DIST_CODE_LEN);zero$1(_dist_code);var _length_code=Array(MAX_MATCH$1-MIN_MATCH$1+1);zero$1(_length_code);var base_length=Array(LENGTH_CODES$1);zero$1(base_length);var base_dist=Array(D_CODES$1);zero$1(base_dist);function StaticTreeDesc(static_tree,extra_bits,extra_base,elems,max_length){this.static_tree=static_tree,this.extra_bits=extra_bits,this.extra_base=extra_base,this.elems=elems,this.max_length=max_length,this.has_stree=static_tree&&static_tree.length}var static_l_desc,static_d_desc,static_bl_desc;function TreeDesc(dyn_tree,stat_desc){this.dyn_tree=dyn_tree,this.max_code=0,this.stat_desc=stat_desc}var d_code=dist=>dist<256?_dist_code[dist]:_dist_code[256+(dist>>>7)],put_short=(s$2,w$3)=>{s$2.pending_buf[s$2.pending++]=w$3&255,s$2.pending_buf[s$2.pending++]=w$3>>>8&255},send_bits=(s$2,value,length)=>{s$2.bi_valid>Buf_size-length?(s$2.bi_buf|=value<<s$2.bi_valid&65535,put_short(s$2,s$2.bi_buf),s$2.bi_buf=value>>Buf_size-s$2.bi_valid,s$2.bi_valid+=length-Buf_size):(s$2.bi_buf|=value<<s$2.bi_valid&65535,s$2.bi_valid+=length)},send_code=(s$2,c$2,tree)=>{send_bits(s$2,tree[c$2*2],tree[c$2*2+1])},bi_reverse=(code,len)=>{let res=0;do res|=code&1,code>>>=1,res<<=1;while(--len>0);return res>>>1},bi_flush=s$2=>{s$2.bi_valid===16?(put_short(s$2,s$2.bi_buf),s$2.bi_buf=0,s$2.bi_valid=0):s$2.bi_valid>=8&&(s$2.pending_buf[s$2.pending++]=s$2.bi_buf&255,s$2.bi_buf>>=8,s$2.bi_valid-=8)},gen_bitlen=(s$2,desc)=>{let tree=desc.dyn_tree,max_code=desc.max_code,stree=desc.stat_desc.static_tree,has_stree=desc.stat_desc.has_stree,extra=desc.stat_desc.extra_bits,base=desc.stat_desc.extra_base,max_length=desc.stat_desc.max_length,h$3,n$3,m$1,bits,xbits,f$1,overflow=0;for(bits=0;bits<=MAX_BITS$1;bits++)s$2.bl_count[bits]=0;for(tree[s$2.heap[s$2.heap_max]*2+1]=0,h$3=s$2.heap_max+1;h$3<HEAP_SIZE$1;h$3++)n$3=s$2.heap[h$3],bits=tree[tree[n$3*2+1]*2+1]+1,bits>max_length&&(bits=max_length,overflow++),tree[n$3*2+1]=bits,!(n$3>max_code)&&(s$2.bl_count[bits]++,xbits=0,n$3>=base&&(xbits=extra[n$3-base]),f$1=tree[n$3*2],s$2.opt_len+=f$1*(bits+xbits),has_stree&&(s$2.static_len+=f$1*(stree[n$3*2+1]+xbits)));if(overflow!==0){do{for(bits=max_length-1;s$2.bl_count[bits]===0;)bits--;s$2.bl_count[bits]--,s$2.bl_count[bits+1]+=2,s$2.bl_count[max_length]--,overflow-=2}while(overflow>0);for(bits=max_length;bits!==0;bits--)for(n$3=s$2.bl_count[bits];n$3!==0;)m$1=s$2.heap[--h$3],!(m$1>max_code)&&(tree[m$1*2+1]!==bits&&(s$2.opt_len+=(bits-tree[m$1*2+1])*tree[m$1*2],tree[m$1*2+1]=bits),n$3--)}},gen_codes=(tree,max_code,bl_count)=>{let next_code=Array(MAX_BITS$1+1),code=0,bits,n$3;for(bits=1;bits<=MAX_BITS$1;bits++)code=code+bl_count[bits-1]<<1,next_code[bits]=code;for(n$3=0;n$3<=max_code;n$3++){let len=tree[n$3*2+1];len!==0&&(tree[n$3*2]=bi_reverse(next_code[len]++,len))}},tr_static_init=()=>{let n$3,bits,length,code,dist,bl_count=Array(MAX_BITS$1+1);for(length=0,code=0;code<LENGTH_CODES$1-1;code++)for(base_length[code]=length,n$3=0;n$3<1<<extra_lbits[code];n$3++)_length_code[length++]=code;for(_length_code[length-1]=code,dist=0,code=0;code<16;code++)for(base_dist[code]=dist,n$3=0;n$3<1<<extra_dbits[code];n$3++)_dist_code[dist++]=code;for(dist>>=7;code<D_CODES$1;code++)for(base_dist[code]=dist<<7,n$3=0;n$3<1<<extra_dbits[code]-7;n$3++)_dist_code[256+ dist++]=code;for(bits=0;bits<=MAX_BITS$1;bits++)bl_count[bits]=0;for(n$3=0;n$3<=143;)static_ltree[n$3*2+1]=8,n$3++,bl_count[8]++;for(;n$3<=255;)static_ltree[n$3*2+1]=9,n$3++,bl_count[9]++;for(;n$3<=279;)static_ltree[n$3*2+1]=7,n$3++,bl_count[7]++;for(;n$3<=287;)static_ltree[n$3*2+1]=8,n$3++,bl_count[8]++;for(gen_codes(static_ltree,L_CODES$1+1,bl_count),n$3=0;n$3<D_CODES$1;n$3++)static_dtree[n$3*2+1]=5,static_dtree[n$3*2]=bi_reverse(n$3,5);static_l_desc=new StaticTreeDesc(static_ltree,extra_lbits,LITERALS$1+1,L_CODES$1,MAX_BITS$1),static_d_desc=new StaticTreeDesc(static_dtree,extra_dbits,0,D_CODES$1,MAX_BITS$1),static_bl_desc=new StaticTreeDesc([],extra_blbits,0,BL_CODES$1,MAX_BL_BITS)},init_block=s$2=>{let n$3;for(n$3=0;n$3<L_CODES$1;n$3++)s$2.dyn_ltree[n$3*2]=0;for(n$3=0;n$3<D_CODES$1;n$3++)s$2.dyn_dtree[n$3*2]=0;for(n$3=0;n$3<BL_CODES$1;n$3++)s$2.bl_tree[n$3*2]=0;s$2.dyn_ltree[END_BLOCK*2]=1,s$2.opt_len=s$2.static_len=0,s$2.sym_next=s$2.matches=0},bi_windup=s$2=>{s$2.bi_valid>8?put_short(s$2,s$2.bi_buf):s$2.bi_valid>0&&(s$2.pending_buf[s$2.pending++]=s$2.bi_buf),s$2.bi_buf=0,s$2.bi_valid=0},smaller=(tree,n$3,m$1,depth)=>{let _n2=n$3*2,_m2=m$1*2;return tree[_n2]<tree[_m2]||tree[_n2]===tree[_m2]&&depth[n$3]<=depth[m$1]},pqdownheap=(s$2,tree,k$2)=>{let v$2=s$2.heap[k$2],j$2=k$2<<1;for(;j$2<=s$2.heap_len&&(j$2<s$2.heap_len&&smaller(tree,s$2.heap[j$2+1],s$2.heap[j$2],s$2.depth)&&j$2++,!smaller(tree,v$2,s$2.heap[j$2],s$2.depth));)s$2.heap[k$2]=s$2.heap[j$2],k$2=j$2,j$2<<=1;s$2.heap[k$2]=v$2},compress_block=(s$2,ltree,dtree)=>{let dist,lc,sx=0,code,extra;if(s$2.sym_next!==0)do dist=s$2.pending_buf[s$2.sym_buf+ sx++]&255,dist+=(s$2.pending_buf[s$2.sym_buf+ sx++]&255)<<8,lc=s$2.pending_buf[s$2.sym_buf+ sx++],dist===0?send_code(s$2,lc,ltree):(code=_length_code[lc],send_code(s$2,code+LITERALS$1+1,ltree),extra=extra_lbits[code],extra!==0&&(lc-=base_length[code],send_bits(s$2,lc,extra)),dist--,code=d_code(dist),send_code(s$2,code,dtree),extra=extra_dbits[code],extra!==0&&(dist-=base_dist[code],send_bits(s$2,dist,extra)));while(sx<s$2.sym_next);send_code(s$2,END_BLOCK,ltree)},build_tree=(s$2,desc)=>{let tree=desc.dyn_tree,stree=desc.stat_desc.static_tree,has_stree=desc.stat_desc.has_stree,elems=desc.stat_desc.elems,n$3,m$1,max_code=-1,node;for(s$2.heap_len=0,s$2.heap_max=HEAP_SIZE$1,n$3=0;n$3<elems;n$3++)tree[n$3*2]===0?tree[n$3*2+1]=0:(s$2.heap[++s$2.heap_len]=max_code=n$3,s$2.depth[n$3]=0);for(;s$2.heap_len<2;)node=s$2.heap[++s$2.heap_len]=max_code<2?++max_code:0,tree[node*2]=1,s$2.depth[node]=0,s$2.opt_len--,has_stree&&(s$2.static_len-=stree[node*2+1]);for(desc.max_code=max_code,n$3=s$2.heap_len>>1;n$3>=1;n$3--)pqdownheap(s$2,tree,n$3);node=elems;do n$3=s$2.heap[1],s$2.heap[1]=s$2.heap[s$2.heap_len--],pqdownheap(s$2,tree,1),m$1=s$2.heap[1],s$2.heap[--s$2.heap_max]=n$3,s$2.heap[--s$2.heap_max]=m$1,tree[node*2]=tree[n$3*2]+tree[m$1*2],s$2.depth[node]=(s$2.depth[n$3]>=s$2.depth[m$1]?s$2.depth[n$3]:s$2.depth[m$1])+1,tree[n$3*2+1]=tree[m$1*2+1]=node,s$2.heap[1]=node++,pqdownheap(s$2,tree,1);while(s$2.heap_len>=2);s$2.heap[--s$2.heap_max]=s$2.heap[1],gen_bitlen(s$2,desc),gen_codes(tree,max_code,s$2.bl_count)},scan_tree=(s$2,tree,max_code)=>{let n$3,prevlen=-1,curlen,nextlen=tree[1],count=0,max_count=7,min_count=4;for(nextlen===0&&(max_count=138,min_count=3),tree[(max_code+1)*2+1]=65535,n$3=0;n$3<=max_code;n$3++)curlen=nextlen,nextlen=tree[(n$3+1)*2+1],!(++count<max_count&&curlen===nextlen)&&(count<min_count?s$2.bl_tree[curlen*2]+=count:curlen===0?count<=10?s$2.bl_tree[REPZ_3_10*2]++:s$2.bl_tree[REPZ_11_138*2]++:(curlen!==prevlen&&s$2.bl_tree[curlen*2]++,s$2.bl_tree[REP_3_6*2]++),count=0,prevlen=curlen,nextlen===0?(max_count=138,min_count=3):curlen===nextlen?(max_count=6,min_count=3):(max_count=7,min_count=4))},send_tree=(s$2,tree,max_code)=>{let n$3,prevlen=-1,curlen,nextlen=tree[1],count=0,max_count=7,min_count=4;for(nextlen===0&&(max_count=138,min_count=3),n$3=0;n$3<=max_code;n$3++)if(curlen=nextlen,nextlen=tree[(n$3+1)*2+1],!(++count<max_count&&curlen===nextlen)){if(count<min_count)do send_code(s$2,curlen,s$2.bl_tree);while(--count!==0);else curlen===0?count<=10?(send_code(s$2,REPZ_3_10,s$2.bl_tree),send_bits(s$2,count-3,3)):(send_code(s$2,REPZ_11_138,s$2.bl_tree),send_bits(s$2,count-11,7)):(curlen!==prevlen&&(send_code(s$2,curlen,s$2.bl_tree),count--),send_code(s$2,REP_3_6,s$2.bl_tree),send_bits(s$2,count-3,2));count=0,prevlen=curlen,nextlen===0?(max_count=138,min_count=3):curlen===nextlen?(max_count=6,min_count=3):(max_count=7,min_count=4)}},build_bl_tree=s$2=>{let max_blindex;for(scan_tree(s$2,s$2.dyn_ltree,s$2.l_desc.max_code),scan_tree(s$2,s$2.dyn_dtree,s$2.d_desc.max_code),build_tree(s$2,s$2.bl_desc),max_blindex=BL_CODES$1-1;max_blindex>=3&&s$2.bl_tree[bl_order[max_blindex]*2+1]===0;max_blindex--);return s$2.opt_len+=3*(max_blindex+1)+5+5+4,max_blindex},send_all_trees=(s$2,lcodes,dcodes,blcodes)=>{let rank$1;for(send_bits(s$2,lcodes-257,5),send_bits(s$2,dcodes-1,5),send_bits(s$2,blcodes-4,4),rank$1=0;rank$1<blcodes;rank$1++)send_bits(s$2,s$2.bl_tree[bl_order[rank$1]*2+1],3);send_tree(s$2,s$2.dyn_ltree,lcodes-1),send_tree(s$2,s$2.dyn_dtree,dcodes-1)},detect_data_type=s$2=>{let block_mask=4093624447,n$3;for(n$3=0;n$3<=31;n$3++,block_mask>>>=1)if(block_mask&1&&s$2.dyn_ltree[n$3*2]!==0)return Z_BINARY;if(s$2.dyn_ltree[18]!==0||s$2.dyn_ltree[20]!==0||s$2.dyn_ltree[26]!==0)return Z_TEXT;for(n$3=32;n$3<LITERALS$1;n$3++)if(s$2.dyn_ltree[n$3*2]!==0)return Z_TEXT;return Z_BINARY},static_init_done=!1,_tr_init$1=s$2=>{static_init_done||=(tr_static_init(),!0),s$2.l_desc=new TreeDesc(s$2.dyn_ltree,static_l_desc),s$2.d_desc=new TreeDesc(s$2.dyn_dtree,static_d_desc),s$2.bl_desc=new TreeDesc(s$2.bl_tree,static_bl_desc),s$2.bi_buf=0,s$2.bi_valid=0,init_block(s$2)},_tr_stored_block$1=(s$2,buf,stored_len,last)=>{send_bits(s$2,(STORED_BLOCK<<1)+(last?1:0),3),bi_windup(s$2),put_short(s$2,stored_len),put_short(s$2,~stored_len),stored_len&&s$2.pending_buf.set(s$2.window.subarray(buf,buf+stored_len),s$2.pending),s$2.pending+=stored_len},trees={_tr_init:_tr_init$1,_tr_stored_block:_tr_stored_block$1,_tr_flush_block:(s$2,buf,stored_len,last)=>{let opt_lenb,static_lenb,max_blindex=0;s$2.level>0?(s$2.strm.data_type===Z_UNKNOWN$1&&(s$2.strm.data_type=detect_data_type(s$2)),build_tree(s$2,s$2.l_desc),build_tree(s$2,s$2.d_desc),max_blindex=build_bl_tree(s$2),opt_lenb=s$2.opt_len+3+7>>>3,static_lenb=s$2.static_len+3+7>>>3,static_lenb<=opt_lenb&&(opt_lenb=static_lenb)):opt_lenb=static_lenb=stored_len+5,stored_len+4<=opt_lenb&&buf!==-1?_tr_stored_block$1(s$2,buf,stored_len,last):s$2.strategy===Z_FIXED$1||static_lenb===opt_lenb?(send_bits(s$2,(STATIC_TREES<<1)+(last?1:0),3),compress_block(s$2,static_ltree,static_dtree)):(send_bits(s$2,(DYN_TREES<<1)+(last?1:0),3),send_all_trees(s$2,s$2.l_desc.max_code+1,s$2.d_desc.max_code+1,max_blindex+1),compress_block(s$2,s$2.dyn_ltree,s$2.dyn_dtree)),init_block(s$2),last&&bi_windup(s$2)},_tr_tally:(s$2,dist,lc)=>(s$2.pending_buf[s$2.sym_buf+ s$2.sym_next++]=dist,s$2.pending_buf[s$2.sym_buf+ s$2.sym_next++]=dist>>8,s$2.pending_buf[s$2.sym_buf+ s$2.sym_next++]=lc,dist===0?s$2.dyn_ltree[lc*2]++:(s$2.matches++,dist--,s$2.dyn_ltree[(_length_code[lc]+LITERALS$1+1)*2]++,s$2.dyn_dtree[d_code(dist)*2]++),s$2.sym_next===s$2.sym_end),_tr_align:s$2=>{send_bits(s$2,STATIC_TREES<<1,3),send_code(s$2,END_BLOCK,static_ltree),bi_flush(s$2)}},adler32_1=(adler,buf,len,pos)=>{let s1=adler&65535|0,s2=adler>>>16&65535|0,n$3=0;for(;len!==0;){n$3=len>2e3?2e3:len,len-=n$3;do s1=s1+buf[pos++]|0,s2=s2+s1|0;while(--n$3);s1%=65521,s2%=65521}return s1|s2<<16|0},crcTable$1=new Uint32Array((()=>{let c$2,table=[];for(var n$3=0;n$3<256;n$3++){c$2=n$3;for(var k$2=0;k$2<8;k$2++)c$2=c$2&1?3988292384^c$2>>>1:c$2>>>1;table[n$3]=c$2}return table})()),crc32_1=(crc,buf,len,pos)=>{let t$3=crcTable$1,end=pos+len;crc^=-1;for(let i$3=pos;i$3<end;i$3++)crc=crc>>>8^t$3[(crc^buf[i$3])&255];return crc^-1},messages={2:`need dictionary`,1:`stream end`,0:``,"-1":`file error`,"-2":`stream error`,"-3":`data error`,"-4":`insufficient memory`,"-5":`buffer error`,"-6":`incompatible version`},constants$2={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_MEM_ERROR:-4,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8},{_tr_init,_tr_stored_block,_tr_flush_block,_tr_tally,_tr_align}=trees,{Z_NO_FLUSH:Z_NO_FLUSH$2,Z_PARTIAL_FLUSH,Z_FULL_FLUSH:Z_FULL_FLUSH$1,Z_FINISH:Z_FINISH$3,Z_BLOCK:Z_BLOCK$1,Z_OK:Z_OK$3,Z_STREAM_END:Z_STREAM_END$3,Z_STREAM_ERROR:Z_STREAM_ERROR$2,Z_DATA_ERROR:Z_DATA_ERROR$2,Z_BUF_ERROR:Z_BUF_ERROR$1,Z_DEFAULT_COMPRESSION:Z_DEFAULT_COMPRESSION$1,Z_FILTERED,Z_HUFFMAN_ONLY,Z_RLE,Z_FIXED,Z_DEFAULT_STRATEGY:Z_DEFAULT_STRATEGY$1,Z_UNKNOWN,Z_DEFLATED:Z_DEFLATED$2}=constants$2,MAX_MEM_LEVEL=9,MAX_WBITS$1=15,DEF_MEM_LEVEL=8,L_CODES=286,D_CODES=30,BL_CODES=19,HEAP_SIZE=2*L_CODES+1,MAX_BITS=15,MIN_MATCH=3,MAX_MATCH=258,MIN_LOOKAHEAD=MAX_MATCH+MIN_MATCH+1,PRESET_DICT=32,INIT_STATE=42,GZIP_STATE=57,EXTRA_STATE=69,NAME_STATE=73,COMMENT_STATE=91,HCRC_STATE=103,BUSY_STATE=113,FINISH_STATE=666,BS_NEED_MORE=1,BS_BLOCK_DONE=2,BS_FINISH_STARTED=3,BS_FINISH_DONE=4,OS_CODE=3,err=(strm,errorCode)=>(strm.msg=messages[errorCode],errorCode),rank=f$1=>f$1*2-(f$1>4?9:0),zero=buf=>{let len=buf.length;for(;--len>=0;)buf[len]=0},slide_hash=s$2=>{let n$3,m$1,p$3,wsize=s$2.w_size;n$3=s$2.hash_size,p$3=n$3;do m$1=s$2.head[--p$3],s$2.head[p$3]=m$1>=wsize?m$1-wsize:0;while(--n$3);n$3=wsize,p$3=n$3;do m$1=s$2.prev[--p$3],s$2.prev[p$3]=m$1>=wsize?m$1-wsize:0;while(--n$3)},HASH=(s$2,prev,data)=>(prev<<s$2.hash_shift^data)&s$2.hash_mask,flush_pending=strm=>{let s$2=strm.state,len=s$2.pending;len>strm.avail_out&&(len=strm.avail_out),len!==0&&(strm.output.set(s$2.pending_buf.subarray(s$2.pending_out,s$2.pending_out+len),strm.next_out),strm.next_out+=len,s$2.pending_out+=len,strm.total_out+=len,strm.avail_out-=len,s$2.pending-=len,s$2.pending===0&&(s$2.pending_out=0))},flush_block_only=(s$2,last)=>{_tr_flush_block(s$2,s$2.block_start>=0?s$2.block_start:-1,s$2.strstart-s$2.block_start,last),s$2.block_start=s$2.strstart,flush_pending(s$2.strm)},put_byte=(s$2,b$3)=>{s$2.pending_buf[s$2.pending++]=b$3},putShortMSB=(s$2,b$3)=>{s$2.pending_buf[s$2.pending++]=b$3>>>8&255,s$2.pending_buf[s$2.pending++]=b$3&255},read_buf=(strm,buf,start,size)=>{let len=strm.avail_in;return len>size&&(len=size),len===0?0:(strm.avail_in-=len,buf.set(strm.input.subarray(strm.next_in,strm.next_in+len),start),strm.state.wrap===1?strm.adler=adler32_1(strm.adler,buf,len,start):strm.state.wrap===2&&(strm.adler=crc32_1(strm.adler,buf,len,start)),strm.next_in+=len,strm.total_in+=len,len)},longest_match=(s$2,cur_match)=>{let chain_length=s$2.max_chain_length,scan=s$2.strstart,match,len,best_len=s$2.prev_length,nice_match=s$2.nice_match,limit=s$2.strstart>s$2.w_size-MIN_LOOKAHEAD?s$2.strstart-(s$2.w_size-MIN_LOOKAHEAD):0,_win=s$2.window,wmask=s$2.w_mask,prev=s$2.prev,strend=s$2.strstart+MAX_MATCH,scan_end1=_win[scan+best_len-1],scan_end=_win[scan+best_len];s$2.prev_length>=s$2.good_match&&(chain_length>>=2),nice_match>s$2.lookahead&&(nice_match=s$2.lookahead);do{if(match=cur_match,_win[match+best_len]!==scan_end||_win[match+best_len-1]!==scan_end1||_win[match]!==_win[scan]||_win[++match]!==_win[scan+1])continue;scan+=2,match++;do;while(_win[++scan]===_win[++match]&&_win[++scan]===_win[++match]&&_win[++scan]===_win[++match]&&_win[++scan]===_win[++match]&&_win[++scan]===_win[++match]&&_win[++scan]===_win[++match]&&_win[++scan]===_win[++match]&&_win[++scan]===_win[++match]&&scan<strend);if(len=MAX_MATCH-(strend-scan),scan=strend-MAX_MATCH,len>best_len){if(s$2.match_start=cur_match,best_len=len,len>=nice_match)break;scan_end1=_win[scan+best_len-1],scan_end=_win[scan+best_len]}}while((cur_match=prev[cur_match&wmask])>limit&&--chain_length!==0);return best_len<=s$2.lookahead?best_len:s$2.lookahead},fill_window=s$2=>{let _w_size=s$2.w_size,n$3,more,str;do{if(more=s$2.window_size-s$2.lookahead-s$2.strstart,s$2.strstart>=_w_size+(_w_size-MIN_LOOKAHEAD)&&(s$2.window.set(s$2.window.subarray(_w_size,_w_size+_w_size-more),0),s$2.match_start-=_w_size,s$2.strstart-=_w_size,s$2.block_start-=_w_size,s$2.insert>s$2.strstart&&(s$2.insert=s$2.strstart),slide_hash(s$2),more+=_w_size),s$2.strm.avail_in===0)break;if(n$3=read_buf(s$2.strm,s$2.window,s$2.strstart+s$2.lookahead,more),s$2.lookahead+=n$3,s$2.lookahead+s$2.insert>=MIN_MATCH)for(str=s$2.strstart-s$2.insert,s$2.ins_h=s$2.window[str],s$2.ins_h=HASH(s$2,s$2.ins_h,s$2.window[str+1]);s$2.insert&&(s$2.ins_h=HASH(s$2,s$2.ins_h,s$2.window[str+MIN_MATCH-1]),s$2.prev[str&s$2.w_mask]=s$2.head[s$2.ins_h],s$2.head[s$2.ins_h]=str,str++,s$2.insert--,!(s$2.lookahead+s$2.insert<MIN_MATCH)););}while(s$2.lookahead<MIN_LOOKAHEAD&&s$2.strm.avail_in!==0)},deflate_stored=(s$2,flush)=>{let min_block=s$2.pending_buf_size-5>s$2.w_size?s$2.w_size:s$2.pending_buf_size-5,len,left,have,last=0,used=s$2.strm.avail_in;do{if(len=65535,have=s$2.bi_valid+42>>3,s$2.strm.avail_out<have||(have=s$2.strm.avail_out-have,left=s$2.strstart-s$2.block_start,len>left+s$2.strm.avail_in&&(len=left+s$2.strm.avail_in),len>have&&(len=have),len<min_block&&(len===0&&flush!==Z_FINISH$3||flush===Z_NO_FLUSH$2||len!==left+s$2.strm.avail_in)))break;last=flush===Z_FINISH$3&&len===left+s$2.strm.avail_in?1:0,_tr_stored_block(s$2,0,0,last),s$2.pending_buf[s$2.pending-4]=len,s$2.pending_buf[s$2.pending-3]=len>>8,s$2.pending_buf[s$2.pending-2]=~len,s$2.pending_buf[s$2.pending-1]=~len>>8,flush_pending(s$2.strm),left&&(left>len&&(left=len),s$2.strm.output.set(s$2.window.subarray(s$2.block_start,s$2.block_start+left),s$2.strm.next_out),s$2.strm.next_out+=left,s$2.strm.avail_out-=left,s$2.strm.total_out+=left,s$2.block_start+=left,len-=left),len&&(read_buf(s$2.strm,s$2.strm.output,s$2.strm.next_out,len),s$2.strm.next_out+=len,s$2.strm.avail_out-=len,s$2.strm.total_out+=len)}while(last===0);return used-=s$2.strm.avail_in,used&&(used>=s$2.w_size?(s$2.matches=2,s$2.window.set(s$2.strm.input.subarray(s$2.strm.next_in-s$2.w_size,s$2.strm.next_in),0),s$2.strstart=s$2.w_size,s$2.insert=s$2.strstart):(s$2.window_size-s$2.strstart<=used&&(s$2.strstart-=s$2.w_size,s$2.window.set(s$2.window.subarray(s$2.w_size,s$2.w_size+s$2.strstart),0),s$2.matches<2&&s$2.matches++,s$2.insert>s$2.strstart&&(s$2.insert=s$2.strstart)),s$2.window.set(s$2.strm.input.subarray(s$2.strm.next_in-used,s$2.strm.next_in),s$2.strstart),s$2.strstart+=used,s$2.insert+=used>s$2.w_size-s$2.insert?s$2.w_size-s$2.insert:used),s$2.block_start=s$2.strstart),s$2.high_water<s$2.strstart&&(s$2.high_water=s$2.strstart),last?BS_FINISH_DONE:flush!==Z_NO_FLUSH$2&&flush!==Z_FINISH$3&&s$2.strm.avail_in===0&&s$2.strstart===s$2.block_start?BS_BLOCK_DONE:(have=s$2.window_size-s$2.strstart,s$2.strm.avail_in>have&&s$2.block_start>=s$2.w_size&&(s$2.block_start-=s$2.w_size,s$2.strstart-=s$2.w_size,s$2.window.set(s$2.window.subarray(s$2.w_size,s$2.w_size+s$2.strstart),0),s$2.matches<2&&s$2.matches++,have+=s$2.w_size,s$2.insert>s$2.strstart&&(s$2.insert=s$2.strstart)),have>s$2.strm.avail_in&&(have=s$2.strm.avail_in),have&&(read_buf(s$2.strm,s$2.window,s$2.strstart,have),s$2.strstart+=have,s$2.insert+=have>s$2.w_size-s$2.insert?s$2.w_size-s$2.insert:have),s$2.high_water<s$2.strstart&&(s$2.high_water=s$2.strstart),have=s$2.bi_valid+42>>3,have=s$2.pending_buf_size-have>65535?65535:s$2.pending_buf_size-have,min_block=have>s$2.w_size?s$2.w_size:have,left=s$2.strstart-s$2.block_start,(left>=min_block||(left||flush===Z_FINISH$3)&&flush!==Z_NO_FLUSH$2&&s$2.strm.avail_in===0&&left<=have)&&(len=left>have?have:left,last=flush===Z_FINISH$3&&s$2.strm.avail_in===0&&len===left?1:0,_tr_stored_block(s$2,s$2.block_start,len,last),s$2.block_start+=len,flush_pending(s$2.strm)),last?BS_FINISH_STARTED:BS_NEED_MORE)},deflate_fast=(s$2,flush)=>{let hash_head,bflush;for(;;){if(s$2.lookahead<MIN_LOOKAHEAD){if(fill_window(s$2),s$2.lookahead<MIN_LOOKAHEAD&&flush===Z_NO_FLUSH$2)return BS_NEED_MORE;if(s$2.lookahead===0)break}if(hash_head=0,s$2.lookahead>=MIN_MATCH&&(s$2.ins_h=HASH(s$2,s$2.ins_h,s$2.window[s$2.strstart+MIN_MATCH-1]),hash_head=s$2.prev[s$2.strstart&s$2.w_mask]=s$2.head[s$2.ins_h],s$2.head[s$2.ins_h]=s$2.strstart),hash_head!==0&&s$2.strstart-hash_head<=s$2.w_size-MIN_LOOKAHEAD&&(s$2.match_length=longest_match(s$2,hash_head)),s$2.match_length>=MIN_MATCH)if(bflush=_tr_tally(s$2,s$2.strstart-s$2.match_start,s$2.match_length-MIN_MATCH),s$2.lookahead-=s$2.match_length,s$2.match_length<=s$2.max_lazy_match&&s$2.lookahead>=MIN_MATCH){s$2.match_length--;do s$2.strstart++,s$2.ins_h=HASH(s$2,s$2.ins_h,s$2.window[s$2.strstart+MIN_MATCH-1]),hash_head=s$2.prev[s$2.strstart&s$2.w_mask]=s$2.head[s$2.ins_h],s$2.head[s$2.ins_h]=s$2.strstart;while(--s$2.match_length!==0);s$2.strstart++}else s$2.strstart+=s$2.match_length,s$2.match_length=0,s$2.ins_h=s$2.window[s$2.strstart],s$2.ins_h=HASH(s$2,s$2.ins_h,s$2.window[s$2.strstart+1]);else bflush=_tr_tally(s$2,0,s$2.window[s$2.strstart]),s$2.lookahead--,s$2.strstart++;if(bflush&&(flush_block_only(s$2,!1),s$2.strm.avail_out===0))return BS_NEED_MORE}return s$2.insert=s$2.strstart<MIN_MATCH-1?s$2.strstart:MIN_MATCH-1,flush===Z_FINISH$3?(flush_block_only(s$2,!0),s$2.strm.avail_out===0?BS_FINISH_STARTED:BS_FINISH_DONE):s$2.sym_next&&(flush_block_only(s$2,!1),s$2.strm.avail_out===0)?BS_NEED_MORE:BS_BLOCK_DONE},deflate_slow=(s$2,flush)=>{let hash_head,bflush,max_insert;for(;;){if(s$2.lookahead<MIN_LOOKAHEAD){if(fill_window(s$2),s$2.lookahead<MIN_LOOKAHEAD&&flush===Z_NO_FLUSH$2)return BS_NEED_MORE;if(s$2.lookahead===0)break}if(hash_head=0,s$2.lookahead>=MIN_MATCH&&(s$2.ins_h=HASH(s$2,s$2.ins_h,s$2.window[s$2.strstart+MIN_MATCH-1]),hash_head=s$2.prev[s$2.strstart&s$2.w_mask]=s$2.head[s$2.ins_h],s$2.head[s$2.ins_h]=s$2.strstart),s$2.prev_length=s$2.match_length,s$2.prev_match=s$2.match_start,s$2.match_length=MIN_MATCH-1,hash_head!==0&&s$2.prev_length<s$2.max_lazy_match&&s$2.strstart-hash_head<=s$2.w_size-MIN_LOOKAHEAD&&(s$2.match_length=longest_match(s$2,hash_head),s$2.match_length<=5&&(s$2.strategy===Z_FILTERED||s$2.match_length===MIN_MATCH&&s$2.strstart-s$2.match_start>4096)&&(s$2.match_length=MIN_MATCH-1)),s$2.prev_length>=MIN_MATCH&&s$2.match_length<=s$2.prev_length){max_insert=s$2.strstart+s$2.lookahead-MIN_MATCH,bflush=_tr_tally(s$2,s$2.strstart-1-s$2.prev_match,s$2.prev_length-MIN_MATCH),s$2.lookahead-=s$2.prev_length-1,s$2.prev_length-=2;do++s$2.strstart<=max_insert&&(s$2.ins_h=HASH(s$2,s$2.ins_h,s$2.window[s$2.strstart+MIN_MATCH-1]),hash_head=s$2.prev[s$2.strstart&s$2.w_mask]=s$2.head[s$2.ins_h],s$2.head[s$2.ins_h]=s$2.strstart);while(--s$2.prev_length!==0);if(s$2.match_available=0,s$2.match_length=MIN_MATCH-1,s$2.strstart++,bflush&&(flush_block_only(s$2,!1),s$2.strm.avail_out===0))return BS_NEED_MORE}else if(s$2.match_available){if(bflush=_tr_tally(s$2,0,s$2.window[s$2.strstart-1]),bflush&&flush_block_only(s$2,!1),s$2.strstart++,s$2.lookahead--,s$2.strm.avail_out===0)return BS_NEED_MORE}else s$2.match_available=1,s$2.strstart++,s$2.lookahead--}return s$2.match_available&&=(bflush=_tr_tally(s$2,0,s$2.window[s$2.strstart-1]),0),s$2.insert=s$2.strstart<MIN_MATCH-1?s$2.strstart:MIN_MATCH-1,flush===Z_FINISH$3?(flush_block_only(s$2,!0),s$2.strm.avail_out===0?BS_FINISH_STARTED:BS_FINISH_DONE):s$2.sym_next&&(flush_block_only(s$2,!1),s$2.strm.avail_out===0)?BS_NEED_MORE:BS_BLOCK_DONE},deflate_rle=(s$2,flush)=>{let bflush,prev,scan,strend,_win=s$2.window;for(;;){if(s$2.lookahead<=MAX_MATCH){if(fill_window(s$2),s$2.lookahead<=MAX_MATCH&&flush===Z_NO_FLUSH$2)return BS_NEED_MORE;if(s$2.lookahead===0)break}if(s$2.match_length=0,s$2.lookahead>=MIN_MATCH&&s$2.strstart>0&&(scan=s$2.strstart-1,prev=_win[scan],prev===_win[++scan]&&prev===_win[++scan]&&prev===_win[++scan])){strend=s$2.strstart+MAX_MATCH;do;while(prev===_win[++scan]&&prev===_win[++scan]&&prev===_win[++scan]&&prev===_win[++scan]&&prev===_win[++scan]&&prev===_win[++scan]&&prev===_win[++scan]&&prev===_win[++scan]&&scan<strend);s$2.match_length=MAX_MATCH-(strend-scan),s$2.match_length>s$2.lookahead&&(s$2.match_length=s$2.lookahead)}if(s$2.match_length>=MIN_MATCH?(bflush=_tr_tally(s$2,1,s$2.match_length-MIN_MATCH),s$2.lookahead-=s$2.match_length,s$2.strstart+=s$2.match_length,s$2.match_length=0):(bflush=_tr_tally(s$2,0,s$2.window[s$2.strstart]),s$2.lookahead--,s$2.strstart++),bflush&&(flush_block_only(s$2,!1),s$2.strm.avail_out===0))return BS_NEED_MORE}return s$2.insert=0,flush===Z_FINISH$3?(flush_block_only(s$2,!0),s$2.strm.avail_out===0?BS_FINISH_STARTED:BS_FINISH_DONE):s$2.sym_next&&(flush_block_only(s$2,!1),s$2.strm.avail_out===0)?BS_NEED_MORE:BS_BLOCK_DONE},deflate_huff=(s$2,flush)=>{let bflush;for(;;){if(s$2.lookahead===0&&(fill_window(s$2),s$2.lookahead===0)){if(flush===Z_NO_FLUSH$2)return BS_NEED_MORE;break}if(s$2.match_length=0,bflush=_tr_tally(s$2,0,s$2.window[s$2.strstart]),s$2.lookahead--,s$2.strstart++,bflush&&(flush_block_only(s$2,!1),s$2.strm.avail_out===0))return BS_NEED_MORE}return s$2.insert=0,flush===Z_FINISH$3?(flush_block_only(s$2,!0),s$2.strm.avail_out===0?BS_FINISH_STARTED:BS_FINISH_DONE):s$2.sym_next&&(flush_block_only(s$2,!1),s$2.strm.avail_out===0)?BS_NEED_MORE:BS_BLOCK_DONE};function Config(good_length,max_lazy,nice_length,max_chain,func){this.good_length=good_length,this.max_lazy=max_lazy,this.nice_length=nice_length,this.max_chain=max_chain,this.func=func}var configuration_table=[new Config(0,0,0,0,deflate_stored),new Config(4,4,8,4,deflate_fast),new Config(4,5,16,8,deflate_fast),new Config(4,6,32,32,deflate_fast),new Config(4,4,16,16,deflate_slow),new Config(8,16,32,32,deflate_slow),new Config(8,16,128,128,deflate_slow),new Config(8,32,128,256,deflate_slow),new Config(32,128,258,1024,deflate_slow),new Config(32,258,258,4096,deflate_slow)],lm_init=s$2=>{s$2.window_size=2*s$2.w_size,zero(s$2.head),s$2.max_lazy_match=configuration_table[s$2.level].max_lazy,s$2.good_match=configuration_table[s$2.level].good_length,s$2.nice_match=configuration_table[s$2.level].nice_length,s$2.max_chain_length=configuration_table[s$2.level].max_chain,s$2.strstart=0,s$2.block_start=0,s$2.lookahead=0,s$2.insert=0,s$2.match_length=s$2.prev_length=MIN_MATCH-1,s$2.match_available=0,s$2.ins_h=0};function DeflateState(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=Z_DEFLATED$2,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new Uint16Array(HEAP_SIZE*2),this.dyn_dtree=new Uint16Array((2*D_CODES+1)*2),this.bl_tree=new Uint16Array((2*BL_CODES+1)*2),zero(this.dyn_ltree),zero(this.dyn_dtree),zero(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new Uint16Array(MAX_BITS+1),this.heap=new Uint16Array(2*L_CODES+1),zero(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new Uint16Array(2*L_CODES+1),zero(this.depth),this.sym_buf=0,this.lit_bufsize=0,this.sym_next=0,this.sym_end=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}var deflateStateCheck=strm=>{if(!strm)return 1;let s$2=strm.state;return!s$2||s$2.strm!==strm||s$2.status!==INIT_STATE&&s$2.status!==GZIP_STATE&&s$2.status!==EXTRA_STATE&&s$2.status!==NAME_STATE&&s$2.status!==COMMENT_STATE&&s$2.status!==HCRC_STATE&&s$2.status!==BUSY_STATE&&s$2.status!==FINISH_STATE?1:0},deflateResetKeep=strm=>{if(deflateStateCheck(strm))return err(strm,Z_STREAM_ERROR$2);strm.total_in=strm.total_out=0,strm.data_type=Z_UNKNOWN;let s$2=strm.state;return s$2.pending=0,s$2.pending_out=0,s$2.wrap<0&&(s$2.wrap=-s$2.wrap),s$2.status=s$2.wrap===2?GZIP_STATE:s$2.wrap?INIT_STATE:BUSY_STATE,strm.adler=s$2.wrap===2?0:1,s$2.last_flush=-2,_tr_init(s$2),Z_OK$3},deflateReset=strm=>{let ret=deflateResetKeep(strm);return ret===Z_OK$3&&lm_init(strm.state),ret},deflateSetHeader=(strm,head)=>deflateStateCheck(strm)||strm.state.wrap!==2?Z_STREAM_ERROR$2:(strm.state.gzhead=head,Z_OK$3),deflateInit2=(strm,level$1,method,windowBits,memLevel,strategy)=>{if(!strm)return Z_STREAM_ERROR$2;let wrap$2=1;if(level$1===Z_DEFAULT_COMPRESSION$1&&(level$1=6),windowBits<0?(wrap$2=0,windowBits=-windowBits):windowBits>15&&(wrap$2=2,windowBits-=16),memLevel<1||memLevel>MAX_MEM_LEVEL||method!==Z_DEFLATED$2||windowBits<8||windowBits>15||level$1<0||level$1>9||strategy<0||strategy>Z_FIXED||windowBits===8&&wrap$2!==1)return err(strm,Z_STREAM_ERROR$2);windowBits===8&&(windowBits=9);let s$2=new DeflateState;return strm.state=s$2,s$2.strm=strm,s$2.status=INIT_STATE,s$2.wrap=wrap$2,s$2.gzhead=null,s$2.w_bits=windowBits,s$2.w_size=1<<s$2.w_bits,s$2.w_mask=s$2.w_size-1,s$2.hash_bits=memLevel+7,s$2.hash_size=1<<s$2.hash_bits,s$2.hash_mask=s$2.hash_size-1,s$2.hash_shift=~~((s$2.hash_bits+MIN_MATCH-1)/MIN_MATCH),s$2.window=new Uint8Array(s$2.w_size*2),s$2.head=new Uint16Array(s$2.hash_size),s$2.prev=new Uint16Array(s$2.w_size),s$2.lit_bufsize=1<<memLevel+6,s$2.pending_buf_size=s$2.lit_bufsize*4,s$2.pending_buf=new Uint8Array(s$2.pending_buf_size),s$2.sym_buf=s$2.lit_bufsize,s$2.sym_end=(s$2.lit_bufsize-1)*3,s$2.level=level$1,s$2.strategy=strategy,s$2.method=method,deflateReset(strm)},deflate_1$2={deflateInit:(strm,level$1)=>deflateInit2(strm,level$1,Z_DEFLATED$2,MAX_WBITS$1,DEF_MEM_LEVEL,Z_DEFAULT_STRATEGY$1),deflateInit2,deflateReset,deflateResetKeep,deflateSetHeader,deflate:(strm,flush)=>{if(deflateStateCheck(strm)||flush>Z_BLOCK$1||flush<0)return strm?err(strm,Z_STREAM_ERROR$2):Z_STREAM_ERROR$2;let s$2=strm.state;if(!strm.output||strm.avail_in!==0&&!strm.input||s$2.status===FINISH_STATE&&flush!==Z_FINISH$3)return err(strm,strm.avail_out===0?Z_BUF_ERROR$1:Z_STREAM_ERROR$2);let old_flush=s$2.last_flush;if(s$2.last_flush=flush,s$2.pending!==0){if(flush_pending(strm),strm.avail_out===0)return s$2.last_flush=-1,Z_OK$3}else if(strm.avail_in===0&&rank(flush)<=rank(old_flush)&&flush!==Z_FINISH$3)return err(strm,Z_BUF_ERROR$1);if(s$2.status===FINISH_STATE&&strm.avail_in!==0)return err(strm,Z_BUF_ERROR$1);if(s$2.status===INIT_STATE&&s$2.wrap===0&&(s$2.status=BUSY_STATE),s$2.status===INIT_STATE){let header=Z_DEFLATED$2+(s$2.w_bits-8<<4)<<8,level_flags=-1;if(level_flags=s$2.strategy>=Z_HUFFMAN_ONLY||s$2.level<2?0:s$2.level<6?1:s$2.level===6?2:3,header|=level_flags<<6,s$2.strstart!==0&&(header|=PRESET_DICT),header+=31-header%31,putShortMSB(s$2,header),s$2.strstart!==0&&(putShortMSB(s$2,strm.adler>>>16),putShortMSB(s$2,strm.adler&65535)),strm.adler=1,s$2.status=BUSY_STATE,flush_pending(strm),s$2.pending!==0)return s$2.last_flush=-1,Z_OK$3}if(s$2.status===GZIP_STATE){if(strm.adler=0,put_byte(s$2,31),put_byte(s$2,139),put_byte(s$2,8),s$2.gzhead)put_byte(s$2,(s$2.gzhead.text?1:0)+(s$2.gzhead.hcrc?2:0)+(s$2.gzhead.extra?4:0)+(s$2.gzhead.name?8:0)+(s$2.gzhead.comment?16:0)),put_byte(s$2,s$2.gzhead.time&255),put_byte(s$2,s$2.gzhead.time>>8&255),put_byte(s$2,s$2.gzhead.time>>16&255),put_byte(s$2,s$2.gzhead.time>>24&255),put_byte(s$2,s$2.level===9?2:s$2.strategy>=Z_HUFFMAN_ONLY||s$2.level<2?4:0),put_byte(s$2,s$2.gzhead.os&255),s$2.gzhead.extra&&s$2.gzhead.extra.length&&(put_byte(s$2,s$2.gzhead.extra.length&255),put_byte(s$2,s$2.gzhead.extra.length>>8&255)),s$2.gzhead.hcrc&&(strm.adler=crc32_1(strm.adler,s$2.pending_buf,s$2.pending,0)),s$2.gzindex=0,s$2.status=EXTRA_STATE;else if(put_byte(s$2,0),put_byte(s$2,0),put_byte(s$2,0),put_byte(s$2,0),put_byte(s$2,0),put_byte(s$2,s$2.level===9?2:s$2.strategy>=Z_HUFFMAN_ONLY||s$2.level<2?4:0),put_byte(s$2,OS_CODE),s$2.status=BUSY_STATE,flush_pending(strm),s$2.pending!==0)return s$2.last_flush=-1,Z_OK$3}if(s$2.status===EXTRA_STATE){if(s$2.gzhead.extra){let beg=s$2.pending,left=(s$2.gzhead.extra.length&65535)-s$2.gzindex;for(;s$2.pending+left>s$2.pending_buf_size;){let copy=s$2.pending_buf_size-s$2.pending;if(s$2.pending_buf.set(s$2.gzhead.extra.subarray(s$2.gzindex,s$2.gzindex+copy),s$2.pending),s$2.pending=s$2.pending_buf_size,s$2.gzhead.hcrc&&s$2.pending>beg&&(strm.adler=crc32_1(strm.adler,s$2.pending_buf,s$2.pending-beg,beg)),s$2.gzindex+=copy,flush_pending(strm),s$2.pending!==0)return s$2.last_flush=-1,Z_OK$3;beg=0,left-=copy}let gzhead_extra=new Uint8Array(s$2.gzhead.extra);s$2.pending_buf.set(gzhead_extra.subarray(s$2.gzindex,s$2.gzindex+left),s$2.pending),s$2.pending+=left,s$2.gzhead.hcrc&&s$2.pending>beg&&(strm.adler=crc32_1(strm.adler,s$2.pending_buf,s$2.pending-beg,beg)),s$2.gzindex=0}s$2.status=NAME_STATE}if(s$2.status===NAME_STATE){if(s$2.gzhead.name){let beg=s$2.pending,val;do{if(s$2.pending===s$2.pending_buf_size){if(s$2.gzhead.hcrc&&s$2.pending>beg&&(strm.adler=crc32_1(strm.adler,s$2.pending_buf,s$2.pending-beg,beg)),flush_pending(strm),s$2.pending!==0)return s$2.last_flush=-1,Z_OK$3;beg=0}val=s$2.gzindex<s$2.gzhead.name.length?s$2.gzhead.name.charCodeAt(s$2.gzindex++)&255:0,put_byte(s$2,val)}while(val!==0);s$2.gzhead.hcrc&&s$2.pending>beg&&(strm.adler=crc32_1(strm.adler,s$2.pending_buf,s$2.pending-beg,beg)),s$2.gzindex=0}s$2.status=COMMENT_STATE}if(s$2.status===COMMENT_STATE){if(s$2.gzhead.comment){let beg=s$2.pending,val;do{if(s$2.pending===s$2.pending_buf_size){if(s$2.gzhead.hcrc&&s$2.pending>beg&&(strm.adler=crc32_1(strm.adler,s$2.pending_buf,s$2.pending-beg,beg)),flush_pending(strm),s$2.pending!==0)return s$2.last_flush=-1,Z_OK$3;beg=0}val=s$2.gzindex<s$2.gzhead.comment.length?s$2.gzhead.comment.charCodeAt(s$2.gzindex++)&255:0,put_byte(s$2,val)}while(val!==0);s$2.gzhead.hcrc&&s$2.pending>beg&&(strm.adler=crc32_1(strm.adler,s$2.pending_buf,s$2.pending-beg,beg))}s$2.status=HCRC_STATE}if(s$2.status===HCRC_STATE){if(s$2.gzhead.hcrc){if(s$2.pending+2>s$2.pending_buf_size&&(flush_pending(strm),s$2.pending!==0))return s$2.last_flush=-1,Z_OK$3;put_byte(s$2,strm.adler&255),put_byte(s$2,strm.adler>>8&255),strm.adler=0}if(s$2.status=BUSY_STATE,flush_pending(strm),s$2.pending!==0)return s$2.last_flush=-1,Z_OK$3}if(strm.avail_in!==0||s$2.lookahead!==0||flush!==Z_NO_FLUSH$2&&s$2.status!==FINISH_STATE){let bstate=s$2.level===0?deflate_stored(s$2,flush):s$2.strategy===Z_HUFFMAN_ONLY?deflate_huff(s$2,flush):s$2.strategy===Z_RLE?deflate_rle(s$2,flush):configuration_table[s$2.level].func(s$2,flush);if((bstate===BS_FINISH_STARTED||bstate===BS_FINISH_DONE)&&(s$2.status=FINISH_STATE),bstate===BS_NEED_MORE||bstate===BS_FINISH_STARTED)return strm.avail_out===0&&(s$2.last_flush=-1),Z_OK$3;if(bstate===BS_BLOCK_DONE&&(flush===Z_PARTIAL_FLUSH?_tr_align(s$2):flush!==Z_BLOCK$1&&(_tr_stored_block(s$2,0,0,!1),flush===Z_FULL_FLUSH$1&&(zero(s$2.head),s$2.lookahead===0&&(s$2.strstart=0,s$2.block_start=0,s$2.insert=0))),flush_pending(strm),strm.avail_out===0))return s$2.last_flush=-1,Z_OK$3}return flush===Z_FINISH$3?s$2.wrap<=0?Z_STREAM_END$3:(s$2.wrap===2?(put_byte(s$2,strm.adler&255),put_byte(s$2,strm.adler>>8&255),put_byte(s$2,strm.adler>>16&255),put_byte(s$2,strm.adler>>24&255),put_byte(s$2,strm.total_in&255),put_byte(s$2,strm.total_in>>8&255),put_byte(s$2,strm.total_in>>16&255),put_byte(s$2,strm.total_in>>24&255)):(putShortMSB(s$2,strm.adler>>>16),putShortMSB(s$2,strm.adler&65535)),flush_pending(strm),s$2.wrap>0&&(s$2.wrap=-s$2.wrap),s$2.pending===0?Z_STREAM_END$3:Z_OK$3):Z_OK$3},deflateEnd:strm=>{if(deflateStateCheck(strm))return Z_STREAM_ERROR$2;let status=strm.state.status;return strm.state=null,status===BUSY_STATE?err(strm,Z_DATA_ERROR$2):Z_OK$3},deflateSetDictionary:(strm,dictionary)=>{let dictLength=dictionary.length;if(deflateStateCheck(strm))return Z_STREAM_ERROR$2;let s$2=strm.state,wrap$2=s$2.wrap;if(wrap$2===2||wrap$2===1&&s$2.status!==INIT_STATE||s$2.lookahead)return Z_STREAM_ERROR$2;if(wrap$2===1&&(strm.adler=adler32_1(strm.adler,dictionary,dictLength,0)),s$2.wrap=0,dictLength>=s$2.w_size){wrap$2===0&&(zero(s$2.head),s$2.strstart=0,s$2.block_start=0,s$2.insert=0);let tmpDict=new Uint8Array(s$2.w_size);tmpDict.set(dictionary.subarray(dictLength-s$2.w_size,dictLength),0),dictionary=tmpDict,dictLength=s$2.w_size}let avail=strm.avail_in,next=strm.next_in,input=strm.input;for(strm.avail_in=dictLength,strm.next_in=0,strm.input=dictionary,fill_window(s$2);s$2.lookahead>=MIN_MATCH;){let str=s$2.strstart,n$3=s$2.lookahead-(MIN_MATCH-1);do s$2.ins_h=HASH(s$2,s$2.ins_h,s$2.window[str+MIN_MATCH-1]),s$2.prev[str&s$2.w_mask]=s$2.head[s$2.ins_h],s$2.head[s$2.ins_h]=str,str++;while(--n$3);s$2.strstart=str,s$2.lookahead=MIN_MATCH-1,fill_window(s$2)}return s$2.strstart+=s$2.lookahead,s$2.block_start=s$2.strstart,s$2.insert=s$2.lookahead,s$2.lookahead=0,s$2.match_length=s$2.prev_length=MIN_MATCH-1,s$2.match_available=0,strm.next_in=next,strm.input=input,strm.avail_in=avail,s$2.wrap=wrap$2,Z_OK$3},deflateInfo:`pako deflate (from Nodeca project)`},_has=(obj,key)=>Object.prototype.hasOwnProperty.call(obj,key),common={assign:function(obj){let sources=Array.prototype.slice.call(arguments,1);for(;sources.length;){let source=sources.shift();if(source){if(typeof source!=`object`)throw TypeError(source+`must be non-object`);for(let p$3 in source)_has(source,p$3)&&(obj[p$3]=source[p$3])}}return obj},flattenChunks:chunks=>{let len=0;for(let i$3=0,l$2=chunks.length;i$3<l$2;i$3++)len+=chunks[i$3].length;let result=new Uint8Array(len);for(let i$3=0,pos=0,l$2=chunks.length;i$3<l$2;i$3++){let chunk=chunks[i$3];result.set(chunk,pos),pos+=chunk.length}return result}},STR_APPLY_UIA_OK=!0;try{String.fromCharCode.apply(null,new Uint8Array(1))}catch{STR_APPLY_UIA_OK=!1}var _utf8len=new Uint8Array(256);for(let q=0;q<256;q++)_utf8len[q]=q>=252?6:q>=248?5:q>=240?4:q>=224?3:q>=192?2:1;_utf8len[254]=_utf8len[254]=1;var string2buf=str=>{if(typeof TextEncoder==`function`&&TextEncoder.prototype.encode)return new TextEncoder().encode(str);let buf,c$2,c2,m_pos,i$3,str_len=str.length,buf_len=0;for(m_pos=0;m_pos<str_len;m_pos++)c$2=str.charCodeAt(m_pos),(c$2&64512)==55296&&m_pos+1<str_len&&(c2=str.charCodeAt(m_pos+1),(c2&64512)==56320&&(c$2=65536+(c$2-55296<<10)+(c2-56320),m_pos++)),buf_len+=c$2<128?1:c$2<2048?2:c$2<65536?3:4;for(buf=new Uint8Array(buf_len),i$3=0,m_pos=0;i$3<buf_len;m_pos++)c$2=str.charCodeAt(m_pos),(c$2&64512)==55296&&m_pos+1<str_len&&(c2=str.charCodeAt(m_pos+1),(c2&64512)==56320&&(c$2=65536+(c$2-55296<<10)+(c2-56320),m_pos++)),c$2<128?buf[i$3++]=c$2:c$2<2048?(buf[i$3++]=192|c$2>>>6,buf[i$3++]=128|c$2&63):c$2<65536?(buf[i$3++]=224|c$2>>>12,buf[i$3++]=128|c$2>>>6&63,buf[i$3++]=128|c$2&63):(buf[i$3++]=240|c$2>>>18,buf[i$3++]=128|c$2>>>12&63,buf[i$3++]=128|c$2>>>6&63,buf[i$3++]=128|c$2&63);return buf},buf2binstring=(buf,len)=>{if(len<65534&&buf.subarray&&STR_APPLY_UIA_OK)return String.fromCharCode.apply(null,buf.length===len?buf:buf.subarray(0,len));let result=``;for(let i$3=0;i$3<len;i$3++)result+=String.fromCharCode(buf[i$3]);return result},strings={string2buf,buf2string:(buf,max$2)=>{let len=max$2||buf.length;if(typeof TextDecoder==`function`&&TextDecoder.prototype.decode)return new TextDecoder().decode(buf.subarray(0,max$2));let i$3,out,utf16buf=Array(len*2);for(out=0,i$3=0;i$3<len;){let c$2=buf[i$3++];if(c$2<128){utf16buf[out++]=c$2;continue}let c_len=_utf8len[c$2];if(c_len>4){utf16buf[out++]=65533,i$3+=c_len-1;continue}for(c$2&=c_len===2?31:c_len===3?15:7;c_len>1&&i$3<len;)c$2=c$2<<6|buf[i$3++]&63,c_len--;if(c_len>1){utf16buf[out++]=65533;continue}c$2<65536?utf16buf[out++]=c$2:(c$2-=65536,utf16buf[out++]=55296|c$2>>10&1023,utf16buf[out++]=56320|c$2&1023)}return buf2binstring(utf16buf,out)},utf8border:(buf,max$2)=>{max$2||=buf.length,max$2>buf.length&&(max$2=buf.length);let pos=max$2-1;for(;pos>=0&&(buf[pos]&192)==128;)pos--;return pos<0||pos===0?max$2:pos+_utf8len[buf[pos]]>max$2?pos:max$2}};function ZStream(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg=``,this.state=null,this.data_type=2,this.adler=0}var zstream=ZStream,toString$1=Object.prototype.toString,{Z_NO_FLUSH:Z_NO_FLUSH$1,Z_SYNC_FLUSH,Z_FULL_FLUSH,Z_FINISH:Z_FINISH$2,Z_OK:Z_OK$2,Z_STREAM_END:Z_STREAM_END$2,Z_DEFAULT_COMPRESSION,Z_DEFAULT_STRATEGY,Z_DEFLATED:Z_DEFLATED$1}=constants$2;function Deflate$1(options){this.options=common.assign({level:Z_DEFAULT_COMPRESSION,method:Z_DEFLATED$1,chunkSize:16384,windowBits:15,memLevel:8,strategy:Z_DEFAULT_STRATEGY},options||{});let opt=this.options;opt.raw&&opt.windowBits>0?opt.windowBits=-opt.windowBits:opt.gzip&&opt.windowBits>0&&opt.windowBits<16&&(opt.windowBits+=16),this.err=0,this.msg=``,this.ended=!1,this.chunks=[],this.strm=new zstream,this.strm.avail_out=0;let status=deflate_1$2.deflateInit2(this.strm,opt.level,opt.method,opt.windowBits,opt.memLevel,opt.strategy);if(status!==Z_OK$2)throw Error(messages[status]);if(opt.header&&deflate_1$2.deflateSetHeader(this.strm,opt.header),opt.dictionary){let dict;if(dict=typeof opt.dictionary==`string`?strings.string2buf(opt.dictionary):toString$1.call(opt.dictionary)===`[object ArrayBuffer]`?new Uint8Array(opt.dictionary):opt.dictionary,status=deflate_1$2.deflateSetDictionary(this.strm,dict),status!==Z_OK$2)throw Error(messages[status]);this._dict_set=!0}}Deflate$1.prototype.push=function(data,flush_mode){let strm=this.strm,chunkSize=this.options.chunkSize,status,_flush_mode;if(this.ended)return!1;for(_flush_mode=flush_mode===~~flush_mode?flush_mode:flush_mode===!0?Z_FINISH$2:Z_NO_FLUSH$1,typeof data==`string`?strm.input=strings.string2buf(data):toString$1.call(data)===`[object ArrayBuffer]`?strm.input=new Uint8Array(data):strm.input=data,strm.next_in=0,strm.avail_in=strm.input.length;;){if(strm.avail_out===0&&(strm.output=new Uint8Array(chunkSize),strm.next_out=0,strm.avail_out=chunkSize),(_flush_mode===Z_SYNC_FLUSH||_flush_mode===Z_FULL_FLUSH)&&strm.avail_out<=6){this.onData(strm.output.subarray(0,strm.next_out)),strm.avail_out=0;continue}if(status=deflate_1$2.deflate(strm,_flush_mode),status===Z_STREAM_END$2)return strm.next_out>0&&this.onData(strm.output.subarray(0,strm.next_out)),status=deflate_1$2.deflateEnd(this.strm),this.onEnd(status),this.ended=!0,status===Z_OK$2;if(strm.avail_out===0){this.onData(strm.output);continue}if(_flush_mode>0&&strm.next_out>0){this.onData(strm.output.subarray(0,strm.next_out)),strm.avail_out=0;continue}if(strm.avail_in===0)break}return!0},Deflate$1.prototype.onData=function(chunk){this.chunks.push(chunk)},Deflate$1.prototype.onEnd=function(status){status===Z_OK$2&&(this.result=common.flattenChunks(this.chunks)),this.chunks=[],this.err=status,this.msg=this.strm.msg};function deflate$1(input,options){let deflator=new Deflate$1(options);if(deflator.push(input,!0),deflator.err)throw deflator.msg||messages[deflator.err];return deflator.result}function deflateRaw$1(input,options){return options||={},options.raw=!0,deflate$1(input,options)}function gzip$1(input,options){return options||={},options.gzip=!0,deflate$1(input,options)}var deflate_1$1={Deflate:Deflate$1,deflate:deflate$1,deflateRaw:deflateRaw$1,gzip:gzip$1,constants:constants$2},BAD$1=16209,TYPE$1=16191,inffast=function(strm,start){let _in,last,_out,beg,end,dmax,wsize,whave,wnext,s_window,hold,bits,lcode,dcode,lmask,dmask,here,op,len,dist,from,from_source,input,output,state=strm.state;_in=strm.next_in,input=strm.input,last=_in+(strm.avail_in-5),_out=strm.next_out,output=strm.output,beg=_out-(start-strm.avail_out),end=_out+(strm.avail_out-257),dmax=state.dmax,wsize=state.wsize,whave=state.whave,wnext=state.wnext,s_window=state.window,hold=state.hold,bits=state.bits,lcode=state.lencode,dcode=state.distcode,lmask=(1<<state.lenbits)-1,dmask=(1<<state.distbits)-1;top:do{bits<15&&(hold+=input[_in++]<<bits,bits+=8,hold+=input[_in++]<<bits,bits+=8),here=lcode[hold&lmask];dolen:for(;;){if(op=here>>>24,hold>>>=op,bits-=op,op=here>>>16&255,op===0)output[_out++]=here&65535;else if(op&16){len=here&65535,op&=15,op&&(bits<op&&(hold+=input[_in++]<<bits,bits+=8),len+=hold&(1<<op)-1,hold>>>=op,bits-=op),bits<15&&(hold+=input[_in++]<<bits,bits+=8,hold+=input[_in++]<<bits,bits+=8),here=dcode[hold&dmask];dodist:for(;;){if(op=here>>>24,hold>>>=op,bits-=op,op=here>>>16&255,op&16){if(dist=here&65535,op&=15,bits<op&&(hold+=input[_in++]<<bits,bits+=8,bits<op&&(hold+=input[_in++]<<bits,bits+=8)),dist+=hold&(1<<op)-1,dist>dmax){strm.msg=`invalid distance too far back`,state.mode=BAD$1;break top}if(hold>>>=op,bits-=op,op=_out-beg,dist>op){if(op=dist-op,op>whave&&state.sane){strm.msg=`invalid distance too far back`,state.mode=BAD$1;break top}if(from=0,from_source=s_window,wnext===0){if(from+=wsize-op,op<len){len-=op;do output[_out++]=s_window[from++];while(--op);from=_out-dist,from_source=output}}else if(wnext<op){if(from+=wsize+wnext-op,op-=wnext,op<len){len-=op;do output[_out++]=s_window[from++];while(--op);if(from=0,wnext<len){op=wnext,len-=op;do output[_out++]=s_window[from++];while(--op);from=_out-dist,from_source=output}}}else if(from+=wnext-op,op<len){len-=op;do output[_out++]=s_window[from++];while(--op);from=_out-dist,from_source=output}for(;len>2;)output[_out++]=from_source[from++],output[_out++]=from_source[from++],output[_out++]=from_source[from++],len-=3;len&&(output[_out++]=from_source[from++],len>1&&(output[_out++]=from_source[from++]))}else{from=_out-dist;do output[_out++]=output[from++],output[_out++]=output[from++],output[_out++]=output[from++],len-=3;while(len>2);len&&(output[_out++]=output[from++],len>1&&(output[_out++]=output[from++]))}}else if(op&64){strm.msg=`invalid distance code`,state.mode=BAD$1;break top}else{here=dcode[(here&65535)+(hold&(1<<op)-1)];continue dodist}break}}else if(op&64)if(op&32){state.mode=TYPE$1;break top}else{strm.msg=`invalid literal/length code`,state.mode=BAD$1;break top}else{here=lcode[(here&65535)+(hold&(1<<op)-1)];continue dolen}break}}while(_in<last&&_out<end);len=bits>>3,_in-=len,bits-=len<<3,hold&=(1<<bits)-1,strm.next_in=_in,strm.next_out=_out,strm.avail_in=_in<last?5+(last-_in):5-(_in-last),strm.avail_out=_out<end?257+(end-_out):257-(_out-end),state.hold=hold,state.bits=bits},MAXBITS=15,ENOUGH_LENS$1=852,ENOUGH_DISTS$1=592,CODES$1=0,LENS$1=1,DISTS$1=2,lbase=new Uint16Array([3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0]),lext=new Uint8Array([16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78]),dbase=new Uint16Array([1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0]),dext=new Uint8Array([16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64]),inftrees=(type,lens,lens_index,codes,table,table_index,work,opts)=>{let bits=opts.bits,len=0,sym=0,min$2=0,max$2=0,root=0,curr=0,drop=0,left=0,used=0,huff=0,incr,fill,low,mask,next,base=null,match,count=new Uint16Array(MAXBITS+1),offs=new Uint16Array(MAXBITS+1),extra=null,here_bits,here_op,here_val;for(len=0;len<=MAXBITS;len++)count[len]=0;for(sym=0;sym<codes;sym++)count[lens[lens_index+sym]]++;for(root=bits,max$2=MAXBITS;max$2>=1&&count[max$2]===0;max$2--);if(root>max$2&&(root=max$2),max$2===0)return table[table_index++]=20971520,table[table_index++]=20971520,opts.bits=1,0;for(min$2=1;min$2<max$2&&count[min$2]===0;min$2++);for(root<min$2&&(root=min$2),left=1,len=1;len<=MAXBITS;len++)if(left<<=1,left-=count[len],left<0)return-1;if(left>0&&(type===CODES$1||max$2!==1))return-1;for(offs[1]=0,len=1;len<MAXBITS;len++)offs[len+1]=offs[len]+count[len];for(sym=0;sym<codes;sym++)lens[lens_index+sym]!==0&&(work[offs[lens[lens_index+sym]]++]=sym);if(type===CODES$1?(base=extra=work,match=20):type===LENS$1?(base=lbase,extra=lext,match=257):(base=dbase,extra=dext,match=0),huff=0,sym=0,len=min$2,next=table_index,curr=root,drop=0,low=-1,used=1<<root,mask=used-1,type===LENS$1&&used>ENOUGH_LENS$1||type===DISTS$1&&used>ENOUGH_DISTS$1)return 1;for(;;){here_bits=len-drop,work[sym]+1<match?(here_op=0,here_val=work[sym]):work[sym]>=match?(here_op=extra[work[sym]-match],here_val=base[work[sym]-match]):(here_op=96,here_val=0),incr=1<<len-drop,fill=1<<curr,min$2=fill;do fill-=incr,table[next+(huff>>drop)+fill]=here_bits<<24|here_op<<16|here_val|0;while(fill!==0);for(incr=1<<len-1;huff&incr;)incr>>=1;if(incr===0?huff=0:(huff&=incr-1,huff+=incr),sym++,--count[len]===0){if(len===max$2)break;len=lens[lens_index+work[sym]]}if(len>root&&(huff&mask)!==low){for(drop===0&&(drop=root),next+=min$2,curr=len-drop,left=1<<curr;curr+drop<max$2&&(left-=count[curr+drop],!(left<=0));)curr++,left<<=1;if(used+=1<<curr,type===LENS$1&&used>ENOUGH_LENS$1||type===DISTS$1&&used>ENOUGH_DISTS$1)return 1;low=huff&mask,table[low]=root<<24|curr<<16|next-table_index|0}}return huff!==0&&(table[next+huff]=len-drop<<24|4194304),opts.bits=root,0},CODES=0,LENS=1,DISTS=2,{Z_FINISH:Z_FINISH$1,Z_BLOCK,Z_TREES,Z_OK:Z_OK$1,Z_STREAM_END:Z_STREAM_END$1,Z_NEED_DICT:Z_NEED_DICT$1,Z_STREAM_ERROR:Z_STREAM_ERROR$1,Z_DATA_ERROR:Z_DATA_ERROR$1,Z_MEM_ERROR:Z_MEM_ERROR$1,Z_BUF_ERROR,Z_DEFLATED}=constants$2,HEAD=16180,FLAGS=16181,TIME=16182,OS=16183,EXLEN=16184,EXTRA=16185,NAME=16186,COMMENT=16187,HCRC=16188,DICTID=16189,DICT=16190,TYPE=16191,TYPEDO=16192,STORED=16193,COPY_=16194,COPY=16195,TABLE=16196,LENLENS=16197,CODELENS=16198,LEN_=16199,LEN=16200,LENEXT=16201,DIST=16202,DISTEXT=16203,MATCH=16204,LIT=16205,CHECK=16206,LENGTH=16207,DONE=16208,BAD=16209,MEM=16210,SYNC=16211,ENOUGH_LENS=852,ENOUGH_DISTS=592,DEF_WBITS=15,zswap32=q=>(q>>>24&255)+(q>>>8&65280)+((q&65280)<<8)+((q&255)<<24);function InflateState(){this.strm=null,this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new Uint16Array(320),this.work=new Uint16Array(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}var inflateStateCheck=strm=>{if(!strm)return 1;let state=strm.state;return!state||state.strm!==strm||state.mode<HEAD||state.mode>SYNC?1:0},inflateResetKeep=strm=>{if(inflateStateCheck(strm))return Z_STREAM_ERROR$1;let state=strm.state;return strm.total_in=strm.total_out=state.total=0,strm.msg=``,state.wrap&&(strm.adler=state.wrap&1),state.mode=HEAD,state.last=0,state.havedict=0,state.flags=-1,state.dmax=32768,state.head=null,state.hold=0,state.bits=0,state.lencode=state.lendyn=new Int32Array(ENOUGH_LENS),state.distcode=state.distdyn=new Int32Array(ENOUGH_DISTS),state.sane=1,state.back=-1,Z_OK$1},inflateReset=strm=>{if(inflateStateCheck(strm))return Z_STREAM_ERROR$1;let state=strm.state;return state.wsize=0,state.whave=0,state.wnext=0,inflateResetKeep(strm)},inflateReset2=(strm,windowBits)=>{let wrap$2;if(inflateStateCheck(strm))return Z_STREAM_ERROR$1;let state=strm.state;return windowBits<0?(wrap$2=0,windowBits=-windowBits):(wrap$2=(windowBits>>4)+5,windowBits<48&&(windowBits&=15)),windowBits&&(windowBits<8||windowBits>15)?Z_STREAM_ERROR$1:(state.window!==null&&state.wbits!==windowBits&&(state.window=null),state.wrap=wrap$2,state.wbits=windowBits,inflateReset(strm))},inflateInit2=(strm,windowBits)=>{if(!strm)return Z_STREAM_ERROR$1;let state=new InflateState;strm.state=state,state.strm=strm,state.window=null,state.mode=HEAD;let ret=inflateReset2(strm,windowBits);return ret!==Z_OK$1&&(strm.state=null),ret},inflateInit=strm=>inflateInit2(strm,DEF_WBITS),virgin=!0,lenfix,distfix,fixedtables=state=>{if(virgin){lenfix=new Int32Array(512),distfix=new Int32Array(32);let sym=0;for(;sym<144;)state.lens[sym++]=8;for(;sym<256;)state.lens[sym++]=9;for(;sym<280;)state.lens[sym++]=7;for(;sym<288;)state.lens[sym++]=8;for(inftrees(LENS,state.lens,0,288,lenfix,0,state.work,{bits:9}),sym=0;sym<32;)state.lens[sym++]=5;inftrees(DISTS,state.lens,0,32,distfix,0,state.work,{bits:5}),virgin=!1}state.lencode=lenfix,state.lenbits=9,state.distcode=distfix,state.distbits=5},updatewindow=(strm,src,end,copy)=>{let dist,state=strm.state;return state.window===null&&(state.wsize=1<<state.wbits,state.wnext=0,state.whave=0,state.window=new Uint8Array(state.wsize)),copy>=state.wsize?(state.window.set(src.subarray(end-state.wsize,end),0),state.wnext=0,state.whave=state.wsize):(dist=state.wsize-state.wnext,dist>copy&&(dist=copy),state.window.set(src.subarray(end-copy,end-copy+dist),state.wnext),copy-=dist,copy?(state.window.set(src.subarray(end-copy,end),0),state.wnext=copy,state.whave=state.wsize):(state.wnext+=dist,state.wnext===state.wsize&&(state.wnext=0),state.whave<state.wsize&&(state.whave+=dist))),0},inflate_1$2={inflateReset,inflateReset2,inflateResetKeep,inflateInit,inflateInit2,inflate:(strm,flush)=>{let state,input,output,next,put,have,left,hold,bits,_in,_out,copy,from,from_source,here=0,here_bits,here_op,here_val,last_bits,last_op,last_val,len,ret,hbuf=new Uint8Array(4),opts,n$3,order=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);if(inflateStateCheck(strm)||!strm.output||!strm.input&&strm.avail_in!==0)return Z_STREAM_ERROR$1;state=strm.state,state.mode===TYPE&&(state.mode=TYPEDO),put=strm.next_out,output=strm.output,left=strm.avail_out,next=strm.next_in,input=strm.input,have=strm.avail_in,hold=state.hold,bits=state.bits,_in=have,_out=left,ret=Z_OK$1;inf_leave:for(;;)switch(state.mode){case HEAD:if(state.wrap===0){state.mode=TYPEDO;break}for(;bits<16;){if(have===0)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}if(state.wrap&2&&hold===35615){state.wbits===0&&(state.wbits=15),state.check=0,hbuf[0]=hold&255,hbuf[1]=hold>>>8&255,state.check=crc32_1(state.check,hbuf,2,0),hold=0,bits=0,state.mode=FLAGS;break}if(state.head&&(state.head.done=!1),!(state.wrap&1)||(((hold&255)<<8)+(hold>>8))%31){strm.msg=`incorrect header check`,state.mode=BAD;break}if((hold&15)!==Z_DEFLATED){strm.msg=`unknown compression method`,state.mode=BAD;break}if(hold>>>=4,bits-=4,len=(hold&15)+8,state.wbits===0&&(state.wbits=len),len>15||len>state.wbits){strm.msg=`invalid window size`,state.mode=BAD;break}state.dmax=1<<state.wbits,state.flags=0,strm.adler=state.check=1,state.mode=hold&512?DICTID:TYPE,hold=0,bits=0;break;case FLAGS:for(;bits<16;){if(have===0)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}if(state.flags=hold,(state.flags&255)!==Z_DEFLATED){strm.msg=`unknown compression method`,state.mode=BAD;break}if(state.flags&57344){strm.msg=`unknown header flags set`,state.mode=BAD;break}state.head&&(state.head.text=hold>>8&1),state.flags&512&&state.wrap&4&&(hbuf[0]=hold&255,hbuf[1]=hold>>>8&255,state.check=crc32_1(state.check,hbuf,2,0)),hold=0,bits=0,state.mode=TIME;case TIME:for(;bits<32;){if(have===0)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}state.head&&(state.head.time=hold),state.flags&512&&state.wrap&4&&(hbuf[0]=hold&255,hbuf[1]=hold>>>8&255,hbuf[2]=hold>>>16&255,hbuf[3]=hold>>>24&255,state.check=crc32_1(state.check,hbuf,4,0)),hold=0,bits=0,state.mode=OS;case OS:for(;bits<16;){if(have===0)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}state.head&&(state.head.xflags=hold&255,state.head.os=hold>>8),state.flags&512&&state.wrap&4&&(hbuf[0]=hold&255,hbuf[1]=hold>>>8&255,state.check=crc32_1(state.check,hbuf,2,0)),hold=0,bits=0,state.mode=EXLEN;case EXLEN:if(state.flags&1024){for(;bits<16;){if(have===0)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}state.length=hold,state.head&&(state.head.extra_len=hold),state.flags&512&&state.wrap&4&&(hbuf[0]=hold&255,hbuf[1]=hold>>>8&255,state.check=crc32_1(state.check,hbuf,2,0)),hold=0,bits=0}else state.head&&(state.head.extra=null);state.mode=EXTRA;case EXTRA:if(state.flags&1024&&(copy=state.length,copy>have&&(copy=have),copy&&(state.head&&(len=state.head.extra_len-state.length,state.head.extra||(state.head.extra=new Uint8Array(state.head.extra_len)),state.head.extra.set(input.subarray(next,next+copy),len)),state.flags&512&&state.wrap&4&&(state.check=crc32_1(state.check,input,copy,next)),have-=copy,next+=copy,state.length-=copy),state.length))break inf_leave;state.length=0,state.mode=NAME;case NAME:if(state.flags&2048){if(have===0)break inf_leave;copy=0;do len=input[next+ copy++],state.head&&len&&state.length<65536&&(state.head.name+=String.fromCharCode(len));while(len&&copy<have);if(state.flags&512&&state.wrap&4&&(state.check=crc32_1(state.check,input,copy,next)),have-=copy,next+=copy,len)break inf_leave}else state.head&&(state.head.name=null);state.length=0,state.mode=COMMENT;case COMMENT:if(state.flags&4096){if(have===0)break inf_leave;copy=0;do len=input[next+ copy++],state.head&&len&&state.length<65536&&(state.head.comment+=String.fromCharCode(len));while(len&&copy<have);if(state.flags&512&&state.wrap&4&&(state.check=crc32_1(state.check,input,copy,next)),have-=copy,next+=copy,len)break inf_leave}else state.head&&(state.head.comment=null);state.mode=HCRC;case HCRC:if(state.flags&512){for(;bits<16;){if(have===0)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}if(state.wrap&4&&hold!==(state.check&65535)){strm.msg=`header crc mismatch`,state.mode=BAD;break}hold=0,bits=0}state.head&&(state.head.hcrc=state.flags>>9&1,state.head.done=!0),strm.adler=state.check=0,state.mode=TYPE;break;case DICTID:for(;bits<32;){if(have===0)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}strm.adler=state.check=zswap32(hold),hold=0,bits=0,state.mode=DICT;case DICT:if(state.havedict===0)return strm.next_out=put,strm.avail_out=left,strm.next_in=next,strm.avail_in=have,state.hold=hold,state.bits=bits,Z_NEED_DICT$1;strm.adler=state.check=1,state.mode=TYPE;case TYPE:if(flush===Z_BLOCK||flush===Z_TREES)break inf_leave;case TYPEDO:if(state.last){hold>>>=bits&7,bits-=bits&7,state.mode=CHECK;break}for(;bits<3;){if(have===0)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}switch(state.last=hold&1,hold>>>=1,--bits,hold&3){case 0:state.mode=STORED;break;case 1:if(fixedtables(state),state.mode=LEN_,flush===Z_TREES){hold>>>=2,bits-=2;break inf_leave}break;case 2:state.mode=TABLE;break;case 3:strm.msg=`invalid block type`,state.mode=BAD}hold>>>=2,bits-=2;break;case STORED:for(hold>>>=bits&7,bits-=bits&7;bits<32;){if(have===0)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}if((hold&65535)!=(hold>>>16^65535)){strm.msg=`invalid stored block lengths`,state.mode=BAD;break}if(state.length=hold&65535,hold=0,bits=0,state.mode=COPY_,flush===Z_TREES)break inf_leave;case COPY_:state.mode=COPY;case COPY:if(copy=state.length,copy){if(copy>have&&(copy=have),copy>left&&(copy=left),copy===0)break inf_leave;output.set(input.subarray(next,next+copy),put),have-=copy,next+=copy,left-=copy,put+=copy,state.length-=copy;break}state.mode=TYPE;break;case TABLE:for(;bits<14;){if(have===0)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}if(state.nlen=(hold&31)+257,hold>>>=5,bits-=5,state.ndist=(hold&31)+1,hold>>>=5,bits-=5,state.ncode=(hold&15)+4,hold>>>=4,bits-=4,state.nlen>286||state.ndist>30){strm.msg=`too many length or distance symbols`,state.mode=BAD;break}state.have=0,state.mode=LENLENS;case LENLENS:for(;state.have<state.ncode;){for(;bits<3;){if(have===0)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}state.lens[order[state.have++]]=hold&7,hold>>>=3,bits-=3}for(;state.have<19;)state.lens[order[state.have++]]=0;if(state.lencode=state.lendyn,state.lenbits=7,opts={bits:state.lenbits},ret=inftrees(CODES,state.lens,0,19,state.lencode,0,state.work,opts),state.lenbits=opts.bits,ret){strm.msg=`invalid code lengths set`,state.mode=BAD;break}state.have=0,state.mode=CODELENS;case CODELENS:for(;state.have<state.nlen+state.ndist;){for(;here=state.lencode[hold&(1<<state.lenbits)-1],here_bits=here>>>24,here_op=here>>>16&255,here_val=here&65535,!(here_bits<=bits);){if(have===0)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}if(here_val<16)hold>>>=here_bits,bits-=here_bits,state.lens[state.have++]=here_val;else{if(here_val===16){for(n$3=here_bits+2;bits<n$3;){if(have===0)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}if(hold>>>=here_bits,bits-=here_bits,state.have===0){strm.msg=`invalid bit length repeat`,state.mode=BAD;break}len=state.lens[state.have-1],copy=3+(hold&3),hold>>>=2,bits-=2}else if(here_val===17){for(n$3=here_bits+3;bits<n$3;){if(have===0)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}hold>>>=here_bits,bits-=here_bits,len=0,copy=3+(hold&7),hold>>>=3,bits-=3}else{for(n$3=here_bits+7;bits<n$3;){if(have===0)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}hold>>>=here_bits,bits-=here_bits,len=0,copy=11+(hold&127),hold>>>=7,bits-=7}if(state.have+copy>state.nlen+state.ndist){strm.msg=`invalid bit length repeat`,state.mode=BAD;break}for(;copy--;)state.lens[state.have++]=len}}if(state.mode===BAD)break;if(state.lens[256]===0){strm.msg=`invalid code -- missing end-of-block`,state.mode=BAD;break}if(state.lenbits=9,opts={bits:state.lenbits},ret=inftrees(LENS,state.lens,0,state.nlen,state.lencode,0,state.work,opts),state.lenbits=opts.bits,ret){strm.msg=`invalid literal/lengths set`,state.mode=BAD;break}if(state.distbits=6,state.distcode=state.distdyn,opts={bits:state.distbits},ret=inftrees(DISTS,state.lens,state.nlen,state.ndist,state.distcode,0,state.work,opts),state.distbits=opts.bits,ret){strm.msg=`invalid distances set`,state.mode=BAD;break}if(state.mode=LEN_,flush===Z_TREES)break inf_leave;case LEN_:state.mode=LEN;case LEN:if(have>=6&&left>=258){strm.next_out=put,strm.avail_out=left,strm.next_in=next,strm.avail_in=have,state.hold=hold,state.bits=bits,inffast(strm,_out),put=strm.next_out,output=strm.output,left=strm.avail_out,next=strm.next_in,input=strm.input,have=strm.avail_in,hold=state.hold,bits=state.bits,state.mode===TYPE&&(state.back=-1);break}for(state.back=0;here=state.lencode[hold&(1<<state.lenbits)-1],here_bits=here>>>24,here_op=here>>>16&255,here_val=here&65535,!(here_bits<=bits);){if(have===0)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}if(here_op&&!(here_op&240)){for(last_bits=here_bits,last_op=here_op,last_val=here_val;here=state.lencode[last_val+((hold&(1<<last_bits+last_op)-1)>>last_bits)],here_bits=here>>>24,here_op=here>>>16&255,here_val=here&65535,!(last_bits+here_bits<=bits);){if(have===0)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}hold>>>=last_bits,bits-=last_bits,state.back+=last_bits}if(hold>>>=here_bits,bits-=here_bits,state.back+=here_bits,state.length=here_val,here_op===0){state.mode=LIT;break}if(here_op&32){state.back=-1,state.mode=TYPE;break}if(here_op&64){strm.msg=`invalid literal/length code`,state.mode=BAD;break}state.extra=here_op&15,state.mode=LENEXT;case LENEXT:if(state.extra){for(n$3=state.extra;bits<n$3;){if(have===0)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}state.length+=hold&(1<<state.extra)-1,hold>>>=state.extra,bits-=state.extra,state.back+=state.extra}state.was=state.length,state.mode=DIST;case DIST:for(;here=state.distcode[hold&(1<<state.distbits)-1],here_bits=here>>>24,here_op=here>>>16&255,here_val=here&65535,!(here_bits<=bits);){if(have===0)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}if(!(here_op&240)){for(last_bits=here_bits,last_op=here_op,last_val=here_val;here=state.distcode[last_val+((hold&(1<<last_bits+last_op)-1)>>last_bits)],here_bits=here>>>24,here_op=here>>>16&255,here_val=here&65535,!(last_bits+here_bits<=bits);){if(have===0)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}hold>>>=last_bits,bits-=last_bits,state.back+=last_bits}if(hold>>>=here_bits,bits-=here_bits,state.back+=here_bits,here_op&64){strm.msg=`invalid distance code`,state.mode=BAD;break}state.offset=here_val,state.extra=here_op&15,state.mode=DISTEXT;case DISTEXT:if(state.extra){for(n$3=state.extra;bits<n$3;){if(have===0)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}state.offset+=hold&(1<<state.extra)-1,hold>>>=state.extra,bits-=state.extra,state.back+=state.extra}if(state.offset>state.dmax){strm.msg=`invalid distance too far back`,state.mode=BAD;break}state.mode=MATCH;case MATCH:if(left===0)break inf_leave;if(copy=_out-left,state.offset>copy){if(copy=state.offset-copy,copy>state.whave&&state.sane){strm.msg=`invalid distance too far back`,state.mode=BAD;break}copy>state.wnext?(copy-=state.wnext,from=state.wsize-copy):from=state.wnext-copy,copy>state.length&&(copy=state.length),from_source=state.window}else from_source=output,from=put-state.offset,copy=state.length;copy>left&&(copy=left),left-=copy,state.length-=copy;do output[put++]=from_source[from++];while(--copy);state.length===0&&(state.mode=LEN);break;case LIT:if(left===0)break inf_leave;output[put++]=state.length,left--,state.mode=LEN;break;case CHECK:if(state.wrap){for(;bits<32;){if(have===0)break inf_leave;have--,hold|=input[next++]<<bits,bits+=8}if(_out-=left,strm.total_out+=_out,state.total+=_out,state.wrap&4&&_out&&(strm.adler=state.check=state.flags?crc32_1(state.check,output,_out,put-_out):adler32_1(state.check,output,_out,put-_out)),_out=left,state.wrap&4&&(state.flags?hold:zswap32(hold))!==state.check){strm.msg=`incorrect data check`,state.mode=BAD;break}hold=0,bits=0}state.mode=LENGTH;case LENGTH:if(state.wrap&&state.flags){for(;bits<32;){if(have===0)break inf_leave;have--,hold+=input[next++]<<bits,bits+=8}if(state.wrap&4&&hold!==(state.total&4294967295)){strm.msg=`incorrect length check`,state.mode=BAD;break}hold=0,bits=0}state.mode=DONE;case DONE:ret=Z_STREAM_END$1;break inf_leave;case BAD:ret=Z_DATA_ERROR$1;break inf_leave;case MEM:return Z_MEM_ERROR$1;case SYNC:default:return Z_STREAM_ERROR$1}return strm.next_out=put,strm.avail_out=left,strm.next_in=next,strm.avail_in=have,state.hold=hold,state.bits=bits,(state.wsize||_out!==strm.avail_out&&state.mode<BAD&&(state.mode<CHECK||flush!==Z_FINISH$1))&&updatewindow(strm,strm.output,strm.next_out,_out-strm.avail_out),_in-=strm.avail_in,_out-=strm.avail_out,strm.total_in+=_in,strm.total_out+=_out,state.total+=_out,state.wrap&4&&_out&&(strm.adler=state.check=state.flags?crc32_1(state.check,output,_out,strm.next_out-_out):adler32_1(state.check,output,_out,strm.next_out-_out)),strm.data_type=state.bits+(state.last?64:0)+(state.mode===TYPE?128:0)+(state.mode===LEN_||state.mode===COPY_?256:0),(_in===0&&_out===0||flush===Z_FINISH$1)&&ret===Z_OK$1&&(ret=Z_BUF_ERROR),ret},inflateEnd:strm=>{if(inflateStateCheck(strm))return Z_STREAM_ERROR$1;let state=strm.state;return state.window&&=null,strm.state=null,Z_OK$1},inflateGetHeader:(strm,head)=>{if(inflateStateCheck(strm))return Z_STREAM_ERROR$1;let state=strm.state;return state.wrap&2?(state.head=head,head.done=!1,Z_OK$1):Z_STREAM_ERROR$1},inflateSetDictionary:(strm,dictionary)=>{let dictLength=dictionary.length,state,dictid,ret;return inflateStateCheck(strm)||(state=strm.state,state.wrap!==0&&state.mode!==DICT)?Z_STREAM_ERROR$1:state.mode===DICT&&(dictid=1,dictid=adler32_1(dictid,dictionary,dictLength,0),dictid!==state.check)?Z_DATA_ERROR$1:(ret=updatewindow(strm,dictionary,dictLength,dictLength),ret?(state.mode=MEM,Z_MEM_ERROR$1):(state.havedict=1,Z_OK$1))},inflateInfo:`pako inflate (from Nodeca project)`};function GZheader(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name=``,this.comment=``,this.hcrc=0,this.done=!1}var gzheader=GZheader,toString=Object.prototype.toString,{Z_NO_FLUSH,Z_FINISH,Z_OK,Z_STREAM_END,Z_NEED_DICT,Z_STREAM_ERROR,Z_DATA_ERROR,Z_MEM_ERROR}=constants$2;function Inflate$1(options){this.options=common.assign({chunkSize:1024*64,windowBits:15,to:``},options||{});let opt=this.options;opt.raw&&opt.windowBits>=0&&opt.windowBits<16&&(opt.windowBits=-opt.windowBits,opt.windowBits===0&&(opt.windowBits=-15)),opt.windowBits>=0&&opt.windowBits<16&&!(options&&options.windowBits)&&(opt.windowBits+=32),opt.windowBits>15&&opt.windowBits<48&&(opt.windowBits&15||(opt.windowBits|=15)),this.err=0,this.msg=``,this.ended=!1,this.chunks=[],this.strm=new zstream,this.strm.avail_out=0;let status=inflate_1$2.inflateInit2(this.strm,opt.windowBits);if(status!==Z_OK||(this.header=new gzheader,inflate_1$2.inflateGetHeader(this.strm,this.header),opt.dictionary&&(typeof opt.dictionary==`string`?opt.dictionary=strings.string2buf(opt.dictionary):toString.call(opt.dictionary)===`[object ArrayBuffer]`&&(opt.dictionary=new Uint8Array(opt.dictionary)),opt.raw&&(status=inflate_1$2.inflateSetDictionary(this.strm,opt.dictionary),status!==Z_OK))))throw Error(messages[status])}Inflate$1.prototype.push=function(data,flush_mode){let strm=this.strm,chunkSize=this.options.chunkSize,dictionary=this.options.dictionary,status,_flush_mode,last_avail_out;if(this.ended)return!1;for(_flush_mode=flush_mode===~~flush_mode?flush_mode:flush_mode===!0?Z_FINISH:Z_NO_FLUSH,toString.call(data)===`[object ArrayBuffer]`?strm.input=new Uint8Array(data):strm.input=data,strm.next_in=0,strm.avail_in=strm.input.length;;){for(strm.avail_out===0&&(strm.output=new Uint8Array(chunkSize),strm.next_out=0,strm.avail_out=chunkSize),status=inflate_1$2.inflate(strm,_flush_mode),status===Z_NEED_DICT&&dictionary&&(status=inflate_1$2.inflateSetDictionary(strm,dictionary),status===Z_OK?status=inflate_1$2.inflate(strm,_flush_mode):status===Z_DATA_ERROR&&(status=Z_NEED_DICT));strm.avail_in>0&&status===Z_STREAM_END&&strm.state.wrap>0&&data[strm.next_in]!==0;)inflate_1$2.inflateReset(strm),status=inflate_1$2.inflate(strm,_flush_mode);switch(status){case Z_STREAM_ERROR:case Z_DATA_ERROR:case Z_NEED_DICT:case Z_MEM_ERROR:return this.onEnd(status),this.ended=!0,!1}if(last_avail_out=strm.avail_out,strm.next_out&&(strm.avail_out===0||status===Z_STREAM_END))if(this.options.to===`string`){let next_out_utf8=strings.utf8border(strm.output,strm.next_out),tail=strm.next_out-next_out_utf8,utf8str=strings.buf2string(strm.output,next_out_utf8);strm.next_out=tail,strm.avail_out=chunkSize-tail,tail&&strm.output.set(strm.output.subarray(next_out_utf8,next_out_utf8+tail),0),this.onData(utf8str)}else this.onData(strm.output.length===strm.next_out?strm.output:strm.output.subarray(0,strm.next_out));if(!(status===Z_OK&&last_avail_out===0)){if(status===Z_STREAM_END)return status=inflate_1$2.inflateEnd(this.strm),this.onEnd(status),this.ended=!0,!0;if(strm.avail_in===0)break}}return!0},Inflate$1.prototype.onData=function(chunk){this.chunks.push(chunk)},Inflate$1.prototype.onEnd=function(status){status===Z_OK&&(this.options.to===`string`?this.result=this.chunks.join(``):this.result=common.flattenChunks(this.chunks)),this.chunks=[],this.err=status,this.msg=this.strm.msg};function inflate$1(input,options){let inflator=new Inflate$1(options);if(inflator.push(input),inflator.err)throw inflator.msg||messages[inflator.err];return inflator.result}function inflateRaw$1(input,options){return options||={},options.raw=!0,inflate$1(input,options)}var inflate_1$1={Inflate:Inflate$1,inflate:inflate$1,inflateRaw:inflateRaw$1,ungzip:inflate$1,constants:constants$2},{Deflate,deflate,deflateRaw,gzip}=deflate_1$1,{Inflate,inflate,inflateRaw,ungzip}=inflate_1$1,crcTable=[];for(let n$3=0;n$3<256;n$3++){let c$2=n$3;for(let k$2=0;k$2<8;k$2++)c$2&1?c$2=3988292384^c$2>>>1:c$2>>>=1;crcTable[n$3]=c$2}var uint16$1=new Uint16Array([255]),osIsLittleEndian$1=new Uint8Array(uint16$1.buffer)[0]===255,uint16=new Uint16Array([255]),osIsLittleEndian=new Uint8Array(uint16.buffer)[0]===255,empty=new Uint8Array,pngSignature=Uint8Array.of(137,80,78,71,13,10,26,10),latin1Decoder=new TextDecoder(`latin1`),base64codes$1=Uint8Array.from([255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,62,255,255,255,63,52,53,54,55,56,57,58,59,60,61,255,255,255,0,255,255,255,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,255,255,255,255,255,255,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51]);const base64codes=Uint8Array.from([65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,48,49,50,51,52,53,54,55,56,57,43,47]);var base64codes1=new Uint32Array(4096);for(let i$3=0;i$3<64;i$3++)for(let j$2=0;j$2<64;j$2++){let index=i$3<<2|(j$2&48)>>4|(j$2&15)<<8;base64codes1[index]=base64codes[i$3]|base64codes[j$2]<<8}var base64codes2=new Uint32Array(4096);for(let i$3=0;i$3<64;i$3++)for(let j$2=0;j$2<64;j$2++){let index=i$3<<6|j$2;base64codes2[index]=base64codes[i$3]<<16|base64codes[j$2]<<24}var require_file_type=__commonJSMin(((exports,module)=>{var toBytes=s$2=>[...s$2].map(c$2=>c$2.charCodeAt(0)),xpiZipFilename=toBytes(`META-INF/mozilla.rsa`),oxmlContentTypes=toBytes(`[Content_Types].xml`),oxmlRels=toBytes(`_rels/.rels`);function readUInt64LE(buf,offset=0){let n$3=buf[offset],mul=1,i$3=0;for(;++i$3<8;)mul*=256,n$3+=buf[offset+i$3]*mul;return n$3}var fileType$1=input=>{if(!(input instanceof Uint8Array||input instanceof ArrayBuffer||Buffer.isBuffer(input)))throw TypeError(`Expected the \`input\` argument to be of type \`Uint8Array\` or \`Buffer\` or \`ArrayBuffer\`, got \`${typeof input}\``);let buf=input instanceof Uint8Array?input:new Uint8Array(input);if(!(buf&&buf.length>1))return null;let check=(header,options)=>{options=Object.assign({offset:0},options);for(let i$3=0;i$3<header.length;i$3++)if(options.mask){if(header[i$3]!==(options.mask[i$3]&buf[i$3+options.offset]))return!1}else if(header[i$3]!==buf[i$3+options.offset])return!1;return!0},checkString=(header,options)=>check(toBytes(header),options);if(check([255,216,255]))return{ext:`jpg`,mime:`image/jpeg`};if(check([137,80,78,71,13,10,26,10]))return{ext:`png`,mime:`image/png`};if(check([71,73,70]))return{ext:`gif`,mime:`image/gif`};if(check([87,69,66,80],{offset:8}))return{ext:`webp`,mime:`image/webp`};if(check([70,76,73,70]))return{ext:`flif`,mime:`image/flif`};if((check([73,73,42,0])||check([77,77,0,42]))&&check([67,82],{offset:8}))return{ext:`cr2`,mime:`image/x-canon-cr2`};if(check([73,73,42,0])||check([77,77,0,42]))return{ext:`tif`,mime:`image/tiff`};if(check([66,77]))return{ext:`bmp`,mime:`image/bmp`};if(check([73,73,188]))return{ext:`jxr`,mime:`image/vnd.ms-photo`};if(check([56,66,80,83]))return{ext:`psd`,mime:`image/vnd.adobe.photoshop`};if(check([80,75,3,4])){if(check([109,105,109,101,116,121,112,101,97,112,112,108,105,99,97,116,105,111,110,47,101,112,117,98,43,122,105,112],{offset:30}))return{ext:`epub`,mime:`application/epub+zip`};if(check(xpiZipFilename,{offset:30}))return{ext:`xpi`,mime:`application/x-xpinstall`};if(checkString(`mimetypeapplication/vnd.oasis.opendocument.text`,{offset:30}))return{ext:`odt`,mime:`application/vnd.oasis.opendocument.text`};if(checkString(`mimetypeapplication/vnd.oasis.opendocument.spreadsheet`,{offset:30}))return{ext:`ods`,mime:`application/vnd.oasis.opendocument.spreadsheet`};if(checkString(`mimetypeapplication/vnd.oasis.opendocument.presentation`,{offset:30}))return{ext:`odp`,mime:`application/vnd.oasis.opendocument.presentation`};let findNextZipHeaderIndex=(arr,startAt=0)=>arr.findIndex((el,i$3,arr$1)=>i$3>=startAt&&arr$1[i$3]===80&&arr$1[i$3+1]===75&&arr$1[i$3+2]===3&&arr$1[i$3+3]===4),zipHeaderIndex=0,oxmlFound=!1,type=null;do{let offset=zipHeaderIndex+30;if(oxmlFound||=check(oxmlContentTypes,{offset})||check(oxmlRels,{offset}),type||(checkString(`word/`,{offset})?type={ext:`docx`,mime:`application/vnd.openxmlformats-officedocument.wordprocessingml.document`}:checkString(`ppt/`,{offset})?type={ext:`pptx`,mime:`application/vnd.openxmlformats-officedocument.presentationml.presentation`}:checkString(`xl/`,{offset})&&(type={ext:`xlsx`,mime:`application/vnd.openxmlformats-officedocument.spreadsheetml.sheet`})),oxmlFound&&type)return type;zipHeaderIndex=findNextZipHeaderIndex(buf,offset)}while(zipHeaderIndex>=0);if(type)return type}if(check([80,75])&&(buf[2]===3||buf[2]===5||buf[2]===7)&&(buf[3]===4||buf[3]===6||buf[3]===8))return{ext:`zip`,mime:`application/zip`};if(check([117,115,116,97,114],{offset:257}))return{ext:`tar`,mime:`application/x-tar`};if(check([82,97,114,33,26,7])&&(buf[6]===0||buf[6]===1))return{ext:`rar`,mime:`application/x-rar-compressed`};if(check([31,139,8]))return{ext:`gz`,mime:`application/gzip`};if(check([66,90,104]))return{ext:`bz2`,mime:`application/x-bzip2`};if(check([55,122,188,175,39,28]))return{ext:`7z`,mime:`application/x-7z-compressed`};if(check([120,1]))return{ext:`dmg`,mime:`application/x-apple-diskimage`};if(check([51,103,112,53])||check([0,0,0])&&check([102,116,121,112],{offset:4})&&(check([109,112,52,49],{offset:8})||check([109,112,52,50],{offset:8})||check([105,115,111,109],{offset:8})||check([105,115,111,50],{offset:8})||check([109,109,112,52],{offset:8})||check([77,52,86],{offset:8})||check([100,97,115,104],{offset:8})))return{ext:`mp4`,mime:`video/mp4`};if(check([77,84,104,100]))return{ext:`mid`,mime:`audio/midi`};if(check([26,69,223,163])){let sliced=buf.subarray(4,4100),idPos=sliced.findIndex((el,i$3,arr)=>arr[i$3]===66&&arr[i$3+1]===130);if(idPos!==-1){let docTypePos=idPos+3,findDocType=type=>[...type].every((c$2,i$3)=>sliced[docTypePos+i$3]===c$2.charCodeAt(0));if(findDocType(`matroska`))return{ext:`mkv`,mime:`video/x-matroska`};if(findDocType(`webm`))return{ext:`webm`,mime:`video/webm`}}}if(check([0,0,0,20,102,116,121,112,113,116,32,32])||check([102,114,101,101],{offset:4})||check([102,116,121,112,113,116,32,32],{offset:4})||check([109,100,97,116],{offset:4})||check([109,111,111,118],{offset:4})||check([119,105,100,101],{offset:4}))return{ext:`mov`,mime:`video/quicktime`};if(check([82,73,70,70])){if(check([65,86,73],{offset:8}))return{ext:`avi`,mime:`video/vnd.avi`};if(check([87,65,86,69],{offset:8}))return{ext:`wav`,mime:`audio/vnd.wave`};if(check([81,76,67,77],{offset:8}))return{ext:`qcp`,mime:`audio/qcelp`}}if(check([48,38,178,117,142,102,207,17,166,217])){let offset=30;do{let objectSize=readUInt64LE(buf,offset+16);if(check([145,7,220,183,183,169,207,17,142,230,0,192,12,32,83,101],{offset})){if(check([64,158,105,248,77,91,207,17,168,253,0,128,95,92,68,43],{offset:offset+24}))return{ext:`wma`,mime:`audio/x-ms-wma`};if(check([192,239,25,188,77,91,207,17,168,253,0,128,95,92,68,43],{offset:offset+24}))return{ext:`wmv`,mime:`video/x-ms-asf`};break}offset+=objectSize}while(offset+24<=buf.length);return{ext:`asf`,mime:`application/vnd.ms-asf`}}if(check([0,0,1,186])||check([0,0,1,179]))return{ext:`mpg`,mime:`video/mpeg`};if(check([102,116,121,112,51,103],{offset:4}))return{ext:`3gp`,mime:`video/3gpp`};for(let start=0;start<2&&start<buf.length-16;start++){if(check([73,68,51],{offset:start})||check([255,226],{offset:start,mask:[255,226]}))return{ext:`mp3`,mime:`audio/mpeg`};if(check([255,228],{offset:start,mask:[255,228]})||check([255,248],{offset:start,mask:[255,252]}))return{ext:`mp2`,mime:`audio/mpeg`};if(check([255,240],{offset:start,mask:[255,252]}))return{ext:`mp4`,mime:`audio/mpeg`}}if(check([102,116,121,112,77,52,65],{offset:4}))return{ext:`m4a`,mime:`audio/mp4`};if(check([79,112,117,115,72,101,97,100],{offset:28}))return{ext:`opus`,mime:`audio/opus`};if(check([79,103,103,83]))return check([128,116,104,101,111,114,97],{offset:28})?{ext:`ogv`,mime:`video/ogg`}:check([1,118,105,100,101,111,0],{offset:28})?{ext:`ogm`,mime:`video/ogg`}:check([127,70,76,65,67],{offset:28})?{ext:`oga`,mime:`audio/ogg`}:check([83,112,101,101,120,32,32],{offset:28})?{ext:`spx`,mime:`audio/ogg`}:check([1,118,111,114,98,105,115],{offset:28})?{ext:`ogg`,mime:`audio/ogg`}:{ext:`ogx`,mime:`application/ogg`};if(check([102,76,97,67]))return{ext:`flac`,mime:`audio/x-flac`};if(check([77,65,67,32]))return{ext:`ape`,mime:`audio/ape`};if(check([119,118,112,107]))return{ext:`wv`,mime:`audio/wavpack`};if(check([35,33,65,77,82,10]))return{ext:`amr`,mime:`audio/amr`};if(check([37,80,68,70]))return{ext:`pdf`,mime:`application/pdf`};if(check([77,90]))return{ext:`exe`,mime:`application/x-msdownload`};if((buf[0]===67||buf[0]===70)&&check([87,83],{offset:1}))return{ext:`swf`,mime:`application/x-shockwave-flash`};if(check([123,92,114,116,102]))return{ext:`rtf`,mime:`application/rtf`};if(check([0,97,115,109]))return{ext:`wasm`,mime:`application/wasm`};if(check([119,79,70,70])&&(check([0,1,0,0],{offset:4})||check([79,84,84,79],{offset:4})))return{ext:`woff`,mime:`font/woff`};if(check([119,79,70,50])&&(check([0,1,0,0],{offset:4})||check([79,84,84,79],{offset:4})))return{ext:`woff2`,mime:`font/woff2`};if(check([76,80],{offset:34})&&(check([0,0,1],{offset:8})||check([1,0,2],{offset:8})||check([2,0,2],{offset:8})))return{ext:`eot`,mime:`application/vnd.ms-fontobject`};if(check([0,1,0,0,0]))return{ext:`ttf`,mime:`font/ttf`};if(check([79,84,84,79,0]))return{ext:`otf`,mime:`font/otf`};if(check([0,0,1,0]))return{ext:`ico`,mime:`image/x-icon`};if(check([0,0,2,0]))return{ext:`cur`,mime:`image/x-icon`};if(check([70,76,86,1]))return{ext:`flv`,mime:`video/x-flv`};if(check([37,33]))return{ext:`ps`,mime:`application/postscript`};if(check([253,55,122,88,90,0]))return{ext:`xz`,mime:`application/x-xz`};if(check([83,81,76,105]))return{ext:`sqlite`,mime:`application/x-sqlite3`};if(check([78,69,83,26]))return{ext:`nes`,mime:`application/x-nintendo-nes-rom`};if(check([67,114,50,52]))return{ext:`crx`,mime:`application/x-google-chrome-extension`};if(check([77,83,67,70])||check([73,83,99,40]))return{ext:`cab`,mime:`application/vnd.ms-cab-compressed`};if(check([33,60,97,114,99,104,62,10,100,101,98,105,97,110,45,98,105,110,97,114,121]))return{ext:`deb`,mime:`application/x-deb`};if(check([33,60,97,114,99,104,62]))return{ext:`ar`,mime:`application/x-unix-archive`};if(check([237,171,238,219]))return{ext:`rpm`,mime:`application/x-rpm`};if(check([31,160])||check([31,157]))return{ext:`Z`,mime:`application/x-compress`};if(check([76,90,73,80]))return{ext:`lz`,mime:`application/x-lzip`};if(check([208,207,17,224,161,177,26,225]))return{ext:`msi`,mime:`application/x-msi`};if(check([6,14,43,52,2,5,1,1,13,1,2,1,1,2]))return{ext:`mxf`,mime:`application/mxf`};if(check([71],{offset:4})&&(check([71],{offset:192})||check([71],{offset:196})))return{ext:`mts`,mime:`video/mp2t`};if(check([66,76,69,78,68,69,82]))return{ext:`blend`,mime:`application/x-blender`};if(check([66,80,71,251]))return{ext:`bpg`,mime:`image/bpg`};if(check([0,0,0,12,106,80,32,32,13,10,135,10])){if(check([106,112,50,32],{offset:20}))return{ext:`jp2`,mime:`image/jp2`};if(check([106,112,120,32],{offset:20}))return{ext:`jpx`,mime:`image/jpx`};if(check([106,112,109,32],{offset:20}))return{ext:`jpm`,mime:`image/jpm`};if(check([109,106,112,50],{offset:20}))return{ext:`mj2`,mime:`image/mj2`}}if(check([70,79,82,77]))return{ext:`aif`,mime:`audio/aiff`};if(checkString(`<?xml `))return{ext:`xml`,mime:`application/xml`};if(check([66,79,79,75,77,79,66,73],{offset:60}))return{ext:`mobi`,mime:`application/x-mobipocket-ebook`};if(check([102,116,121,112],{offset:4})){if(check([109,105,102,49],{offset:8}))return{ext:`heic`,mime:`image/heif`};if(check([109,115,102,49],{offset:8}))return{ext:`heic`,mime:`image/heif-sequence`};if(check([104,101,105,99],{offset:8})||check([104,101,105,120],{offset:8}))return{ext:`heic`,mime:`image/heic`};if(check([104,101,118,99],{offset:8})||check([104,101,118,120],{offset:8}))return{ext:`heic`,mime:`image/heic-sequence`}}return check([171,75,84,88,32,49,49,187,13,10,26,10])?{ext:`ktx`,mime:`image/ktx`}:check([68,73,67,77],{offset:128})?{ext:`dcm`,mime:`application/dicom`}:check([77,80,43])||check([77,80,67,75])?{ext:`mpc`,mime:`audio/x-musepack`}:check([66,69,71,73,78,58])?{ext:`ics`,mime:`text/calendar`}:check([103,108,84,70,2,0,0,0])?{ext:`glb`,mime:`model/gltf-binary`}:check([212,195,178,161])||check([161,178,195,212])?{ext:`pcap`,mime:`application/vnd.tcpdump.pcap`}:null};module.exports=fileType$1,module.exports.default=fileType$1,Object.defineProperty(fileType$1,`minimumBytes`,{value:4100}),module.exports.stream=readableStream=>new Promise((resolve,reject)=>{let stream=eval(`require`)(`stream`);readableStream.once(`readable`,()=>{let pass=new stream.PassThrough,chunk=readableStream.read(module.exports.minimumBytes)||readableStream.read();try{pass.fileType=fileType$1(chunk)}catch(error){reject(error)}readableStream.unshift(chunk),stream.pipeline?resolve(stream.pipeline(readableStream,pass,()=>{})):resolve(readableStream.pipe(pass))})})})),require_image_type=__commonJSMin(((exports,module)=>{var fileType=require_file_type(),imageExts=new Set([`jpg`,`png`,`gif`,`webp`,`flif`,`cr2`,`tif`,`bmp`,`jxr`,`psd`,`ico`,`bpg`,`jp2`,`jpm`,`jpx`,`heic`,`cur`,`dcm`]),imageType$2=input=>{let ret=fileType(input);return imageExts.has(ret&&ret.ext)?ret:null};module.exports=imageType$2,module.exports.default=imageType$2,Object.defineProperty(imageType$2,`minimumBytes`,{value:fileType.minimumBytes})})),tagsById$2={33434:`ExposureTime`,33437:`FNumber`,34850:`ExposureProgram`,34852:`SpectralSensitivity`,34855:`ISOSpeedRatings`,34856:`OECF`,34864:`SensitivityType`,34865:`StandardOutputSensitivity`,34866:`RecommendedExposureIndex`,34867:`ISOSpeed`,34868:`ISOSpeedLatitudeyyy`,34869:`ISOSpeedLatitudezzz`,36864:`ExifVersion`,36867:`DateTimeOriginal`,36868:`DateTimeDigitized`,37121:`ComponentsConfiguration`,37122:`CompressedBitsPerPixel`,37377:`ShutterSpeedValue`,37378:`ApertureValue`,37379:`BrightnessValue`,37380:`ExposureBiasValue`,37381:`MaxApertureValue`,37382:`SubjectDistance`,37383:`MeteringMode`,37384:`LightSource`,37385:`Flash`,37386:`FocalLength`,37396:`SubjectArea`,37500:`MakerNote`,37510:`UserComment`,37520:`SubsecTime`,37521:`SubsecTimeOriginal`,37522:`SubsecTimeDigitized`,40960:`FlashpixVersion`,40961:`ColorSpace`,40962:`PixelXDimension`,40963:`PixelYDimension`,40964:`RelatedSoundFile`,41483:`FlashEnergy`,41484:`SpatialFrequencyResponse`,41486:`FocalPlaneXResolution`,41487:`FocalPlaneYResolution`,41488:`FocalPlaneResolutionUnit`,41492:`SubjectLocation`,41493:`ExposureIndex`,41495:`SensingMethod`,41728:`FileSource`,41729:`SceneType`,41730:`CFAPattern`,41985:`CustomRendered`,41986:`ExposureMode`,41987:`WhiteBalance`,41988:`DigitalZoomRatio`,41989:`FocalLengthIn35mmFilm`,41990:`SceneCaptureType`,41991:`GainControl`,41992:`Contrast`,41993:`Saturation`,41994:`Sharpness`,41995:`DeviceSettingDescription`,41996:`SubjectDistanceRange`,42016:`ImageUniqueID`,42032:`CameraOwnerName`,42033:`BodySerialNumber`,42034:`LensSpecification`,42035:`LensMake`,42036:`LensModel`,42037:`LensSerialNumber`,42240:`Gamma`},tagsByName$2={};for(let i$3 in tagsById$2)tagsByName$2[tagsById$2[i$3]]=Number(i$3);var tagsById$1={0:`GPSVersionID`,1:`GPSLatitudeRef`,2:`GPSLatitude`,3:`GPSLongitudeRef`,4:`GPSLongitude`,5:`GPSAltitudeRef`,6:`GPSAltitude`,7:`GPSTimeStamp`,8:`GPSSatellites`,9:`GPSStatus`,10:`GPSMeasureMode`,11:`GPSDOP`,12:`GPSSpeedRef`,13:`GPSSpeed`,14:`GPSTrackRef`,15:`GPSTrack`,16:`GPSImgDirectionRef`,17:`GPSImgDirection`,18:`GPSMapDatum`,19:`GPSDestLatitudeRef`,20:`GPSDestLatitude`,21:`GPSDestLongitudeRef`,22:`GPSDestLongitude`,23:`GPSDestBearingRef`,24:`GPSDestBearing`,25:`GPSDestDistanceRef`,26:`GPSDestDistance`,27:`GPSProcessingMethod`,28:`GPSAreaInformation`,29:`GPSDateStamp`,30:`GPSDifferential`,31:`GPSHPositioningError`},tagsByName$1={};for(let i$3 in tagsById$1)tagsByName$1[tagsById$1[i$3]]=Number(i$3);var tagsById={254:`NewSubfileType`,255:`SubfileType`,256:`ImageWidth`,257:`ImageLength`,258:`BitsPerSample`,259:`Compression`,262:`PhotometricInterpretation`,263:`Threshholding`,264:`CellWidth`,265:`CellLength`,266:`FillOrder`,270:`ImageDescription`,271:`Make`,272:`Model`,273:`StripOffsets`,274:`Orientation`,277:`SamplesPerPixel`,278:`RowsPerStrip`,279:`StripByteCounts`,280:`MinSampleValue`,281:`MaxSampleValue`,282:`XResolution`,283:`YResolution`,284:`PlanarConfiguration`,288:`FreeOffsets`,289:`FreeByteCounts`,290:`GrayResponseUnit`,291:`GrayResponseCurve`,296:`ResolutionUnit`,305:`Software`,306:`DateTime`,315:`Artist`,316:`HostComputer`,320:`ColorMap`,338:`ExtraSamples`,33432:`Copyright`,269:`DocumentName`,285:`PageName`,286:`XPosition`,287:`YPosition`,292:`T4Options`,293:`T6Options`,297:`PageNumber`,301:`TransferFunction`,317:`Predictor`,318:`WhitePoint`,319:`PrimaryChromaticities`,321:`HalftoneHints`,322:`TileWidth`,323:`TileLength`,324:`TileOffsets`,325:`TileByteCounts`,326:`BadFaxLines`,327:`CleanFaxData`,328:`ConsecutiveBadFaxLines`,330:`SubIFDs`,332:`InkSet`,333:`InkNames`,334:`NumberOfInks`,336:`DotRange`,337:`TargetPrinter`,339:`SampleFormat`,340:`SMinSampleValue`,341:`SMaxSampleValue`,342:`TransferRange`,343:`ClipPath`,344:`XClipPathUnits`,345:`YClipPathUnits`,346:`Indexed`,347:`JPEGTables`,351:`OPIProxy`,400:`GlobalParametersIFD`,401:`ProfileType`,402:`FaxProfile`,403:`CodingMethods`,404:`VersionYear`,405:`ModeNumber`,433:`Decode`,434:`DefaultImageColor`,512:`JPEGProc`,513:`JPEGInterchangeFormat`,514:`JPEGInterchangeFormatLength`,515:`JPEGRestartInterval`,517:`JPEGLosslessPredictors`,518:`JPEGPointTransforms`,519:`JPEGQTables`,520:`JPEGDCTables`,521:`JPEGACTables`,529:`YCbCrCoefficients`,530:`YCbCrSubSampling`,531:`YCbCrPositioning`,532:`ReferenceBlackWhite`,559:`StripRowCounts`,700:`XMP`,32781:`ImageID`,34732:`ImageLayer`,32932:`WangAnnotatio`,33445:`MDFileTag`,33446:`MDScalePixel`,33447:`MDColorTable`,33448:`MDLabName`,33449:`MDSampleInfo`,33450:`MDPrepDate`,33451:`MDPrepTime`,33452:`MDFileUnits`,33550:`ModelPixelScaleTag`,33723:`IPTC`,33918:`INGRPacketDataTag`,33919:`INGRFlagRegisters`,33920:`IrasBTransformationMatrix`,33922:`ModelTiepointTag`,34264:`ModelTransformationTag`,34377:`Photoshop`,34665:`ExifIFD`,34675:`ICCProfile`,34735:`GeoKeyDirectoryTag`,34736:`GeoDoubleParamsTag`,34737:`GeoAsciiParamsTag`,34853:`GPSIFD`,34908:`HylaFAXFaxRecvParams`,34909:`HylaFAXFaxSubAddress`,34910:`HylaFAXFaxRecvTime`,37724:`ImageSourceData`,40965:`InteroperabilityIFD`,42112:`GDAL_METADATA`,42113:`GDAL_NODATA`,50215:`OceScanjobDescription`,50216:`OceApplicationSelector`,50217:`OceIdentificationNumber`,50218:`OceImageLogicCharacteristics`,50706:`DNGVersion`,50707:`DNGBackwardVersion`,50708:`UniqueCameraModel`,50709:`LocalizedCameraModel`,50710:`CFAPlaneColor`,50711:`CFALayout`,50712:`LinearizationTable`,50713:`BlackLevelRepeatDim`,50714:`BlackLevel`,50715:`BlackLevelDeltaH`,50716:`BlackLevelDeltaV`,50717:`WhiteLevel`,50718:`DefaultScale`,50719:`DefaultCropOrigin`,50720:`DefaultCropSize`,50721:`ColorMatrix1`,50722:`ColorMatrix2`,50723:`CameraCalibration1`,50724:`CameraCalibration2`,50725:`ReductionMatrix1`,50726:`ReductionMatrix2`,50727:`AnalogBalance`,50728:`AsShotNeutral`,50729:`AsShotWhiteXY`,50730:`BaselineExposure`,50731:`BaselineNoise`,50732:`BaselineSharpness`,50733:`BayerGreenSplit`,50734:`LinearResponseLimit`,50735:`CameraSerialNumber`,50736:`LensInfo`,50737:`ChromaBlurRadius`,50738:`AntiAliasStrength`,50740:`DNGPrivateData`,50741:`MakerNoteSafety`,50778:`CalibrationIlluminant1`,50779:`CalibrationIlluminant2`,50780:`BestQualityScale`,50784:`AliasLayerMetadata`},tagsByName={};for(let i$3 in tagsById)tagsByName[tagsById[i$3]]=Number(i$3);var import_jpeg_js=__toESM(require_jpeg_js()),import_image_type$1=__toESM(require_image_type());function readCanvas(canvas){let ctx=canvas.getContext(`2d`);assert(ctx);let imageData=ctx.getImageData(0,0,canvas.width,canvas.height);return new Image(imageData.width,imageData.height,{data:new Uint8Array(imageData.data.buffer,imageData.data.byteOffset,imageData.data.byteLength),colorModel:`RGBA`})}function readImg(img){let canvas=document.createElement(`canvas`);canvas.width=img.width,canvas.height=img.height;let ctx=canvas.getContext(`2d`);return assert(ctx),ctx.drawImage(img,0,0),readCanvas(canvas)}var import_priority_queue=__toESM(__commonJSMin(((exports,module)=>{(function(f$1){if(typeof exports==`object`&&module!==void 0)module.exports=f$1();else if(typeof define==`function`&&define.amd)define([],f$1);else{var g$1=typeof window<`u`?window:typeof global<`u`?global:typeof self<`u`?self:this;g$1.PriorityQueue=f$1()}})(function(){return(function e$3(t$3,n$3,r$3){function s$2(o$4,u$2){if(!n$3[o$4]){if(!t$3[o$4]){var a$3=typeof __require==`function`&&__require;if(!u$2&&a$3)return a$3(o$4,!0);if(i$3)return i$3(o$4,!0);var f$1=Error(`Cannot find module '`+o$4+`'`);throw f$1.code=`MODULE_NOT_FOUND`,f$1}var l$2=n$3[o$4]={exports:{}};t$3[o$4][0].call(l$2.exports,function(e$4){var n$4=t$3[o$4][1][e$4];return s$2(n$4||e$4)},l$2,l$2.exports,e$3,t$3,n$3,r$3)}return n$3[o$4].exports}for(var i$3=typeof __require==`function`&&__require,o$3=0;o$3<r$3.length;o$3++)s$2(r$3[o$3]);return s$2})({1:[function(_dereq_,module$1,exports$1){var AbstractPriorityQueue,ArrayStrategy,BHeapStrategy,BinaryHeapStrategy,PriorityQueue$1,extend=function(child,parent){for(var key in parent)hasProp.call(parent,key)&&(child[key]=parent[key]);function ctor(){this.constructor=child}return ctor.prototype=parent.prototype,child.prototype=new ctor,child.__super__=parent.prototype,child},hasProp={}.hasOwnProperty;AbstractPriorityQueue=_dereq_(`./PriorityQueue/AbstractPriorityQueue`),ArrayStrategy=_dereq_(`./PriorityQueue/ArrayStrategy`),BinaryHeapStrategy=_dereq_(`./PriorityQueue/BinaryHeapStrategy`),BHeapStrategy=_dereq_(`./PriorityQueue/BHeapStrategy`),PriorityQueue$1=(function(superClass){extend(PriorityQueue$2,superClass);function PriorityQueue$2(options){options||={},options.strategy||=BinaryHeapStrategy,options.comparator||=function(a$3,b$3){return(a$3||0)-(b$3||0)},PriorityQueue$2.__super__.constructor.call(this,options)}return PriorityQueue$2})(AbstractPriorityQueue),PriorityQueue$1.ArrayStrategy=ArrayStrategy,PriorityQueue$1.BinaryHeapStrategy=BinaryHeapStrategy,PriorityQueue$1.BHeapStrategy=BHeapStrategy,module$1.exports=PriorityQueue$1},{"./PriorityQueue/AbstractPriorityQueue":2,"./PriorityQueue/ArrayStrategy":3,"./PriorityQueue/BHeapStrategy":4,"./PriorityQueue/BinaryHeapStrategy":5}],2:[function(_dereq_,module$1,exports$1){module$1.exports=(function(){function AbstractPriorityQueue(options){var ref;if(options?.strategy==null)throw`Must pass options.strategy, a strategy`;if(options?.comparator==null)throw`Must pass options.comparator, a comparator`;this.priv=new options.strategy(options),this.length=options?.initialValues?.length||0}return AbstractPriorityQueue.prototype.queue=function(value){this.length++,this.priv.queue(value)},AbstractPriorityQueue.prototype.dequeue=function(value){if(!this.length)throw`Empty queue`;return this.length--,this.priv.dequeue()},AbstractPriorityQueue.prototype.peek=function(value){if(!this.length)throw`Empty queue`;return this.priv.peek()},AbstractPriorityQueue.prototype.clear=function(){return this.length=0,this.priv.clear()},AbstractPriorityQueue})()},{}],3:[function(_dereq_,module$1,exports$1){var binarySearchForIndexReversed=function(array,value,comparator){var high,low=0,mid;for(high=array.length;low<high;)mid=low+high>>>1,comparator(array[mid],value)>=0?low=mid+1:high=mid;return low};module$1.exports=(function(){function ArrayStrategy(options){var ref;this.options=options,this.comparator=this.options.comparator,this.data=this.options.initialValues?.slice(0)||[],this.data.sort(this.comparator).reverse()}return ArrayStrategy.prototype.queue=function(value){var pos=binarySearchForIndexReversed(this.data,value,this.comparator);this.data.splice(pos,0,value)},ArrayStrategy.prototype.dequeue=function(){return this.data.pop()},ArrayStrategy.prototype.peek=function(){return this.data[this.data.length-1]},ArrayStrategy.prototype.clear=function(){this.data.length=0},ArrayStrategy})()},{}],4:[function(_dereq_,module$1,exports$1){module$1.exports=(function(){function BHeapStrategy(options){var arr,j$2,k$2,len,ref,ref1,shift,value;for(this.comparator=options?.comparator||function(a$3,b$3){return a$3-b$3},this.pageSize=options?.pageSize||512,this.length=0,shift=0;1<<shift<this.pageSize;)shift+=1;if(1<<shift!==this.pageSize)throw`pageSize must be a power of two`;for(this._shift=shift,this._emptyMemoryPageTemplate=arr=[],j$2=0,ref=this.pageSize;0<=ref?j$2<ref:j$2>ref;0<=ref?++j$2:--j$2)arr.push(null);if(this._memory=[],this._mask=this.pageSize-1,options.initialValues)for(ref1=options.initialValues,k$2=0,len=ref1.length;k$2<len;k$2++)value=ref1[k$2],this.queue(value)}return BHeapStrategy.prototype.queue=function(value){this.length+=1,this._write(this.length,value),this._bubbleUp(this.length,value)},BHeapStrategy.prototype.dequeue=function(){var ret=this._read(1),val=this._read(this.length);return--this.length,this.length>0&&(this._write(1,val),this._bubbleDown(1,val)),ret},BHeapStrategy.prototype.peek=function(){return this._read(1)},BHeapStrategy.prototype.clear=function(){this.length=0,this._memory.length=0},BHeapStrategy.prototype._write=function(index,value){for(var page=index>>this._shift;page>=this._memory.length;)this._memory.push(this._emptyMemoryPageTemplate.slice(0));return this._memory[page][index&this._mask]=value},BHeapStrategy.prototype._read=function(index){return this._memory[index>>this._shift][index&this._mask]},BHeapStrategy.prototype._bubbleUp=function(index,value){for(var compare=this.comparator,indexInPage,parentIndex,parentValue;index>1&&(indexInPage=index&this._mask,index<this.pageSize||indexInPage>3?parentIndex=index&~this._mask|indexInPage>>1:indexInPage<2?(parentIndex=index-this.pageSize>>this._shift,parentIndex+=parentIndex&~(this._mask>>1),parentIndex|=this.pageSize>>1):parentIndex=index-2,parentValue=this._read(parentIndex),!(compare(parentValue,value)<0));)this._write(parentIndex,value),this._write(index,parentValue),index=parentIndex},BHeapStrategy.prototype._bubbleDown=function(index,value){for(var childIndex1,childIndex2,childValue1,childValue2,compare=this.comparator;index<this.length;)if(index>this._mask&&!(index&this._mask-1)?childIndex1=childIndex2=index+2:index&this.pageSize>>1?(childIndex1=(index&~this._mask)>>1,childIndex1|=index&this._mask>>1,childIndex1=childIndex1+1<<this._shift,childIndex2=childIndex1+1):(childIndex1=index+(index&this._mask),childIndex2=childIndex1+1),childIndex1!==childIndex2&&childIndex2<=this.length)if(childValue1=this._read(childIndex1),childValue2=this._read(childIndex2),compare(childValue1,value)<0&&compare(childValue1,childValue2)<=0)this._write(childIndex1,value),this._write(index,childValue1),index=childIndex1;else if(compare(childValue2,value)<0)this._write(childIndex2,value),this._write(index,childValue2),index=childIndex2;else break;else if(childIndex1<=this.length)if(childValue1=this._read(childIndex1),compare(childValue1,value)<0)this._write(childIndex1,value),this._write(index,childValue1),index=childIndex1;else break;else break},BHeapStrategy})()},{}],5:[function(_dereq_,module$1,exports$1){module$1.exports=(function(){function BinaryHeapStrategy(options){var ref;this.comparator=options?.comparator||function(a$3,b$3){return a$3-b$3},this.length=0,this.data=options.initialValues?.slice(0)||[],this._heapify()}return BinaryHeapStrategy.prototype._heapify=function(){var i$3,j$2,ref;if(this.data.length>0)for(i$3=j$2=1,ref=this.data.length;1<=ref?j$2<ref:j$2>ref;i$3=1<=ref?++j$2:--j$2)this._bubbleUp(i$3)},BinaryHeapStrategy.prototype.queue=function(value){this.data.push(value),this._bubbleUp(this.data.length-1)},BinaryHeapStrategy.prototype.dequeue=function(){var last,ret=this.data[0];return last=this.data.pop(),this.data.length>0&&(this.data[0]=last,this._bubbleDown(0)),ret},BinaryHeapStrategy.prototype.peek=function(){return this.data[0]},BinaryHeapStrategy.prototype.clear=function(){this.length=0,this.data.length=0},BinaryHeapStrategy.prototype._bubbleUp=function(pos){for(var parent,x$2;pos>0&&(parent=pos-1>>>1,this.comparator(this.data[pos],this.data[parent])<0);)x$2=this.data[parent],this.data[parent]=this.data[pos],this.data[pos]=x$2,pos=parent},BinaryHeapStrategy.prototype._bubbleDown=function(pos){for(var last=this.data.length-1,left,minIndex,right,x$2;left=(pos<<1)+1,right=left+1,minIndex=pos,left<=last&&this.comparator(this.data[left],this.data[minIndex])<0&&(minIndex=left),right<=last&&this.comparator(this.data[right],this.data[minIndex])<0&&(minIndex=right),minIndex!==pos;)x$2=this.data[minIndex],this.data[minIndex]=this.data[pos],this.data[pos]=x$2,pos=minIndex},BinaryHeapStrategy})()},{}]},{},[1])(1)})}))()),import_median_quickselect_min=__toESM(require_median_quickselect_min()),import_image_type=__toESM(require_image_type());export{readImg as t};